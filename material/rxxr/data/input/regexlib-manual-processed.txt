# This will find URLs in plain text.  With or without protocol. It matches against all toplevel domains to find the URL in the text.
# ID: 1016
([\d\w-.]+?\.(a[cdefgilmnoqrstuwz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvxyz]|d[ejkmnoz]|e[ceghrst]|f[ijkmnor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eouw]|s[abcdeghijklmnortuvyz]|t[cdfghjkmnoprtvwz]|u[augkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw]|aero|arpa|biz|com|coop|edu|info|int|gov|mil|museum|name|net|org|pro)(\b|\W(?<!&|=)(?!\.\s|\.{3}).*?))(\s|$)

# Retrieves all anchor links in a html document, useful for spidering. You will need to do a replace of " and ' after the regular expression, as the expression gets all links. As far as I know there is no way, even with \1 groupings, of getting a condition on whether the link contains a ",' or nothing at all (" and ' is easy enough, but what happens if the link starts with ", and has a javascript function call with a string in it). If there is, it's probably quicker to do it like this and do a string replace anyway.
# ID: 903
<a\s*href=(.*?)[\s|>]

# match isbn 10 and 13
# ID: 3642
/((978[\--– ])?[0-9][0-9\--– ]{10}[\--– ][0-9xX])|((978)?[0-9]{9}[0-9Xx])/

# Matches email addresses.  Based on expression at regular-expressions.info/email.html modified to include all top-level domains (TLD)listed on wikipedia as of June 2010.  Needs to be updated as new TLDs are added.
# ID: 3050
^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+(?:[a-zA-Z]{2}|aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel)$

# Somewhat conservative expression for evaluating phone numbers.  Based off ideas found at http://stackoverflow.com/questions/123559/a-comprehensive-regex-for-phone-number-validation this allows country codes, with or without the + symbol, area codes surrounded by parenthesis (or not) and numbers delimited by spaces, periods or dashes.  You'll want to independently test for string length based on your needs.
# ID: 3052
^([\+][0-9]{1,3}([ \.\-])?)?([\(]{1}[0-9]{3}[\)])?([0-9A-Z \.\-]{1,32})((x|ext|extension)?[0-9]{1,4}?)$

# This pattern mathces the following date formats: DDMMMYY,DDMMMYYYY,DDMMMYY. The Pattern matches on leap year dates as well
# ID: 2111
^(d{0}|(31(?!(FEB|APR|JUN|SEP|NOV)))|((30|29)(?!FEB))|(29(?=FEB(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(29(?=FEB(((0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8])(JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC)((1[6-9]|[2-9]\d)\d{2}|\d{2}|d{0})$

# Matches both normalized and E notations, with or without spaces or negative numbers. Make sure to use a case insensitive pattern matcher. Group 1 is the significand, and either group 5 or group 7 is the exponent (one or the other will be null, but never both).
# ID: 2470
^(-?[1-9](\.\d+)?)((\s?[X*]\s?10[E^]([+-]?\d+))|(E([+-]?\d+)))$

# Used to validate Credit Card numbers, Checks if it contains 16 numbers in groups of 4 separated by -, ,or nothing
# ID: 529
^(\d{4}-){3}\d{4}$|^(\d{4} ){3}\d{4}$|^\d{16}$

# Check if the text is a valid firstname or lastname.It allows Characters,'- and space only
# ID: 531
^([a-zA-Z '-]+)$

# This regex matches FQDNs plus domains starting with an or containing asterisk. This is usefull for DNS configuration tools where you might have domains like *.domain.de or 12.152.80.in-addr.arpa.
# ID: 3494
^(?=^.{1,254}$)(^(?:(?!\.|-)([a-z0-9\-\*]{1,63}|([a-z0-9\-]{1,62}[a-z0-9]))\.)+(?:[a-z]{2,})$)$

# Matches numbers. May include decimals, thousands separators, and sign.
# ID: 3068
^\s*[+-]?\s*(?:\d{1,3}(?:(,?)\d{3})?(?:\1\d{3})*(\.\d*)?|\.\d+)\s*$

# This tests, are entered AW coordinates in correct short format, and it has no world info
# ID: 1704
^[0-9]+[NnSs] [0-9]+[WwEe]$

# Decimal like 123.23
# ID: 2495
^\d*[0-9](|.\d*[0-9]|)*$

# Word HTML cleanup code. Use this expression to get rid of most of the stuff that Word adds to an HTML document such as: lots of span elements, font-family and font-size style attributes, class attributes, a whole bunch of if-then statements. Use this expression in a regex.replace(originalHtml, regExpr, "").
# ID: 731
(?s)( class=\w+(?=([^<]*>)))|(<!--\[if.*?<!\[endif\]-->)|(<!\[if !\w+\]>)|(<!\[endif\]>)|(<o:p>[^<]*</o:p>)|(<span[^>]*>)|(</span>)|(font-family:[^>]*[;'])|(font-size:[^>]*[;'])(?-s)

# Path of files HTML and HTM
# ID: 1241
^(([a-zA-Z]:)|(\\{2}\w+)\$?)(\\(\w[\w ]*.*))+\.((html|HTML)|(htm|HTM))$

# Disallow ' or < or > or ? or % or ! or space in a string. Minimum character is 1 and maximum is 20 in a string.
# ID: 3150
^[^'<>?%!\s]{1,20}$

# User can specify n numbers of digits, upper case character and special character.
# ID: 3211
(?=^.{12,25}$)(?=(?:.*?\d){2})(?=.*[a-z])(?=(?:.*?[A-Z]){2})(?=(?:.*?[!@#$%*()_+^&}{:;?.]){2})(?!.*\s)[0-9a-zA-Z!@#$%*()_+^&]*$

# Regular Expression which does not allow SPACE but allows every possible alpha-numeric and special characters.
# ID: 3269
(?=^.{1,}$)(?!.*\s)[0-9a-zA-Z!@#$%*()_+^&\[\]]*$

# Regular Expression to validate file path and extension.Compatible with JavaScript and ASP.NET
# ID: 3312
^(?:[\w]\:|\\)(\\[a-z_\-\s0-9\.]+)+\.(txt|gif|pdf|doc|docx|xls|xlsx)$

# Password must contain at least one letter, at least one number, and be longer than six charaters.
# ID: 770
^(?=.*[0-9]+.*)(?=.*[a-zA-Z]+.*)[0-9a-zA-Z]{6,}$

# Validates a GUID/UUID, without capture, to the following patterns: [{hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh}],
# ID: 791
# Multiline
^((?-i:0x)?[A-Fa-f0-9]{32}|[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}|\{[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}\})$

# Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the .COM section.
# ID: 39
^[\w\.=-]+@[\w\.-]+\.[\w]{2,3}$

# Parses the objects out from an html header. These objects are: meta, style, link, and script. Use with the multiline option to pull from multine scripts and styles.
# ID: 2971
(<meta [.\w\W]*?\>)|(<style [.\w\W]*?</style>)|(<link [.\w\W]*?\>)|(<script [.\w\W]*?</script>)

# Could not find a regex that truly matched the rules here http://en.wikipedia.org/wiki/Social_Security_number#Valid_SSNs So I modified an existing one to match the valid SSN rules.
# ID: 2850
^((?!000)(?!666)(?:[0-6]\d{2}|7[0-2][0-9]|73[0-3]|7[5-6][0-9]|77[0-2]))-((?!00)\d{2})-((?!0000)\d{4})$

# I wrote this to parse the querystring into its key value parts. It will also match querystring keys without an associated value.
# ID: 2856
(?<=[\?|\&])(?<key>[^\?=\&\#]+)=?(?<value>[^\?=\&\#]*)

# Very easy expression to get the file name from a path. I couldn't find it so I wrote it and now I post it here! Hope it could help.
# ID: 794
/[^/]+$

# This one enables you to parse well-formed script tags to get both the src value and the block content, if specified.  I'm using this one in some AJAX where I get script blocks back in a text reponse and need to parse them and add them to the DOM so they get processed.
# ID: 1482
<script(?:(?:.*(?<src>(?<=src=")[^"]*(?="))[^>]*)|[^>]*)>(?<content>(?:(?:\n|.)(?!(?:\n|.)<script))*)</script>

# Other Swedish personnummer regexps do not take into account that at Swedish universities, foreigners might get special temporary personnummers with a "P", "T", or "F" instead of the first of the four last numbers.
# ID: 2524
^[0-9]{6}-[0-9pPtTfF][0-9]{3}$

# UK Postal Codes - The code is normally written in capital letters with a space between the outer and inner parts; it is understandable if the space is omitted.
# ID: 583
^[A-Za-z]{1,2}[\d]{1,2}([A-Za-z])?\s?[\d][A-Za-z]{2}$

# Take the output of the uptime command and split it into a useful array.
# ID: 2988
/^([0-2][0-9]\:[0-5][0-9]\:[0-5][0-9])\s+up\s+([0-9\:]{1,5})\s*(days|day|min|mins)?(?:\,\s+([0-9\:]{1,5})\s*(days|day|min|mins)?)?\,\s+([0-9]{1,4})\susers?\,\s+load\s+average\:\s+([0-9\.]{1,6})\,\s+([0-9\.]{1,6})\,\s+([0-9\.]{1,6})$/

# Use it for breaking-down a URI (URL, URN) reference into its main components: Scheme, Authority, Path, Query and Fragment.
# ID: 115
^(?=[^&])(?:(?<scheme>[^:/?#]+):)?(?://(?<authority>[^/?#]*))?(?<path>[^?#]*)(?:\?(?<query>[^#]*))?(?:#(?<fragment>.*))?

# Identifies the URLs in an arbitrary string of text, where by “arbitrary” let’s agree we mean something unstructured such as an email message or a tweet.  Source: daringfireball.net
# ID: 2840
\b(([\w-]+://?|www[.])[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|/)))

# This will accept all the Mobile nos starting with 8 or 9 and having exactly 10 digits (total) or it must be blank
# ID: 2931
^[89][0-9]{9}

# Accepts everything except Zero and Double Zeros(0,00 are invalid Values) for two Non Zero digits without using a RangeValidator
# ID: 3091
[0][^0]|([^0]{1}(.){1})|[^0]*

# The time should be fractional number and divisible by 0.005
# ID: 2228
^[0-9]+\.?[0-9]?[0-9]?[0,5]?$

# This expression is to validate indian mobile nos
# ID: 2487
^((\+){0,1}91(\s){0,1}(\-){0,1}(\s){0,1}){0,1}9[0-9](\s){0,1}(\-){0,1}(\s){0,1}[1-9]{1}[0-9]{7}$

# To validate a number of 10 digits before the decimal point and atmost 2 digits after it
# ID: 2488
(?!^0*$)(?!^0*\.0*$)^\d{1,10}(\.\d{1,2})?$

# (?!^0*$)(?!^0*\.0*$)^\d{1,2}(\.\d{1,4})?$
# ID: 2493
Percentage allowing upto 4 places of decimal

# Validates Dutch Postal Codes (ZipCode). There was a previous one listed here, but it's not entirely correct. Namely that dutch postal codes can contain a zero but cannot start with one, so this one is the adjusted version.
# ID: 367
^[1-9][0-9]{3}\s?[a-zA-Z]{2}$

# Double byte charactors validator.
# ID: 395
^[\u0081-\uFFFF]{1,}$

# http://www.kaufenakkus.com/dell-vostro-1310.html akku Dell Vostro 1310
# ID: 3561
akku Dell Vostro 1310

# Simple check of valid UK VAT Registration numbers. The standard format for UK VAT number must be 9 characters long or 12 characters if a branch trader. The GB prefix has been included as optional, but technically you should include it. The UK VAT format also includes Government Departments and Health Authorities, but I have excluded them for the moment.
# ID: 830
^([GB])*(([1-9]\d{8})|([1-9]\d{11}))$

# Matches an israely phone number with country code. With or without the plus sign. Also allows two or one digit in city code. Checks for a valid city code (02,03,04,08,09)
# ID: 911
^\+?972(\-)?0?[23489]{1}(\-)?[^0\D]{1}\d{6}$

# Downloadlinks of the 1-Click-Hoster uploaded.to
# ID: 2244
http://(?:www\.|)uploaded\.to/\?id=[a-z0-9]{6}

# This matches the modifiers section of a properly formed PCRE RegEx (at least in PHP).  This of course assumes that the delimiters are not any of the modifiers letters, if that's even possible.
# ID: 1543
/[^imsxeADSUXu]([imsxeADSUXu]*)$/

# Find apostrophes in text.
# ID: 2772
'([dmstrl])([ .,?!\)\\/<])

# Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. This is a better solution (I think) than #343. Works in Javascript and C#.
# ID: 1412
^.*(([^\.][\.][wW][mM][aA])|([^\.][\.][mM][pP][3]))$

# Simple Expression to evaluate a Mexican CURP Code
# ID: 2400
^[a-zA-Z]{4}\d{6}[a-zA-Z]{6}\d{2}$

# Mexican RFC code without Homonimia or separators
# ID: 2401
^[A-Za-z]{3,4}[0-9]{6}$

# Mexican RFC Homonimia Code
# ID: 2402
^[0-9a-zA-z]{3}$

# This exp will parse out space delimited strings with consideration to single quotes.  I use it with SQL statements.
# ID: 938
(?=(?:[^\']*\'[^\']*\')*(?![^\']*\'))

# following a bit of work this morning trying to get something to strip out arbitrary html but leave 'known' tags in place, we have come up with the following which may be useful. This uses the 'negative lookahead' construct using '?!'  It looks for an angle bracket and perhaps a backslash, as long as it is *not* followed by one of the terms in the ?! section. The brackets in this section do not return a value, they are part of the construct. This regexp can therefore be used to replace all unknown tags  with blanks. Obviously you can add other 'good' html tags to the list.
# ID: 1710
<\/{0,1}(?!\/|b>|i>|p>|a\s|a>|br|em>|ol|li|strong>)[^>]*>

# Matches HTML of XML tags, with or without attributes (single-, double-, or non-quoted), closing tags, or self-closing singleton tags.
# ID: 236
</?(\w+)(\s*\w*\s*=\s*("[^"]*"|'[^']'|[^>]*))*|/?>

# Get the URL, target, class, style and description from a hyperlink
# ID: 1523
<a\s{1}href="(?<url>.*?)"(\s?target="(?<target>_(blank|new|parent|self|top))")?(\s?class="(?<class>.*?)")?(\s?style="(?<style>.*?)")?>(?<title>.*?)</a>

# Version 1.3.0: I needed a regexp to validate URL's without the ht(f)tp(s):// and include North American domains (like .us and .ca) and there didn't seem to be one available...so I created one. It will also work with ASP QueryStrings and anchor URL's. If you have a problem with the expression or have any suggestions to improve, please write me and let me know. Added .uk domain and expression now allows for URLs that contain JSP session IDs. 4/14/04 - added ability to include URLs that start with server names.
# ID: 622
^(((ht|f)tp(s?))\://)?(www.|[a-zA-Z].)[a-zA-Z0-9\-\.]+\.(com|edu|gov|mil|net|org|biz|info|name|museum|us|ca|uk)(\:[0-9]+)*(/($|[a-zA-Z0-9\.\,\;\?\'\\\+&%\$#\=~_\-]+))*$

# matches a six character "password" that has to consist of numbers and letters with at least one letter in it.
# ID: 278
^(?![0-9]{6})[0-9a-zA-Z]{6}$

# I use this expression to read bounced email addresses returned by the system administrator. The body of the subject should contain the email address somewhere but the location varies.
# ID: 956
^[\n <"']*([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+)

# Drops the first subdomain from a domain name with at least one subdomain.  Fails if the domain does not contain a subdomain.
# ID: 3010
^\w+\.((?:\w+\.)+\w+)$

# Email validation based on Rob Eberhardt's (Thanks, Rob!) email expression, but allows single letter subdomains...
# ID: 599
^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@(([0-9a-zA-Z])+([-\w]*[0-9a-zA-Z])*\.)+[a-zA-Z]{2,9})$

# Polish stationary phone number. Mask +48 XX XXXXXXX
# ID: 3207
^(\+48\s*)?\d{2}\s*\d{3}(\s*|\-)\d{2}(\s*|\-)\d{2}$

# allow to insert input for polish tax identyfication number (NIP). Mask accepted:
# ID: 3208
^((\d{3}[- ]\d{3}[- ]\d{2}[- ]\d{2})|(\d{3}[- ]\d{2}[- ]\d{2}[- ]\d{3}))$

# Useful for validating a basic singleline mathematical expression prior to calculating its value (as with eval).
# ID: 2970
^(?:(?>(?:\-(?=\d|\())|(?:(?<=\d|\))(?:\+|\/|\*)(?=\d|\(|\-))|(?<parenthesis>(?<=^|\+|\/|\-|\*|\()\((?=\d|\(|\-))|(?<-parenthesis>(?<=\d|\)))(?!\d))|(?:(?<=\(|\-|\+|\*|\/|^)(?:\d+(?:\,\d{1,4})?)(?=$|\)|\-|\+|\*|\/))) + (?(parenthesis)(?!)))$

# with or without area code (of various forms)(does not allow for unbalanced parens in the area code).  With or without an extension (of various forms).  Does not allow for leading or trailing space.
# ID: 1515
^(((\(\d{3}\)|\d{3})( |-|\.))|(\(\d{3}\)|\d{3}))?\d{3}( |-|\.)?\d{4}(( |-|\.)?([Ee]xt|[Xx])[.]?( |-|\.)?\d{4})?$

# This validation forces a value wheter to be strict niced or plain input of a numerical value.
# ID: 2448
(?:^(?:-)?(?:\d{1,3}\.(?:\d{3}\.)*\d{3})(?:\,\d+)?$|^(?:-)?\d*(?:\,\d+)?$)

# This Pattern matches HTML attributes with quoted quotes or other non-word characters correctly. I used it in an parser-engine.
# ID: 1214
(?:[\w]*) *= *"(?:(?:(?:(?:(?:\\\W)*\\\W)*[^"]*)\\\W)*[^"]*")

# I don't give a f*** to the RFC, fix it yourself for RFC, I just need a valid webresource location. So add forbidden characters as you need them in the character classes or use it as it is. This RegEx is not for searching valid URLs, just for validating. Look at the trailing $.
# ID: 1215
(?:(?:http|https)://(?:(?:[^/&=()/§, ]*?)*\.)+(?:\w{2,3})+?)(?:/+[^ ?,'§$&()={\[\]}]*)*(?:\?+.*)?$

# This Pattern matches a HTML like tag and its closing tag without any childtags, that was identified by an attribute or anything identifiable (?) mark inside the opening tag.
# ID: 1188
(<[^>]*?tag[^>]*?(?:identify_by)[^>]*>)((?:.*?(?:<[ \r\t]*tag[^>]*>?.*?(?:<.*?/.*?tag.*?>)?)*)*)(<[^>]*?/[^>]*?tag[^>]*?>)

# Check for IP address
# ID: 3087
^\d{1,3}[.]\d{1,3}[.]\d{1,3}[.]\d{1,3}$

# Regex for postal code in Portugal
# ID: 3613
[0-9]{4}-[0-9]{3}

# This regular expression accepts any combination of alphabets or alphanumeric.
# ID: 2716
^([A-Za-z]|[A-Za-z][0-9]*|[0-9]*[A-Za-z])+$

# This regular expression parses virtually any variety of U.S. phone numbers--with or without an extension. If you want a version without the named groups, you can use: (\+1|1)?[ \-\.]?\(?[0-9]{3}\)?[ \-\.]?[0-9]{3}[ \-\.]?[0-9]{4}[ \.]*(ext|x)?[ \.]*[0-9]{0,5}
# ID: 3453
(\+1|1)?[ \-\.]?\(?(?<areacode>[0-9]{3})\)?[ \-\.]?(?<prefix>[0-9]{3})[ \-\.]?(?<number>[0-9]{4})[ \.]*(ext|x)?[ \.]*(?<extension>[0-9]{0,5})

# This regular expression is designed just to extract the domain name from a URL. A domain name may neither start with nor end with a dash. I didn't take the time to add in this check and am actually not sure that it could be easily done. Try it for yourself to understand why.
# ID: 3454
(http[s]?://)?([A-Za-z0-9-]\.)*(?<domainName>([A-Za-z0-9-]+\.)[A-Za-z]{2,3})/?.$

# This will validate only time.
# ID: 2224
^(|(0\d)|(1[0-2])):(([0-5]\d)):(([0-5]\d))\s([AP]M)$

# This RE recognizes IPv6 addresses for all the representations described by RFC 2373:
# ID: 2919
(::|(([a-fA-F0-9]{1,4}):){7}(([a-fA-F0-9]{1,4}))|(:(:([a-fA-F0-9]{1,4})){1,6})|((([a-fA-F0-9]{1,4}):){1,6}:)|((([a-fA-F0-9]{1,4}):)(:([a-fA-F0-9]{1,4})){1,6})|((([a-fA-F0-9]{1,4}):){2}(:([a-fA-F0-9]{1,4})){1,5})|((([a-fA-F0-9]{1,4}):){3}(:([a-fA-F0-9]{1,4})){1,4})|((([a-fA-F0-9]{1,4}):){4}(:([a-fA-F0-9]{1,4})){1,3})|((([a-fA-F0-9]{1,4}):){5}(:([a-fA-F0-9]{1,4})){1,2}))

# Validate the year month and day.
# ID: 2225
((19|20)[0-9]{2})-(([1-9])|(0[1-9])|(1[0-2]))-((3[0-1])|([0-2][0-9])|([0-9]))

# A simple regular expression to determine if a subnet mask is contiguous; that is, the submask must start with a 1 bit followed by 0 or more 1 bits, followed by 1 or more 0 bits until the end of the submask.
# ID: 408
^1+0+$

# Matches dates with the following format
# ID: 244
^([1][12]|[0]?[1-9])[\/-]([3][01]|[12]\d|[0]?[1-9])[\/-](\d{4}|\d{2})$

# Matches all non-printable characters in the ASCII-table, such as Data Link Escape and Cancel
# ID: 3307
[\x00-\x1F\x7F]

# This expression is little tricky since the $ sign is includeded in the
# ID: 668
^\$[+-]?([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(\.[0-9]{1,2})?$

# Used for matching a URL and can be used for extracting the domain name from a given URL ending with '/'.
# ID: 2178
^http[s]?://([a-zA-Z0-9\-]+\.)*([a-zA-Z]{3,61}|[a-zA-Z]{1,}\.[a-zA-Z]{2})/.*$

# Polish national ID number PESEL (Powszechny Elektroniczny System Ewidencji Ludnosci).
# ID: 2896
[0-9]{4}[0-3]{1}[0-9}{1}[0-9]{5}

# Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996, so no worries with the y3k bug.
# ID: 1845
(15(8[48]|9[26]))|((1[6-9]|[2-9]\d)(0[48]|[13579][26]|[2468][048]))|(([2468][048]|16|3579[26])00)

# Checks whether email in the string that must be an E-mail address
# ID: 1566
^[a-z0-9_]{1}[a-z0-9\-_]*(\.[a-z0-9\-_]+)*@[a-z0-9]{1}[a-z0-9\-_]*(\.[a-z0-9\-_]+)*\.[a-z]{2,4}$

# simple Name or Full Name pattern.
# ID: 3423
[a-zA-Z]*( [a-zA-Z]*)?

# Valida e mascara CNPJ ou CPF dependendo do valor informado. Se informado dois digitos mais o ponto, será mascarado CNPJ se nao , CPF
# ID: 3102
(\d{2}\.\d{3}\.\d{3}\/\d{4}\-\d{2})|(\d{3}\.\d{3}\.\d{3}\-\d{2})

# Allow Decimal values as [decimal](*, 2),  scale length between 0 and 2
# ID: 1820
^\d*[0-9](\.\d?[0-9])?$

# Allow Percentage with optional scale (max length of 2) between (00.00 and 100)
# ID: 1821
^((\d{0,1}[0-9](\.\d{0,1}[0-9])?)|(100))$

# Match any image insert in a tag .
# ID: 86
<[^>]*\n?.*=("|')?(.*\.jpg)("|')?.*\n?[^<]*>

# This regex will validate whether the value is a valid directory path.
# ID: 3456
([A-Z]:\\[^/:\*;\/\:\?<>\|]+)|(\\{2}[^/:\*;\/\:\?<>\|]+)

# Gets serial from BIND zone file
# ID: 3097
(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}\.?\t*\s*){2}\(\r*\n*([0-9]{1,})

# This is just a regular special char expression used to get the hax0rs off your back (hopefully).  You can use this for regular open name checking if you wanted.  It only fails on the insert of anything other than a-z, A-Z, and ' or whitespace. I'm open to suggestions, but try to email them to me as well as posting them to help others.  Thanks.
# ID: 309
^([a-zA-Z.\s']{1,50})$

# This Regular expression will simply not allow more than a single space to be entered between two words of a sentence.It will also prohibit user to enter space at the begining and at the end of a sentence.It will require a minimum of juz 2 alphabets for making it a valid expression
# ID: 1718
([a-zA-Z]{1}[a-zA-Z]*[\s]{0,1}[a-zA-Z])+([\s]{0,1}[a-zA-Z]+)

# Allow entering Indian Permenant Account Number allocated by Income Tax Authority
# ID: 2376
^[A-Z]{5}[0-9]{4}[A-Z]{1}$

# Find differents parts of a french mail's address.
# ID: 2145
((^[0-9]*).?((BIS)|(TER)|(QUATER))?)?((\W+)|(^))(([a-z]+.)*)([0-9]{5})?.(([a-z\'']+.)*)$

# Matches all packets that have the string username and password
# ID: 3433
username=(.*)&password=(.*)

# Regex to grab emil address's
# ID: 3434
\b[A-z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b

# ukrainian phone numbers in Kiev
# ID: 2242
^((8|\+38)-?)?(\(?044\)?)?-?\d{3}-?\d{2}-?\d{2}$

# Duration validation similar to MS Project (5d16h45m, etc).  Does not allow more than 365 days, 23 hrs or 59 min.
# ID: 2730
^(([0-9]{1})|([0-9]{1}[0-9]{1})|([1-3]{1}[0-6]{1}[0-5]{1}))d(([0-9]{1})|(1[0-9]{1})|([1-2]{1}[0-3]{1}))h(([0-9]{1})|([1-5]{1}[0-9]{1}))m$

# This Works good until we want a multiple email address validator, I am working on it to make it work with the multiple email address, If anyone can work on this part as to validate a multiple email address then that will produce a very good expression, i think the best of this kind. AIM - to Validate Mohit <myadav@yahoo.com>; Rohit <ryadav@yahoo.com>; .........(any number of times)
# ID: 749
^[a-zA-Z]+(([\'\,\.\- ][a-zA-Z ])?[a-zA-Z]*)*\s+<(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})>$|^(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})$

# Simple email regex following some liberal email address validation. Requires non-whitespace name (but allows any other character), an @ symbol, then a non-period character, then some non-whitespace text (but allows just about everything else), and finishes with a tld that is 2 to 10 chars long. Two-characters is the universal minimum, 10 seemed like a good upper limit for now and allows room to grow. You can use this for a quick sanity check. Yes, the user can still enter invalid email addys, but then they won't get their emails, will they?
# ID: 1794
^[^\s]+@[^\.][^\s]{1,}\.[A-Za-z]{2,10}$

# Check email format
# ID: 2099
^[\w-]+(\.[\w-]+)*@([a-z0-9-]+(\.[a-z0-9-]+)*?\.[a-z]{2,6}|(\d{1,3}\.){3}\d{1,3})(:\d{4})?$

# This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.
# ID: 2100
^[-]?([1-9]{1}[0-9]{0,}(\.[0-9]{0,2})?|0(\.[0-9]{0,2})?|\.[0-9]{1,2})$

# Telephone number filter - use to catch and replace phone numbers where you don't want them to appear.
# ID: 2101
(\+)?([-\._\(\) ]?[\d]{3,20}[-\._\(\) ]?){2,10}

# DateTime format DD/MM/YYYY HH:MM:SS AM
# ID: 2102
(?n:^(?=\d)((?<day>31(?!(.0?[2469]|11))|30(?!.0?2)|29(?(.0?2)(?=.{3,4}(1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00))|0?[1-9]|1\d|2[0-8])(?<sep>[/.-])(?<month>0?[1-9]|1[012])\2(?<year>(1[6-9]|[2-9]\d)\d{2})(?:(?=\x20\d)\x20|$))?(?<time>((0?[1-9]|1[012])(:[0-5]\d){0,2}(?i:\ [AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$)

# IPv6 address (128 bit). Matches hexadecimal patterns and single 0 in the address.
# ID: 1115
^([0-9a-fA-F]{4}|0)(\:([0-9a-fA-F]{4}|0)){7}$

# Port Numbers: Well Known Ports: 0 through 1023.  Matches numbers in range of 0 through 1023.
# ID: 1116
^(102[0-3]|10[0-1]\d|[1-9][0-9]{0,2}|0)$

# Port Numbers: Registered Ports: 1024 through 49151.  Matches numbers in range of 1024 through 49151.
# ID: 1117
^(4915[0-1]|491[0-4]\d|490\d\d|4[0-8]\d{3}|[1-3]\d{4}|[2-9]\d{3}|1[1-9]\d{2}|10[3-9]\d|102[4-9])$

# Port Numbers: Dynamic and/or Private Ports: 49152 through 65535.  Matches numbers in range of 49152 through 65535.
# ID: 1118
^(6553[0-5]|655[0-2]\d|65[0-4]\d\d|6[0-4]\d{3}|5\d{4}|49[2-9]\d\d|491[6-9]\d|4915[2-9])$

# Port Numbers: Well Known Ports & Registered Ports: 0 through 49151.  Matches numbers in range of 0 through 49151.
# ID: 1119
^(4915[0-1]|491[0-4]\d|490\d\d|4[0-8]\d{3}|[1-3]\d{4}|[1-9]\d{0,3}|0)$

# Port Numbers: Well Known Ports, Registered Ports & Dynamic and/or Private Ports: 0 through 65536.  Matches numbers in range of 0 through 65536.
# ID: 1120
^(6553[0-5]|655[0-2]\d|65[0-4]\d\d|6[0-4]\d{3}|[1-5]\d{4}|[1-9]\d{0,3}|0)$

# Matches a URL string by: protocol,subdomain,domain,ip address,port number,path and/or filename
# ID: 1121
^((([hH][tT][tT][pP][sS]?|[fF][tT][pP])\:\/\/)?([\w\.\-]+(\:[\w\.\&%\$\-]+)*@)?((([^\s\(\)\<\>\\\"\.\[\]\,@;:]+)(\.[^\s\(\)\<\>\\\"\.\[\]\,@;:]+)*(\.[a-zA-Z]{2,4}))|((([01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}([01]?\d{1,2}|2[0-4]\d|25[0-5])))(\b\:(6553[0-5]|655[0-2]\d|65[0-4]\d{2}|6[0-4]\d{3}|[1-5]\d{4}|[1-9]\d{0,3}|0)\b)?((\/[^\/][\w\.\,\?\'\\\/\+&%\$#\=~_\-@]*)*[^\.\,\?\"\'\(\)\[\]!;<>{}\s\x7F-\xFF])?)$

# Matches a time string.  A loose validation for easy user entry. Saves the information needed for a correct time setting.
# ID: 1122
^((0?[1-9]|1[012])(\s*:\s*([0-5]\d))?(\s*:\s*([0-5]\d))?(\s*([AaPp])[Mm]?)$|(2[0-3]|[1]\d|0?\d)(\s*:\s*([0-5]\d))(\s*:\s*([0-5]\d))?)$

# This regular expressions matches phone numbers with area codes and optional US country code and optional phone extension.  User have so many ways of entering phone numbers into input fields.  This allows for some of the ones I've encountered.  Feel free to contact me if you find ones that do not match.
# ID: 458
^(1\s*[-\/\.]?)?(\((\d{3})\)|(\d{3}))\s*[-\/\.]?\s*(\d{3})\s*[-\/\.]?\s*(\d{4})\s*(([xX]|[eE][xX][tT])\.?\s*(\d+))*$

# California Resale License number validator. Validates Letters and Numbers or Number only. Letters: First 2 letters can be SR, SS, ST , SX, SY, SZ (TAT Code)  Next optional letter can be S,X,Y,Z.  Next letters must be a minimum of two and a maximum of 3 (District Code).  Numbers:  Can be 8-9 numbers. Numbers can be delimited with a hypen or spaces after the first 2 numbers.  Note: I use () to extract the information I want for use in other scripts.
# ID: 506
^((([sS][r-tR-Tx-zX-Z])\s*([sx-zSX-Z])?\s*([a-zA-Z]{2,3}))?\s*(\d\d)\s*-?\s*(\d{6,7}))$

# Matches the 216 web colors with or without the '#' sign.
# ID: 528
^#?(([fFcC0369])\2){3}$

# Check and parse a DOCTYPE tag elements: (topElement, availability, registration, organization, type, label, language, url)
# ID: 3054
\<\!doctype\s+(([^\s\>]+)\s+)?(([^\s\>]+)\s*)?(\"([^\/]+)\/\/([^\/]+)\/\/([^\s]+)\s([^\/]+)\/\/([^\"]+)\")?(\s*\"([^\"]+)\")?\>

# Hexadecimal color values to validate the system must begin with a # symbol, which can be combination of numbers and letters AF, but the letters must be uppercase.
# ID: 2994
^#(\d{6})|^#([A-F]{6})|^#([A-F]|[0-9]){6}

# US 10-Digit Phone number matching.
# ID: 1312
^\s*([\(]?)\[?\s*\d{3}\s*\]?[\)]?\s*[\-]?[\.]?\s*\d{3}\s*[\-]?[\.]?\s*\d{4}$

# UK National Insurance Number (NINO) validation. (The following modifications have been made: Only A to D are permitted as the last letter, and all letters should be in uppercase. For temporary numbers F and M are permitted for female and male holders.)
# ID: 228
^[A-Z]{2}[0-9]{6}[A-DFM]{1}$

# Matches UK postcodes according to the following rules 1. LN NLL eg N1 1AA 2. LLN NLL eg SW4 0QL 3. LNN NLL eg M23 4PJ 4. LLNN NLL eg WS14 0JT 5. LLNL NLL eg SW1N 4TB 6. LNL NLL eg W1C 8LQ. Modifications: 1) Doesn't allow leading zeros in first part (outward) eg BT01 3RT is incorrect; it should be BT1 3RT. 2) Only allows uppercase letters, which is the preference of the UK Post Office. 3) Permits the only postcode to break the rules - GIR 0AA (for the old Girobank, now Alliance & Leicester bank, address)
# ID: 229
^[A-Z]{1,2}[1-9][0-9]?[A-Z]? [0-9][A-Z]{2,}|GIR 0AA$

# Matches token words based on the use of a "$" (USD) prefix.
# ID: 2633
(\$(([0-9]?)[a-zA-Z]+)([0-9]?))

# Removes RTF formatting from a string
# ID: 1655
^\{(.+)|^\\(.+)|(\}*)

# Validates almost all email addresses. Tested and running fine on a major web portal
# ID: 2318
^([a-zA-Z0-9][a-zA-Z0-9_]*(\.{0,1})?[a-zA-Z0-9\-_]+)*(\.{0,1})@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|([a-zA-Z0-9\-]+(\.([a-zA-Z]{2,10}))(\.([a-zA-Z]{2,10}))?(\.([a-zA-Z]{2,10}))?))[\s]*$

# Accepts only characters in small and caps.
# ID: 2319
/^[a-zA-Z\s]+$/

# Simple parser of XPath, it doesn't handle the more complex statements but can be of use in some situations.
# ID: 545
^(?<path>(/?(?<step>\w+))+)(?<predicate>\[(?<comparison>\s*(?<lhs>@\w+)\s*(?<operator><=|>=|<>|=|<|>)\s*(?<rhs>('[^']*'|"[^"]*"))\s*(and|or)?)+\])*$

# Match Canadia Zip Code. You can have a space in the middle Like T2P 3C7, or no space like T2P3C7
# ID: 118
^[a-zA-Z][0-9][a-zA-Z]\s?[0-9][a-zA-Z][0-9]$

# This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.
# ID: 122
^((\d{5}-\d{4})|(\d{5})|([A-Z]\d[A-Z]\s\d[A-Z]\d))$

# Matches any statements in VBScript, such as If, ElseIf, Else, End if, Select Case, etc...
# ID: 1502
(?<=(?:\n|:|^)\s*?)(if|end\sif|elseif|else|for\seach|for|next|call|class|exit|do|loop|const|dim|erase|option\s(?:explicit|implicit)|(?:public|private|end)\ssub|(?:public|private|end)\sfunction|private|public|redim|select\scase|end\sselect|case\selse|case|set|while|wend|with|end\swith|on\serror\sgoto\s0|on\serror\sresume\snext|exit|end\sclass|property\slet|property\sget|property\sset)(?=\s|$)

# Matches all know ASP3.0 objects and their members.
# ID: 1503
(?<=(?:\n|:|&|\()\s*?)(Application\.Unlock|Application\.Lock|Application\.Contents\.RemoveAll|Application\.Contents\.Remove|Request\.BinaryRead|Request\.ClientCertificate|Request\.Cookies|Request\.Form|Request\.QueryString|Request\.ServerVariables|Request\.TotalBytes|Response\.AddHeader|Response\.AppendToLog|Response\.BinaryWrite|Response\.Clear|Response\.End|Response\.Flush|Response\.Redirect|Response\.Write|Response\.Buffer|Response\.CacheControl|Response\.Charset|Response\.CodePage|Response\.ContentType|Response\.Cookies|Response\.Expires|Response\.ExpiresAbsolute|Response\.IsClientConnected|Response\.LCID|Response\.PICS|Response\.Status|Server\.ScriptTimeout|Server\.CreateObject|Server\.Execute|Server\.GetLastError|Server\.HTMLEncode|Server\.MapPath|Server\.Transfer|Server\.URLEncode|Session\.Abandon|Session\.Contents\.Remove|Session\.Contents\.RemoveAll|Session\.CodePage|Session\.Contents|Session\.LCID|Session\.SessionID|Session\.StaticObjects|Session\.Timeout|Application|Session|Request)(?=\s|\.|\()

# Matches all(?) basic functions for VBScript (VB some in).
# ID: 1504
(?<=\s|:|&|\()(Abs|Array|Asc|Atn|CBool|CByte|CCur|CDate|CDbl|Chr|CInt|CLng|Conversions|Cos|CreateObject|CSng|CStr|DateAdd|DateDiff|DatePart|DateSerial|DateValue|Date|Day|DerivedMath|Escape|Eval|Exp|Filter|FormatCurrency|FormatDateTime|FormatNumber|FormatPercent|GetLocale|GetObject|GetRef|Hex|Hour|InputBox|InStr|InStrRev|Int|Fix|IsArray|IsDate|IsEmpty|IsNull|IsNumeric|IsObject|Join|LBound|LCase|Left|Len|LoadPicture|Log|LTrim|RTrim|Trim|Maths|Mid|Minute|Month|MonthName|MsgBox|Now|Oct|Replace|RGB|Right|Rnd|Round|ScriptEngineBuildVersion|ScriptEngineMajorVersion|ScriptEngineMinorVersion|ScriptEngine|Second|SetLocale|Sgn|Sin|Space|Split|Sqr|StrComp|String|StrReverse|Tan|Timer|TimeSerial|TimeValue|Time|TypeName|UBound|UCase|Unescape|VarType|WeekdayName|Weekday|Year)(?=\()

# Matches all keywords in VB and VBScript.
# ID: 1505
(?<=[\s=&\+\-,\(\)])(True|False|Nothing|Empty|Null)(?=[\s=&\+\-,\(\)])

# Matches all textual (not +, -, etc) operators in VB and VBScript.
# ID: 1506
(?<=\s)(And|Or|Eqv|Imp|Is|Mod|Not|Xor)(?=\s)

# Matches all tabs or spaces at the end of a line.
# ID: 1507
[ \t]*?(?=\r?\n)

# This expression matches all VBScript or VB code. Line comments (with ') and strings are inlcuded in named groups. Strings with double quotes (i.e. "this is my ""string"".") is supported. Expression is only tested with RegEx for .net 2.0.
# ID: 1499
(?<Code>[\s\S]*?)(?<NonCode>'.*?\r?\n|(?<quot>"|')(?:(?:(?!\<quot>).|\<quot>{2})*)(?:\<quot>))

# This matches all code in a VBScript or VB code. Line comments (with ') and strings are inlcuded in named groups.
# ID: 1500
(?<Code>[\s\S]*?)(?<Comment>'.*?\r?\n|(?<quot>"|')(?:(?:(?!\<quot>).|\<quot>{2})*)(?:\<quot>))

# Based on some of the other patterns on RegExpLib. This is the ISO way of writing dates.
# ID: 694
^((((19|20)(([02468][048])|([13579][26]))-02-29))|((20[0-9][0-9])|(19[0-9][0-9]))-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))$

# Validates UNC Paths, with or without files. Does not validate on shares ($) or local files (c:\xxx).
# ID: 865
^\\(\\[\w-]+){1,}(\\[\w-()]+(\s[\w-()]+)*)+(\\(([\w-()]+(\s[\w-()]+)*)+\.[\w]+)?)?$

# I'm using this to match Slovenian phone numbers. It's a bit rusty... If you have better version or updated please send it to me.
# ID: 1692
^(([0-9]{3})[ \-\/]?([0-9]{3})[ \-\/]?([0-9]{3}))|([0-9]{9})|([\+]?([0-9]{3})[ \-\/]?([0-9]{2})[ \-\/]?([0-9]{3})[ \-\/]?([0-9]{3}))$

# Remove favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for bookmark backup and transfer).
# ID: 2206
ICON=[a-zA-Z0-9/\+-;:/-/\"=]*

# Esta es la expresion regular adaptada por mi para validar telefonos fijos chilenos de cualquier compañia, espero sirva a alguien
# ID: 2310
^((\(\d{3}\) ?)|(\d{3}-)|(\(\d{2}\) ?)|(\d{2}-)|(\(\d{1}\) ?)|(\d{1}-))?\d{3}-(\d{3}|\d{4})

# Matches US phone numbers with area code inclosed in parents...
# ID: 1434
^\(?\d{3}?\)?\-?\d{3}?\-?\d{4}?$

# United Kingdom Postcode expression, modified for use with Microsoft.Net regular expression validations.
# ID: 1255
(^(((GIR)\s{0,1}((0AA))))|(([A-PR-UWYZ][0-9][0-9]?)|([A-PR-UWYZ][A-HK-Y][0-9][0-9]?)|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\s{0,1}([0-9][ABD-HJLNP-UW-Z]{2})$)

# Validate “Time” Data to Work with SQL Server
# ID: 172
(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])(\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)|(^([0-9]|[1][0-9]|[2][0-3])(\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)

# This expression matches date and time (24 hour) both in format dd-MMM-yyyy HH:mm:ss. Only the short form of month is allowed i.e. Jan not January. The month names are also case sensitive. The second part of the time is optional. Also the leading zeros for day, hour, minute and seconds are optional.
# ID: 2070
^((31(?!([-])(Feb|Apr|June?|Sep|Nov)))|((30|29)(?!([-])Feb))|(29(?=([-])Feb([-])(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8])([-])(Jan|Feb|Ma(r|y)|Apr|Ju(l|n)|Aug|Oct|(Sep|Nov|Dec))([-])((1[6-9]|[2-9]\d)\d{2}\s(([0-1]?[0-9])|([2][0-3])):([0-5]?[0-9])(:([0-5]?[0-9]))?)$

# This expression checks the validity of a date (US, but it is easily editable for other format's). Year's 1990-9999, Month's 1 or 01 to 12, Day's 1 or 01 to 31. Still needs to have individual months added (i.e., Feb's 28 days), and some how to check for leap year...the months issue should not be to hard, but the leap year seems like a real chore. Please let me know if you have any suggestions for leap year.
# ID: 60
^[0,1]?\d{1}\/(([0-2]?\d{1})|([3][0,1]{1}))\/(([1]{1}[9]{1}[9]{1}\d{1})|([2-9]{1}\d{3}))$

# Check for person name in database for example.
# ID: 3242
^[a-zA-Z][a-zA-Z\-' ]*[a-zA-Z ]$

# This expressions parses one line from a CSV file which has been written with Excel. It does cover all variants: simple value, value masked by double quotes (including semicolons between double quotes which don't count) and double quotes masked by double quotes (""). Replace all semicolons within the regex to change the separator character.
# ID: 1520
;?(?:(?:"((?:[^"]|"")*)")|([^;]*))

# This expression checks whether the string contains lower or uppercase characters and numbers from zero to nine and an underscore
# ID: 2870
^[A-Za-z0-9_]+$

# Finding the value behind the char '='. The Exp. is designed to find parametres in specified URL's. In this example it find tha value of "str="
# ID: 1138
(str\=)\s*(?<value>([a-zA-Z0-9\,\.]{1})*)

# Allows for 3 characters max before the decimal and 4 characters max after the decimal
# ID: 1544
^\d{1,3}\.\d{1,4}$

# This Regex validate all israeli cellular companies numbers (050,052,054,057)
# ID: 1461
^[0][5][0]-\d{7}|[0][5][2]-\d{7}|[0][5][4]-\d{7}|[0][5][7]-\d{7}$

# I built this expression to test a string in ASP for valid username and password constraints.  It can be adapted for any number of scenerios.  For instance in this case, we needed to ensure the username someone wanted was not all numbers or all letters and was 6-15 characters in length with no special characters.  This expression tests negatively for all number cases, then all letter cases, and lastly tests for only alphanumeric characters in the required range.  In other words: the match must be alphanumeric with at least one number, one letter, and be between 6-15 character in length.
# ID: 515
(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{6,15})$

# Australian phone numbers including Mobiles and common spacing used. This is used only to test normal contact numbers for residential purposes for example not information lines like 139999.
# ID: 1248
^[0-9]{10}$|^\(0[1-9]{1}\)[0-9]{8}$|^[0-9]{8}$|^[0-9]{4}[ ][0-9]{3}[ ][0-9]{3}$|^\(0[1-9]{1}\)[ ][0-9]{4}[ ][0-9]{4}$|^[0-9]{4}[ ][0-9]{4}$

# I got tired of sites not recognising my Gmail account when I used tags, so I created this regexp which allows them to be included. Outputted variables are #1 - Username, #2 - Tag (or blank), #3 - Domain
# ID: 1926
([A-Z][\w\d\.\-]+)(?:(?:\+)([\w\d\.\-]+))?@([A-Z0-9][\w\.-]*[A-Z0-9]\.[A-Z][A-Z\.]*[A-Z])

# Matches any and all matches of the street types detailed at http://www.abs.gov.au/Ausstats/abs@.nsf/66f306f503e529a5ca25697e0017661f/2a46946e38f31d0cca256c62007dbb98!OpenDocument
# ID: 2713
A(?:CCESS|LLEY|PPROACH|R(?:CADE|TERY)|VE(?:NUE)?)|B(?:A(?:NK|SIN|Y)|E(?:ACH|ND)|L(?:DG|VD)|O(?:ULEVARD|ARDWALK|WL)|R(?:ACE|AE|EAK|IDGE|O(?:ADWAY|OK|W))|UILDING|YPASS)|C(?:A(?:NAL|USEWAY)|ENTRE(?:WAY)?|HASE|IRC(?:LET?|U(?:IT|S))|L(?:OSE)?|O(?:MMON|NCOURSE|PSE|R(?:NER|SO)|UR(?:SE|T(?:YARD)?)|VE)|R(?:ES(?:CENT|T)?|IEF|OSS(?:ING)?)|U(?:LDESAC|RVE))|D(?:ALE|EVIATION|IP|OWNS|R(?:IVE(?:WAY)?)?)|E(?:ASEMENT|DGE|LBOW|N(?:D|TRANCE)|S(?:PLANADE|TATE)|X(?:P(?:(?:RESS)?WAY)|TENSION))|F(?:AIRWAY|IRETRAIL|O(?:LLOW|R(?:D|MATION))|R(?:(?:EEWAY|ONT(?:AGE)?)))|G(?:A(?:P|RDENS?|TE(?:S|WAY)?)|L(?:ADE|EN)|R(?:ANGE|EEN|O(?:UND|VET?)))|H(?:AVEN|E(?:ATH|IGHTS)|I(?:GHWAY|LL)|UB|WY)|I(?:NTER(?:CHANGE)?|SLAND)|JUNCTION|K(?:EY|NOLL)|L(?:A(?:NE(?:WAY)?)?|IN(?:E|K)|O(?:O(?:KOUT|P)|WER))|M(?:ALL|E(?:A(?:D|NDER)|WS)|OTORWAY)|NOOK|O(?:UTLOOK|VERPASS)|P(?:A(?:R(?:ADE|K(?:LANDS|WAY)?)|SS|TH(?:WAY)?)|DE|IER|L(?:A(?:CE|ZA))?|O(?:CKET|INT|RT)|RO(?:MENADE|PERTY)|URSUIT)?|QUA(?:D(?:RANT)?|YS?)|R(?:AMBLE|D|E(?:ACH|S(?:ERVE|T)|T(?:REAT|URN))|I(?:D(?:E|GE)|NG|S(?:E|ING))|O(?:AD(?:WAY)?|TARY|U(?:ND|TE)|W)|UN)|S(?:(?:ER(?:VICE)?WAY)|IDING|LOPE|PUR|QUARE|T(?:EPS|RAND|R(?:EET|IP))?|UBWAY)|T(?:ARN|CE|ERRACE|HRO(?:UGHWAY|WAY)|O(?:LLWAY|P|R)|RA(?:CK|IL)|URN)|UNDERPASS|V(?:AL(?:E|LEY)|I(?:EW|STA))|W(?:A(?:LK(?:WAY)?|Y)|HARF|YND)

# Matches potentially valid dates (from 1/1/1900 - 31/12/2099), according to European Standard (D/M/Y).
# ID: 3123
^(?:(?:0?[1-9])|(?:[12]\d)|3[01])/(?:(?:0?[1-9])|(?:1[012]))/(?:(?:19|20))\d{2}$

# Command line named argument parser which allows quoted values and includes "\"" escape for quotes in a quoted value.  Non-quoted values can be letter, space or underscore only. Argument names can be letter, space or underscore only. Argument delimiter can be "-" or "/" and name-value separator can be ":" or "=". All arguments must be named. Spaces are not allowed in
# ID: 1220
(?:\s*)(?<=[-|/])(?<name>\w*)[:|=]("((?<value>.*?)(?<!\\)")|(?<value>[\w]*))

# This will find the open body tag regardless of any properties or Event Handlers associated with it. This is great for global implementations  of analytics or anything that needs to be placed after the body tag.
# ID: 1925
<body[\d\sa-z\W\S\s]*>

# This Regex matches Mexican RFC's (Registro Federal de Contribuyentes) with 3 or 4 letters in the first section. It accepts spaces and dashes between sections.
# ID: 843
^[A-Za-z]{3,4}[ |\-]{0,1}[0-9]{6}[ |\-]{0,1}[0-9A-Za-z]{3}$

# Regular expression that matches Mexican RFC's (Registro Federal de Contribuyentes).
# ID: 827
^[A-Za-z]{4}[ |\-]{0,1}[0-9]{6}[ |\-]{0,1}[0-9A-Za-z]{3}$

# using match.Result("$1.$2.$3.$4")
# ID: 382
^\[assembly: AssemblyVersion\(\"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)

# This regular expressions matches CNPJ number. CNPJ is a Registration Number of Brazilian Companies.
# ID: 323
\d{2}.?\d{3}.?\d{3}/?\d{4}-?\d{2}

# This RE match the SQL Basics Queries (SELECT, UPDATE, INSERT and DELETE).
# ID: 945
# Multiline
(SELECT\s[\w\*\)\(\,\s]+\sFROM\s[\w]+)|(UPDATE\s[\w]+\sSET\s[\w\,\'\=]+)|(INSERT\sINTO\s[\d\w]+[\s\w\d\)\(\,]*\sVALUES\s\([\d\w\'\,\)]+)|(DELETE\sFROM\s[\d\w\'\=]+)

# Number(no space or thousand separator with point(.) as decimal delimiter.
# ID: 2765
^[-+]?\d+(\.\d)?\d*$

# Validates strings of type dd/mm/yyyy. checking dd to be between 1-31, mm between 1-12 and yyyy between 1900-2099.
# ID: 2803
\b([0]?[1-9]|[1,2]\d|3[0,1])[-/]([0]?[1-9]|[1][0,1,2])[-/](\d{1,2}|[1][9]\d\d|[2][0]\d\d)\b

# This is for Saudi phone
# ID: 2454
^(\d{5}-\d{2}-\d{7})*$

# This expression should work to validate that an uploaded file's extension is either jpg, gif, or png.
# ID: 1457
.*(\.[Jj][Pp][Gg]|\.[Gg][Ii][Ff]|\.[Jj][Pp][Ee][Gg]|\.[Pp][Nn][Gg])

# Should match prices with or without a dollar sign.
# ID: 1406
^[$]?[0-9]*(\.)?[0-9]?[0-9]?$

# This expression was developed to match the Title cased words within a Camel cased variable name.  So it will match 'First' and 'Name' within 'strFirstName'.
# ID: 184
[A-Z][a-z]+

# A very simple ISBN validation expression - it just checks for a 10 digit number where the last digit could also be a capital 'X'.  Complete specs for ISBN available here:
# ID: 79
^\d{9}[\d|X]$

# This expression uses a BackReference to find occurrences of the same word twice in a row (separated by a space).
# ID: 33
(\w+)\s+\1

# Credit card validator.  Just checks that the format is either 16 numbers in groups of four separated by a "-" or a " " or nothing at all.
# ID: 48
^(\d{4}[- ]){3}\d{4}|\d{16}$

# Matches major credit cards including:
# ID: 49
^((4\d{3})|(5[1-5]\d{2})|(6011))-?\d{4}-?\d{4}-?\d{4}|3[4,7]\d{13}$

# Matches any string between 4 and 8 characters in length.  Limits the length of a string.  Useful to add to password regular expressions.
# ID: 50
^.{4,8}$

# Accepts an unsigned integer number.  Also matches empty strings.
# ID: 51
^\d*$

# Matches any integer number or numeric string, including positive and negative value characters (+ or -).  Also matches empty strings.
# ID: 52
^[-+]?\d*$

# Matches any unsigned floating point number/numeric string.  Also matches empty strings.
# ID: 53
^\d*\.?\d*$

# Matches any floating point numer/numeric string, including optional sign character (+ or -).  Also matches empty strings.
# ID: 54
^[-+]?\d*\.?\d*$

# Matches any single upper- or lower-case letter.
# ID: 10
^[a-zA-Z]$

# Matches any string of only upper- and lower- case letters (no spaces).
# ID: 11
^[a-zA-Z]+$

# Matches any alphanumeric string (no spaces).
# ID: 12
^[a-zA-Z0-9]+$

# Positive integer value.
# ID: 13
^\d+$

# Matches any signed integer.
# ID: 14
^(\+|-)?\d+$

# The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers and the underscore may be used
# ID: 15
^[a-zA-Z]\w{3,14}$

# Simple email expression.  Doesn't allow numbers in the domain name and doesn't allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more).  Doesn't handle multiple "." in the domain (joe@abc.co.uk).
# ID: 16
^\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,3}$

# This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.
# ID: 17
^\d{1,2}\/\d{1,2}\/\d{4}$

# The "hello world" of regular expressions, this will match any string with an instance of 'foo' in it.
# ID: 18
foo

# This matches a single numeric digit between 1 and 5, and is the same as saying ^[12345]$.
# ID: 19
^[1-5]$

# This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$.
# ID: 20
^[12345]$

# This expression matches email addresses, and checks that they are of the proper form.  It checks to ensure the top level domain is between 2 and 4 characters long, but does not check the specific domain against a list (especially since there are so many of them now).
# ID: 21
^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$

# This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.
# ID: 22
^[2-9]\d{2}-\d{3}-\d{4}$

# This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code.  The first one must be 5 numeric digits.  The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits.  The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.
# ID: 23
^\d{5}-\d{4}|\d{5}|[A-Z]\d[A-Z] \d[A-Z]\d$

# Matches exactly 1 numeric digit (0-9).
# ID: 1
^\d$

# Matches 5 numeric digits, such as a zip code.
# ID: 2
^\d{5}$

# Numeric and hyphen 5+4 ZIP code match for ZIP+4.
# ID: 3
^\d{5}-\d{4}$

# This regular expression will match either a 5 digit ZIP code or a ZIP+4 code formatted as 5 digits, a hyphen, and another 4 digits.  Other than that, this is just a really really long description of a regular expression that I'm using to test how my front page will look in the case where very long expression descriptions are used.
# ID: 4
^\d{5}$|^\d{5}-\d{4}$

# US Phone Number -- doesn't check to see if first digit is legal (not a 0 or 1).
# ID: 27
((\(\d{3}\) ?)|(\d{3}-))?\d{3}-\d{4}

# Yet another simple email validator expression.
# ID: 28
[\w-]+@([\w-]+\.)+[\w-]+

# Major credit card validator.  Only checks that the format is 16 digits (optionally separated by hyphens), not the value of any of the digits.
# ID: 29
\d{4}-?\d{4}-?\d{4}-?\d{4}

# Password expression.  Password must be between 4 and 8 digits long and include at least one numeric digit.
# ID: 30
^(?=.*\d).{4,8}$

# Password matching expression.  Password must be at least 4 characters, no more than 8 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.
# ID: 31
^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$

# This matches any real number, with optional decimal point and numbers after the decimal, and optional positive (+) or negative (-) designation.
# ID: 117
^[-+]?\d+(\.\d+)?$

# This regular expression will match a 24 hour time with no separators.
# ID: 102
^(20|21|22|23|[0-1]\d)[0-5]\d$

# Matches a 12-hour time value expressed as either 4 numeric digits, 3 numeric digits, or a space and 3 numeric digits.  3 digit times (930) can be expressed with leading 0's (0930) or not.  AM/PM designation is not included in this expression.
# ID: 103
^( [1-9]|[1-9]|0[1-9]|10|11|12)[0-5]\d$

# This expression matches dates formatted as MM/DD/YYYY where months and days must be 2 digits each, zero padded.  It is not perfect - it allows DD to be from 01 to 31 regardless of the month.
# ID: 105
^(|(0[1-9])|(1[0-2]))\/((0[1-9])|(1\d)|(2\d)|(3[0-1]))\/((\d{4}))$

# Date expressions that matches MM/DD/YYYY where MM and DD must be two digits and zero padded.  Validates correctly for all months except February, which it assumes to always have 29 days.  The "/" separator is optional.
# ID: 106
^((((0[13578])|(1[02]))[\/]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\/]?(([0-2][0-9])|(30)))|(02[\/]?[0-2][0-9]))[\/]?\d{4}$

# In response to a question on the regex list at www.aspadvice.com, this expression should ensure that a login field's username includes a 'DOMAIN\' prefix.  The latter part of the expression should probably be limited so that it only allows usernames of appropriate lengths, perhaps 3 to 20 characters (by replacing + with {3,20} for instance).
# ID: 508
^DOMAIN\\\w+$

# This is a regex I wrote to capture requests to AspAlliance.com with an article id as the only thing after the domain.  So http://aspalliance.com/123 would go to article number 123.  It maps the URL to the actual aspx file that displays the article based on the ID.
# ID: 456
\.com/(\d+)$

# This pattern returns as much of the first x characters of a string as full words or sentences as a match, where x is currently 20. Change x to adjust the length supported in your database field.
# ID: 470
^([\s\S]){1,20}([\s\.])

# Get all images in html string, ignore white space, tabs and is case insensitive. the result is iMG	sRc		="ricardo.gif, after this just split the string and Enjoy it!
# ID: 3113
"<[ \t]*[iI][mM][gG][ \t]*[sS][rR][cC][ \t]*=[ \t]*['\"]([^'\"]+)"

# This expression will allow Letters, periods, apostrophe, dashes.
# ID: 1147
^([a-zA-Z][a-zA-Z\&amp;\-\.\'\s]*|)$

# Designed for full url matching in common hyperlink text including: 1. ftp(s),http(s), and mailto protocols. 2. ip, domain names and sub-domains, and standard email addresses. 3. files with extensions and parameters. Match provides whole match and protocol, address, page, file extension, and parameter sub-matches for use in parsing. If you see anything that can be improved, by all means provide me some feedback. Thanks!
# ID: 3544
^(((?:(?:f|ht)tps?(?!\:\/\/[-\.\w]+@)|mailto(?=\:\/\/[-\.\w]+@))\:\/\/)?(?:((?:(?:(?:2(?:[0-4]\d|5[0-5])|[01]?\d?\d))(?:\.(?:2(?:[0-4]\d|5[0-5])|[01]?\d?\d)){3})|(?:(?:[a-zA-Z0-9](?:[-\w]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}(?:(?:\/[-\w]+(?=\/))*)?)|(?:[0-9a-zA-Z](?:[-.\w]*[0-9a-zA-Z])?@(?:[0-9a-zA-Z](?:[-\w]*[0-9a-zA-Z])?\.)+[a-zA-Z]{2,6}(?![\/\?])))(\/[-\w]+)?(?:(?<=\w)\.([a-zA-Z0-9]{2,4}))?(?:(?<=\w)\?([a-zA-Z][-\w]*=[-\w]+(?:&[a-zA-Z][-\w]*=[-\w]+)*))?))$

# UK phone number formats with optional international prefix, optional spaces, dashes and brackets. Brackets mandatory for regional/capital leading zero if included in international form. Based on "Mh" UK London & Regional. (Thanks Mh for the groundwork).  New to Regex so I'm sure it can be done more elegantly... but it works.
# ID: 1421
^\s*\(?((\+0?44)?\)?[ \-]?(\(0\))|0)((20[7,8]{1}\)?[ \-]?[1-9]{1}[0-9]{2}[ \-]?[0-9]{4})|([1-8]{1}[0-9]{3}\)?[ \-]?[1-9]{1}[0-9]{2}[ \-]?[0-9]{3}))\s*$

# Pattern for T-SQL identifier
# ID: 1765
(?:\[(?:[\u0000-\u005C]|[\u005E-\uFFFF]|\]\])+\])|(?:\u0022(?:[\u0000-\u0021]|[\u0023-\uFFFF]|\u0022\u0022)+\u0022)|(?:[a-zA-Z_][a-zA-Z0-9_]*)

# This is a correction from regex by Fernando Cerqueira. It validates brazilian zip codes, aka CEP, with or without mask.
# ID: 1165
(^\d{5}\-\d{3}$)|(^\d{2}\.\d{3}\-\d{3}$)|(^\d{8}$)

# This regex is designed to parse entries from tnsnames.ora for Oracle connections.  This is a crude first cut in that it doesn't allow for multiple ADDRESS entries in the ADDRESS_LIST section, and I don't know if there are other attributes that I should be allowing for.  Basically, I just don't know enough about possible scenarios at this time, so I just wrote it to what I see in the wild where I work.
# ID: 1058
(?<entryname>[\w_0-9]+)\s*=\s+\(\s*DESCRIPTION\s*=\s+\(\s*ADDRESS_LIST\s*=\s+\(\s*ADDRESS\s*=\s*\(\s*PROTOCOL\s*=\s*(?<protocol>\w+)\)\s*\(\s*HOST\s*=\s*(?<host>[^\)]+)\)\s*\(\s*PORT\s*=\s*(?<port>\d+)\s*\)\s*\)\s+\)\s+\(\s*CONNECT_DATA\s*=\s+\(\s*SERVICE_NAME\s*=\s*(?<svcname>\w+)\s*\)\s+\)\s+\)

# Patrón para el esquema de las galas de los Oscars.
# ID: 1279
^(atuvwdxyzad|abcefdghijd|almnodpqrsd|aß?ded???µd?p?sd)(ktuvwdxyzad|kbcefdghijd|klmnodpqrsd|kß?ded???µd?p?sd)*

# Postcode for the Netherlands
# ID: 699
^[1-9]{1}[0-9]{3}\s?[A-Z]{2}$

# Time in 24h format; minutes must be two digits; hours may be one or two digits
# ID: 692
^([0-1]?\d|2[0-3]):([0-5]\d)$

# Parses a C++ function, including return type, declaration type, namespace, class, method, exposure (public, private, protected) and params.
# ID: 3090
(?<expo>public\:|protected\:|private\:) (?<ret>(const )*(void|int|unsigned int|long|unsigned long|float|double|(class .*)|(enum .*))) (?<decl>__thiscall|__cdecl|__stdcall|__fastcall|__clrcall) (?<ns>.*)\:\:(?<class>(.*)((<.*>)*))\:\:(?<method>(.*)((<.*>)*))\((?<params>((.*(<.*>)?)(,)?)*)\)

# it will help u to match valid mobile number with std (including zero) and local(excluding zero).including zero it will accept 11 digit and without zero it will accept 10 digit.
# ID: 3440
([0-0]{1}[1-9]{1}[0-9]{9})|[1-9]{1}[0-9]{9}

# After hitting little snags through the years here is a  [WIP] for replacing relative links. Notice that it considers whitespace between the src,href and the equal sign, it also considers the  links may not have any quotes around them. It negates  urls that start with http,ftp,link anchors, https and mailto.
# ID: 3051
(src|href|action)\s*=\s*('|"|(?!"|'))(?!(http:|ftp:|mailto:|https:|#))

# Validation of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. I'm not able (with this) to validate the correct last day of each month. Anyway, it helps :-)
# ID: 1859
[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])\s{1}(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])

# This RE locates and/or validates standard Bible verse notation.
# ID: 2288
(?:(?:[123]|I{1,3})\s*)?(?:[A-Z][a-zA-Z]+|Song of Songs|Song of Solomon).?\s*(?:1?[0-9]?[0-9]):\s*\d{1,3}(?:[,-]\s*\d{1,3})*(?:;\s*(?:(?:[123]|I{1,3})\s*)?(?:[A-Z][a-zA-Z]+|Song of Songs|Song of Solomon)?.?\s*(?:1?[0-9]?[0-9]):\s*\d{1,3}(?:[,-]\s*\d{1,3})*)*

# Validates a dollar amount including a dollar sign and 2 decmals. The decimal and cents are optional.
# ID: 41
^\$[0-9]+(\.[0-9][0-9])?$

# Matches the AssemblyVersion attribute in an Assembly.vb file. The version value is captured.
# ID: 1077
^[^']*?\<\s*Assembly\s*:\s*AssemblyVersion\s*\(\s*"(\*|[0-9]+.\*|[0-9]+.[0-9]+.\*|[0-9]+.[0-9]+.[0-9]+.\*|[0-9]+.[0-9]+.[0-9]+.[0-9]+)"\s*\)\s*\>.*$

# matches any email address, where a @ is contained
# ID: 1549
([a-zA-Z0-9_\-\.]+)(@[a-zA-Z0-9_\-\.]+)

# an expression to match internet addresses with one of the known protocolls (http, ftp, gopher, telnet, news)
# ID: 1550
(?:(?:(?:http|ftp|gopher|telnet|news)://)(?:w{3}\.)?(?:[a-zA-Z0-9/;\?&=:\-_\$\+!\*'\(\|\\~\[\]#%\.])+)

# here are specified all the top level domains. In fact, this expression gets the urls only till the TLD.
# ID: 1551
(?:(?:[a-zA-Z0-9/;\?&=:\-_\$\+!\*'\(\|\\~\[\]#%\.](?!www))+(?:\.[Cc]om|\.[Ee]du|\.[gG]ov|\.[Ii]nt|\.[Mm]il|\.[Nn]et|\.[Oo]rg|\.[Bb]iz|\.[Ii]nfo|\.[Nn]ame|\.[Pp]ro|\.[Aa]ero|\.[cC]oop|\.[mM]useum|\.[Cc]at|\.[Jj]obs|\.[Tt]ravel|\.[Aa]rpa|\.[Mm]obi|\.[Aa]c|\.[Aa]d|\.[aA]e|\.[aA]f|\.[aA]g|\.[aA]i|\.[aA]l|\.[aA]m|\.[aA]n|\.[aA]o|\.[aA]q|\.[aA]r|\.[aA]s|\.[aA]t|\.[aA]u|\.[aA]w|\.[aA]z|\.[aA]x|\.[bB]a|\.[bB]b|\.[bB]d|\.[bB]e|\.[bB]f|\.[bB]g|\.[bB]h|\.[bB]i|\.[bB]j|\.[bB]m|\.[bB]n|\.[bB]o|\.[bB]r|\.[bB]s|\.[bB]t|\.[bB]v|\.[bB]w|\.[bB]y|\.[bB]z|\.[cC]a|\.[cC]c|\.[cC]d|\.[cC]f|\.[cC]g|\.[cC]h|\.[cC]i|\.[cC]k|\.[cC]l|\.[cC]m|\.[cC]n|\.[cC]o|\.[cC]r|\.[cC]s|\.[cC]u|\.[cC]v|\.[cC]x|\.[cC]y|\.[cC]z|\.[dD]e|\.[dD]j|\.[dD]k|\.[dD]m|\.[dD]o|\.[dD]z|\.[eE]c|\.[eE]e|\.[eE]g|\.[eE]h|\.[eE]r|\.[eE]s|\.[eE]t|\.[eE]u|\.[fF]i|\.[fF]j|\.[fF]k|\.[fF]m|\.[fF]o|\.[fF]r|\.[gG]a|\.[gG]b|\.[gG]d|\.[gG]e|\.[gG]f|\.[gG]g|\.[gG]h|\.[gG]i|\.[gG]l|\.[gG]m|\.[gG]n|\.[gG]p|\.[gG]q|\.[gG]r|\.[gG]s|\.[gG]t|\.[gG]u|\.[gG]w|\.[gG]y|\.[hH]k|\.[hH]m|\.[hH]n|\.[hH]r|\.[hH]t|\.[hH]u|\.[iI]d|\.[iI]e|\.[iI]l|\.[iI]m|\.[iI]n|\.[iI]o|\.[iI]q|\.[iI]r|\.[iI]s|\.[iI]t|\.[jJ]e|\.[jJ]m|\.[jJ]o|\.[jJ]p|\.[kK]e|\.[kK]g|\.[kK]h|\.[kK]i|\.[kK]m|\.[kK]n|\.[kK]p|\.[kK]r|\.[kK]w|\.[kK]y|\.[kK]z|\.[lL]a|\.[lL]b|\.[lL]c|\.[lL]i|\.[lL]k|\.[lL]r|\.[lL]s|\.[lL]t|\.[lL]u|\.[lL]v|\.[lL]y|\.[mM]a|\.[mM]c|\.[mM]d|\.[mM]g|\.[mM]h|\.[mM]k|\.[mM]l|\.[mM]m|\.[mM]n|\.[mM]o|\.[mM]p|\.[mM]q|\.[mM]r|\.[mM]s|\.[mM]t|\.[mM]u|\.[mM]v|\.[mM]w|\.[mM]x|\.[mM]y|\.[mM]z|\.[nN]a|\.[nN]c|\.[nN]e|\.[nN]f|\.[nN]g|\.[nN]i|\.[nN]l|\.[nN]o|\.[nN]p|\.[nN]r|\.[nN]u|\.[nN]z|\.[oO]m|\.[pP]a|\.[pP]e|\.[pP]f|\.[pP]g|\.[pP]h|\.[pP]k|\.[pP]l|\.[pP]m|\.[pP]n|\.[pP]r|\.[pP]s|\.[pP]t|\.[pP]w|\.[pP]y|\.[qP]a|\.[rR]e|\.[rR]o|\.[rR]u|\.[rR]w|\.[sS]a|\.[sS]b|\.[sS]c|\.[sS]d|\.[sS]e|\.[sS]g|\.[sS]h|\.[Ss]i|\.[sS]j|\.[sS]k|\.[sS]l|\.[sS]m|\.[sS]n|\.[sS]o|\.[sS]r|\.[sS]t|\.[sS]v|\.[sS]y|\.[sS]z|\.[tT]c|\.[tT]d|\.[tT]f|\.[tT]g|\.[tT]h|\.[tT]j|\.[tT]k|\.[tT]l|\.[tT]m|\.[tT]n|\.[tT]o|\.[tT]p|\.[tT]r|\.[tT]t|\.[tT]v|\.[tT]w|\.[tT]z|\.[uU]a|\.[uU]g|\.[uU]k|\.[uU]m|\.[uU]s|\.[uU]y|\.[uU]z|\.[vV]a|\.[vV]c|\.[vV]e|\.[vV]g|\.[vV]i|\.[vV]n|\.[vV]u|\.[wW]f|\.[wW]s|\.[yY]e|\.[yY]t|\.[yY]u|\.[zZ]a|\.[zZ]m|\.[zZ]w))

# So, that's it. Gets url-s with "www", BUT without the protocols. If you need one regEx with the protocols, search for it in this database, I've added one
# ID: 1552
(?:(?:w{3}\.)(?:[a-zA-Z0-9/;\?&=:\-_\$\+!\*'\(\|\\~\[\]#%\.])+[\.com|\.edu|\.gov|\.int|\.mil|\.net|\.org|\.biz|\.info|\.name|\.pro|\.aero|\.coop|\.museum|\.cat|\.jobs|\.travel|\.arpa|\.mobi|\.ac|\.ad|\.ae|\.af|\.ag|\.ai|\.al|\.am|\.an|\.ao|\.aq|\.ar|\.as|\.at|\.au|\.aw|\.az|\.ax|\.ba|\.bb|\.bd|\.be|\.bf|\.bg|\.bh|\.bi|\.bj|\.bm|\.bn|\.bo|\.br|\.bs|\.bt|\.bv|\.bw|\.by|\.bz|\.ca|\.cc|\.cd|\.cf|\.cg|\.ch|\.ci|\.ck|\.cl|\.cm|\.cn|\.co|\.cr|\.cs|\.cu|\.cv|\.cx|\.cy|\.cz|\.de|\.dj|\.dk|\.dm|\.do|\.dz|\.ec|\.ee|\.eg|\.eh|\.er|\.es|\.et|\.eu|\.fi|\.fj|\.fk|\.fm|\.fo|\.fr|\.ga|\.gb|\.gd|\.ge|\.gf|\.gg|\.gh|\.gi|\.gl|\.gm|\.gn|\.gp|\.gq|\.gr|\.gs|\.gt|\.gu|\.gw|\.gy|\.hk|\.hm|\.hn|\.hr|\.ht|\.hu|\.id|\.ie|\.il|\.im|\.in|\.io|\.iq|\.ir|\.is|\.it|\.je|\.jm|\.jo|\.jp|\.ke|\.kg|\.kh|\.ki|\.km|\.kn|\.kp|\.kr|\.kw|\.ky|\.kz|\.la|\.lb|\.lc|\.li|\.lk|\.lr|\.ls|\.lt|\.lu|\.lv|\.ly|\.ma|\.mc|\.md|\.mg|\.mh|\.mk|\.ml|\.mm|\.mn|\.mo|\.mp|\.mq|\.mr|\.ms|\.mt|\.mu|\.mv|\.mw|\.mx|\.my|\.mz|\.na|\.nc|\.ne|\.nf|\.ng|\.ni|\.nl|\.no|\.np|\.nr|\.nu|\.nz|\.om|\.pa|\.pe|\.pf|\.pg|\.ph|\.pk|\.pl|\.pm|\.pn|\.pr|\.ps|\.pt|\.pw|\.py|\.qa|\.re|\.ro|\.ru|\.rw|\.sa|\.sb|\.sc|\.sd|\.se|\.sg|\.sh|\..si|\.sj|\.sk|\.sl|\.sm|\.sn|\.so|\.sr|\.st|\.sv|\.sy|\.sz|\.tc|\.td|\.tf|\.tg|\.th|\.tj|\.tk|\.tl|\.tm|\.tn|\.to|\.tp|\.tr|\.tt|\.tv|\.tw|\.tz|\.ua|\.ug|\.uk|\.um|\.us|\.uy|\.uz|\.va|\.vc|\.ve|\.vg|\.vi|\.vn|\.vu|\.wf|\.ws|\.ye|\.yt|\.yu|\.za|\.zm|\.zw](?:[a-zA-Z0-9/;\?&=:\-_\$\+!\*'\(\|\\~\[\]#%\.])*)

# any north american us phone number
# ID: 1553
(?:(?:(?:\+)?1[\-\s\.])?(?:\s?\()?(?:[2-9][0-8][0-9])(?:\))?(?:[\s|\-|\.])?)(?:(?:(?:[2-9][0-9|A-Z][0-9|A-Z])(?:[\s|\-|\.])?)(?:[0-9|A-Z][0-9|A-Z][0-9|A-Z][0-9|A-Z]))

# India mobile number, accept 0  prefix
# ID: 2906
for mobile:^[0][1-9]{1}[0-9]{9}$

# India phone(landline) number, accept 0 for prefix and - (hifen) after the STD code.
# ID: 2907
^[0][1-9]{2}(-)[0-9]{8}$  and  ^[0][1-9]{3}(-)[0-9]{7}$  and  ^[0][1-9]{4}(-)[0-9]{6}$

# This can check the email of any kind..
# ID: 2908
\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

# In this Pattern +91 will be the prefix in the Mobile number(of 10 digits).
# ID: 2910
^((\+){1}91){1}[1-9]{1}[0-9]{9}$

# This is a combination of Jerry Schmersahl's (http://regexlib.com/REDetails.aspx?regexp_id=930) US ZIP Code regex and John Alpha's (http://regexlib.com/REDetails.aspx?regexp_id=2754) Canadian Postal Code regex.
# ID: 2790
^(?<full>(?<part1>[ABCEGHJKLMNPRSTVXY]{1}\d{1}[A-Z]{1})(?:[ ](?=\d))?(?<part2>\d{1}[A-Z]{1}\d{1}))$

# This expression allows you to select 1-365 as a numeric value for the days of the year.  Must be between 1 and 365 and must be numeric
# ID: 2291
^[1-9]{1}$|^[1-9]{1}[0-9]{1}$|^[1-3]{1}[0-6]{1}[0-5]{1}$|^365$

# Validates Microsoft Project-type duration entries. Accepts a number and a unit. The number part can be integer or decimal. The unit can be several variations of weeks, days, and hours: e.g., w, wk, week, ws, wks, weeks are all valid. Whitespace between the number and the unit is optional: e.g., 1d, 2 days, 3.5w are all valid. Captures the number value in a group named num and the unit string in a group named 'unit'.
# ID: 351
^\s*(?'num'\d+(\.\d+)?)\s*(?'unit'((w(eek)?)|(wk)|(d(ay)?)|(h(our)?)|(hr))s?)(\s*$)

# This regex have been created as per the information provided on http://www.govtalk.gov.uk/gdsc/html/noframes/PostCode-2-1-Release.htm. This expression will allow the postcodes with space or without space.
# ID: 1687
^(GIR\\s{0,1}0AA|[A-PR-UWYZ]([0-9]{1,2}|([A-HK-Y][0-9]|[A-HK-Y][0-9]([0-9]|[ABEHMNPRV-Y]))|[0-9][A-HJKS-UW])\\s{0,1}[0-9][ABD-HJLNP-UW-Z]{2})$

# This Expression will allow at least one small letter, one capital and one numeric digit. And length of the password is minimum of 8 and allowed special chars are pre defined(@\$=!:.#%),special chars are optional in password
# ID: 2498
^.*(?=.{8,})(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(^[a-zA-Z0-9@\$=!:.#%]+$)

# Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating
# ID: 2466
^[-+]?(?:\d+\.?|\.\d)\d*(?:[Ee][-+]?\d+)?$

# allows only spaces and dashes in the national number.  parantheses are allowed around the national prefix.  no us and canada numbers (+1) are allowed.  can start with 0 instead of +.  no extensions.
# ID: 3309
^([\+]|0)[(\s]{0,1}[2-9][0-9]{0,2}[\s-)]{0,2}[0-9][0-9][0-9\s-]*[0-9]$

# this regex is based on a previous but i think is more accurate, but still has a bug... it allow things like that: name.name@sub.3.com...
# ID: 1472
^[0-9]*[a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([a-zA-Z][-\w\.]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$

# it will validate phone number formats like -
# ID: 3439
([+(]?\d{0,2}[)]?)([-/.\s]?\d+)+

# It matches all strings that the .NET Framework API "new Guid(string guid)" can recognize. A String that contains a GUID in one of the following formats ('d' represents a hexadecimal digit whose case is ignored):
# ID: 1772
[({]?(0x)?[0-9a-fA-F]{8}([-,]?(0x)?[0-9a-fA-F]{4}){2}((-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12})|(,\{0x[0-9a-fA-F]{2}(,0x[0-9a-fA-F]{2}){7}\}))[)}]?

# Matches english dates with 2 or 4 digit year
# ID: 3147
^(0[1-9]|[12][0-9]|3[01])/(0[1-9]|1[012])/((19|20)\d{2}|\d{2})$

# This expression is useful for determining if an address is a PO Box type address. This can be useful in shipping systems as well as other systems that need to  make determinations based on the type of address imputed.
# ID: 461
^p(ost)?[ |\.]*o(ffice)?[ |\.]*(box)?[ 0-9]*[^[a-z ]]*

# It just accepts negative and positive numeric entries. Dot (.) or comma (,) signs accepted only once.
# ID: 2829
^-?\d+([.,]?\d+)?$

# It just accepts only positive numbers. Also accepts Dot (.) and comma (,) signs only once.
# ID: 2830
^\d+([.,]?\d+)?$

# Accepts positive and negative integers.
# ID: 2831
^-?\d+([^.,])?$

# Accepts positive integers.
# ID: 2832
^\d+([^.,])?$

# If you want to check for positive and nonzero real numbers (both integer and decimal are supported).
# ID: 2044
(^([0-9]*[.][0-9]*[1-9]+[0-9]*)$)|(^([0-9]*[1-9]+[0-9]*[.][0-9]+)$)|(^([1-9]+[0-9]*)$)

# Given HTMl or CSS source, find the value of all href and src attributes + anything between url().
# ID: 2261
((?<html>(href|src)\s*=\s*")|(?<css>url\())(?<url>.*?)(?(html)"|\))

# This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions.  The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space are also accepted). Requires postcodes to be upper-case.
# ID: 1690
^(GIR|[A-Z]\d[A-Z\d]?|[A-Z]{2}\d[A-Z\d]?)[ ]??(\d[A-Z]{0,2})??$

# Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted).  (requires postcodes to be upper-case)
# ID: 1691
^(GIR|[A-Z]\d[A-Z\d]??|[A-Z]{2}\d[A-Z\d]??)[ ]??(\d[A-Z]{2})$

# No idea whether anyone would ever need this, but I had to work half a day on this pattern, so I decided to share it. :) It was never meant for productive use at all; it was rather to filter out all that annoying event handling stuff to find a bug in my DHTML table-generating script. Give it a try with this string (see details):
# ID: 1911
(\s(\bon[a-zA-Z][a-z]+)\s?\=\s?[\'\"]?(javascript\:)?[\w\(\),\' ]*;?[\'\"]?)+

# This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long.
# ID: 223
^((0[1-9])|(1[0-2]))\/(\d{4})$

# get all css links, tags ect without http,  i needed this to my web crawler, maybe somebody need this to ;)_
# ID: 1639
(href=|url|import).*[\'"]([^(http:)].*css)[\'"]

# Tests Vehicle Identification Numbers (VINs).  This works for a Mitsubishi cars in the UK - but I have been unable to determine whether the format is for UK vehicles or applies only to this make.  The requirements are that the first 9 characters and the 11th character are alpha-numeric excluding i, I, o or O.  The 10th character is the chassis year, and is alpha-numeric excluding i, I, o, O, q, Q, u, and U.  The final 6 characters are numeric.  The string is 17 characters in length.  Any refinements would be greatly appreciated!
# ID: 516
^(([a-h,A-H,j-n,J-N,p-z,P-Z,0-9]{9})([a-h,A-H,j-n,J-N,p,P,r-t,R-T,v-z,V-Z,0-9])([a-h,A-H,j-n,J-N,p-z,P-Z,0-9])(\d{6}))$

# Matches UK postcodes according to the following rules
# ID: 38
^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$

# This expression will validate for US Currency with a wide range of input.  Using other exps found on this site, I built this one to fix 2 main problems I was finding:
# ID: 318
^\$?(\d{1,3},?(\d{3},?)*\d{3}(\.\d{0,2})?|\d{1,3}(\.\d{0,2})?|\.\d{1,2}?)$

# Validates Discover Card numbers starting with 6011 and allows for spaces and -'s.
# ID: 2544
^((6011)((-|\s)?[0-9]{4}){3})$

# Validates all Mastercard numbers starting with 51-55 with a total of 16 digits. Allows for spaces and -'s.
# ID: 2545
^((5[1-5])([0-9]{2})((-|\s)?[0-9]{4}){3})$

# This Regular expression validates a string that contains all printable characters with a minimum length of 1 and maximum length of 5.
# ID: 310
^([a-zA-Z0-9!@#$%^&*()-_=+;:'"|~`<>?/{}]{1,5})$

# This expression will match city.state.domain.com
# ID: 3448
^([^\.]+).([^\.]+).([^\.]+).([^\.]+)$

# Just a small pattern to make sure commas are in the rite place (if present).  Only allows one decimal to be suffixed with with 1 or 2 digits.  Also optional dollar sign may proceed value.
# ID: 1531
^\$?\d{1,3}(,?\d{3})*(\.\d{1,2})?$

# Validates numeric input of 99,999,999 to 0 with or without commas. but no decimal places. Very simple, but not bad for a novice.
# ID: 576
^\d{1,8}$|^\d{1,3},\d{3}$|^\d{1,2},\d{3},\d{3}$

# This expression validates dates in the Brazilian d/m/y format from 1/1/1600 - 12/31/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999. Days and months must be 1 or 2 digits and may have leading zeros. Years must be 4 digit years, between 1600 and 9999. Date separator must be a slash (/)
# ID: 316
^(?:(?:(?:0?[1-9]|1\d|2[0-8])\/(?:0?[1-9]|1[0-2]))\/(?:(?:1[6-9]|[2-9]\d)\d{2}))$|^(?:(?:(?:31\/0?[13578]|1[02])|(?:(?:29|30)\/(?:0?[1,3-9]|1[0-2])))\/(?:(?:1[6-9]|[2-9]\d)\d{2}))$|^(?:29\/0?2\/(?:(?:(?:1[6-9]|[2-9]\d)(?:0[48]|[2468][048]|[13579][26]))))$

# This pattern  will replace & with & if the ampersand is followed by space else it will escape &
# ID: 1509
&( )

# US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc. You can add/remove formatting options to meet your needs.
# ID: 607
^(?:\([2-9]\d{2}\)\ ?|[2-9]\d{2}(?:\-?|\ ?))[2-9]\d{2}[- ]?\d{4}$

# This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.
# ID: 689
^(?:\([2-9]\d{2}\)\ ?|(?:[2-9]\d{2}\-))[2-9]\d{2}\-\d{4}$

# This matches floating point expression in a more rigorous way - accepts both exponent as well as non exponent notations.
# ID: 139
^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$

# Currency test for currency symbols and up to three char leading/trailing string
# ID: 3024
^\p{Sc}?[A-Z]{0,3}?[ ]?(\d{1,3})(\.|\,)(\d{0,4})?[ ]?\p{Sc}?[A-Z]{0,3}?$

# Matches e-mail addresses, including some of the newer top-level-domain extensions, such as info, museum, name, etc.  Also allows for emails tied directly to IP addresses.
# ID: 140
^[_a-zA-Z0-9-]+(\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|coop|info|museum|name))$

# This is a robust email validation: the username part conforms with RFC 2822 (for instance, emails with tags ("+") are validated).
# ID: 1448
^((([a-z]|[0-9]|!|#|$|%|&|'|\*|\+|\-|/|=|\?|\^|_|`|\{|\||\}|~)+(\.([a-z]|[0-9]|!|#|$|%|&|'|\*|\+|\-|/|=|\?|\^|_|`|\{|\||\}|~)+)*)@((((([a-z]|[0-9])([a-z]|[0-9]|\-){0,61}([a-z]|[0-9])\.))*([a-z]|[0-9])([a-z]|[0-9]|\-){0,61}([a-z]|[0-9])\.(af|ax|al|dz|as|ad|ao|ai|aq|ag|ar|am|aw|au|at|az|bs|bh|bd|bb|by|be|bz|bj|bm|bt|bo|ba|bw|bv|br|io|bn|bg|bf|bi|kh|cm|ca|cv|ky|cf|td|cl|cn|cx|cc|co|km|cg|cd|ck|cr|ci|hr|cu|cy|cz|dk|dj|dm|do|ec|eg|sv|gq|er|ee|et|fk|fo|fj|fi|fr|gf|pf|tf|ga|gm|ge|de|gh|gi|gr|gl|gd|gp|gu|gt| gg|gn|gw|gy|ht|hm|va|hn|hk|hu|is|in|id|ir|iq|ie|im|il|it|jm|jp|je|jo|kz|ke|ki|kp|kr|kw|kg|la|lv|lb|ls|lr|ly|li|lt|lu|mo|mk|mg|mw|my|mv|ml|mt|mh|mq|mr|mu|yt|mx|fm|md|mc|mn|ms|ma|mz|mm|na|nr|np|nl|an|nc|nz|ni|ne|ng|nu|nf|mp|no|om|pk|pw|ps|pa|pg|py|pe|ph|pn|pl|pt|pr|qa|re|ro|ru|rw|sh|kn|lc|pm|vc|ws|sm|st|sa|sn|cs|sc|sl|sg|sk|si|sb|so|za|gs|es|lk|sd|sr|sj|sz|se|ch|sy|tw|tj|tz|th|tl|tg|tk|to|tt|tn|tr|tm|tc|tv|ug|ua|ae|gb|us|um|uy|uz|vu|ve|vn|vg|vi|wf|eh|ye|zm|zw|com|edu|gov|int|mil|net|org|biz|info|name|pro|aero|coop|museum|arpa))|(((([0-9]){1,3}\.){3}([0-9]){1,3}))|(\[((([0-9]){1,3}\.){3}([0-9]){1,3})\])))$

# Matches simple e-mail addresses such as me@domain.com, me@domain.co.uk, but does not place any restrictions on TLDs other than they must be lower case and alphabetic.  a-z, A-Z, 0-9, ., _, and - are all allowed on the left side of @.
# ID: 2367
^[a-zA-Z0-9._\-]+@[a-z0-9\-]+(\.[a-z]+){1,}$

# to select single selector name of css including id, class name, descendants ,child, direct and indirect siblings.also it's captured into 3 catpuring names
# ID: 2929
(?<Element>((\*|\w+)?)) (?<Complement>((\.|\#|\-|\w|\:)*)) (?<FamilySeparator>([\s\>\+\~]|[\,\{]))

# This is expression is good if you need to clean up some code (like from using DW Design View or Front Page). Just  the "tag1" and "tag2" with the tags you want, and you can add more by putting a | inbetween each tag.
# ID: 1732
<\/?(tag1|tag2)[^>]*\/?>

# Removes all the text between two tags. Replace the "tag1" and "tag2" with the tag you want to remove, you can add more by placing additional "|" between each tag.
# ID: 1733
<(tag1|tag2)[^>]*\/?>.*<\/(?:\1)>

# If when making a website you need to find your relative paths, this regex will find them. You can use the follow to make them absolute:
# ID: 1738
(src|href|action)="(?!http://|#|mailto:|&)([^/#"])

# Use the above pattern with this replacement pattern: "<a\1 title="\2">\2</a>" and it will put title tags in all of your anchors that don't have a title tag.
# ID: 1867
<a((?:(?! title=)[^">]*"[^">]*")+)>([^<]+)<\/a>

# This will remove the InnerHTML of a tag. For instance, if you wanted to clear all paragraphs and h1 tags on a page, you would simply put in "p" and "h1" into those tags, and they would end up looking like <h1></h1> <p></p> <p></p>. It's useful when you're doing work based off a template and you need to get back to the original template.
# ID: 1836
(<(tag1|tag2)[^>]*\/?>)[\w\S\s]*?(<\/(?:\2)>)

# Finds 9 digit numbers within word boundaries, not separated or separated by - or space, not starting with 000, 666, or 900-999, not containing 00 or 0000 in the middle or at the end of SSN (in compliance with current SSN rules).
# ID: 3272
\b(?!000)(?!666)(?!9)[0-9]{3}[ -]?(?!00)[0-9]{2}[ -]?(?!0000)[0-9]{4}\b

# The above regex matches any phone number of the format (XXX-XXX-XXXX). (With or without hyphens)
# ID: 3408
\d{3})[- .]?(\d{3}[- .]?\d{4}

# The above expression pulls the first line of any large text or sentence.
# ID: 3409
^(.*)

# Matches a string and grabs all data till the end of the string/text/sentence.
# ID: 3410
start\s*([^$]*)\s*(.*?)

# Matches and returns the text provided the match string and the end string. Eg. I wonder why all programming languages start with a hello world program !!
# ID: 3411
wonder\s*([^$]*)\s*with

# Matches month and year in the specified format.
# ID: 3416
((?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Sept|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?))(\s+)[0-9]{2,4}

# Limit Length - limit the length of a text box or other area to contain any character plus new line
# ID: 352
^(.|\n){0,16}$

# Use for parsing CSV files exported from MS Excel, This program adds or not quotes, so it's more complicated..
# ID: 1106
(?<=,)\s*(?=,)|^(?=,)|[^\"]{2,}(?=\")|([^,\"]+(?=,|$))

# Allows for a dollar sign with no space after, a dollar sign with a space after, and no dollar sign.  Also makes sure theres no more than 4 decimal places.  Takes out leading zeros if the number isn't 0, and protects against blank entries.
# ID: 1079
^(\$\ |\$)?((0|00|[1-9]\d*|([1-9]\d{0,2}(\,\d{3})*))(\.\d{1,4})?|(\.\d{1,4}))$

# Expression to match names and dis-allow any attempts to send evil characters.  In particular, it tries to allow
# ID: 247
^([ \u00c0-\u01ffa-zA-Z'])+$

# This regular expression allows user to add string spaces and numbers.
# ID: 3520
^\s*[a-zA-Z0-9,\s]+\s*$

# Test the password
# ID: 3571
^[a-zA-Z0-9!@#$&_]+$

# Checks domain names. This will match all of the valid domains. It will accept TLD's that are from 2 to 6 characters. You can not have more then one dash or period next to each other. Also it will not let you have dashes at end of the words.
# ID: 1314
^(([a-zA-Z0-9]+([\-])?[a-zA-Z0-9]+)+(\.)?)+[a-zA-Z]{2,6}$

# Hopefully an all-encompassing expression to validate a URL.  Supports an optional protocol, either a domain or IP address, an optional port number and an optional path.
# ID: 1048
^(((ht|f)tp(s?))\://)?((([a-zA-Z0-9_\-]{2,}\.)+[a-zA-Z]{2,})|((?:(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d)(?(\.?\d)\.)){4}))(:[a-zA-Z0-9]+)?(/[a-zA-Z0-9\-\._\?\,\'/\\\+&%\$#\=~]*)?$

# Simple, but it gave me trouble in the c#...
# ID: 280
{.*}

# Validate and parse date/time string in ISO8601 format. Works with complete representation in both with basic and extended formats. Some of turncated representations and most of representations with reduced precision are also supported. It does not validate range of date/time fields in any way.
# ID: 3322
^(?:-([0-9]{1,2})|([0-9]{4}))?(?:-?(?:([0-9]{2})?(?:-?([0-9]{2}))?|W([0-9]{2})(?:-?([1-7]))?|([0-9]{3})))?(?:T([0-9]{2})(?::?([0-9]{2})(?::?([0-9]{2}))?)?(?:[,\.]([0-9]+))?(?:(Z)|([+-])([0-9]{2})(?::?([0-9]{2}))?)?)?$

# Matches comma separated names in a row based list of names.  Submatches retrieve name parts, e.g. first name, middle name, initial, surname.
# ID: 825
([A-Za-z0-9.]+\s*)+,

# This regular expression checks if the given string is a fraction. This does not allow 0 either in the numerator or the denominator.
# ID: 1232
^[0-9]*\/{1}[1-9]{1}[0-9]*$

# Validates URL to see if the input pattern is a valid URL (ftp, http, https, etc); can be easily modified to support others such as file:/// | Pattern has been tested using .NET runtime engine | localhost literal support for windows IIS server and visal studio (2005 or later) built-in asp.net web-server
# ID: 2841
^(ht|f)tp(s?)\:\/\/(([a-zA-Z0-9\-\._]+(\.[a-zA-Z0-9\-\._]+)+)|localhost)(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&%\$#_]*)?([\d\w\.\/\%\+\-\=\&\?\:\\\"\'\,\|\~\;]*)$

# Validates dates from 1/1/0001 to 12/31/9999. Month and day can be preceded by a zero to a max of two digits; however, year must be four digits exactly. This regex was developed in a .NET environment and uses conditional lookahead syntax, so your regex engine must support same. Month, day, and year are captured to groups named "month", "day", and "year" for additional processing if desired.
# ID: 2773
^(?=0?[1-9]/|1[012]/)(?:(?<month>(?<month31days>0?[13578]|1[02])|(?<month30days>0?[469]|11)|(?<monthFeb>0?2))/)(?<day>(?(month31days)(?:[012]?[1-9]|3[01]))(?(month30days)(?:[012]?[1-9]|30))(?(monthFeb)(?:[01]?[1-9]|2(?(?=\d/(?:(?:(?:04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96)00)|(?:\d\d(?:04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96))))[0-9]|[0-8]))))/(?<year>(?!0000)\d{4})$

# Validates the format of a US mailing address that includes a maximum of three lines.
# ID: 2774
^(?<line1>(?!\s+)[^\n]+)\n(?:(?<line2>(?!\s+)[^\n]+)\n)?(?<city>[^,\n]+), +(?<state>-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]) +(?<zip>(?<zip5>\d{5})(?:[ -]?(?<zip4>\d{4}))?)$

# Validates US state abbreviations used by the Post Office.
# ID: 2775
^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$

# Validate US zip codes. Matches all zip codes of exactly 5 digits except 00000. Optionally, matches zip5+zip4 where zip5 is exactly 5 digits, zip4 is exactly 4 digits, and zip5 and zip4 are, optionally, separated by a single space or hyphen. Captures zip5 and zip4 to named groups to facilitate program manipulation.
# ID: 930
^(?!00000)(?<zip>(?<zip5>\d{5})(?:[ -](?=\d))?(?<zip4>\d{4})?)$

# Regular expression for validating a decimal IP address. Matches 4 groups of from 1 to 3 digits, where each group of digits ranges from 0 to 255 in value. Groups of digits must be separated by a single period (.) with no other formatting characters present. Uses conditional regex with lookahead syntax to prevent a match on a period following the final group of digits.
# ID: 547
^(?:(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d)(?(?=\.?\d)\.)){4}$

# Regular expression for validating US telephone numbers with OPTIONAL area code. Matches various permutations of formatting characters (parenthesis, space, dash). Parses the telephone number area code, prefix, and suffix to named groups to facilitate program manipulation. Area code is optional and can optionally be enclosed in parentheses. Rejects area codes that begin with 0 or 1 and prefixes that begin with 0. Rejects all telephone numbers that do not match on exactly 7 digits, or on exactly 10 digits with the optional area code, not counting the formatting characters.
# ID: 536
^(?:(?<1>[(])?(?<AreaCode>[2-9]\d{2})(?(1)[)])(?(1)(?<2>[ ])|(?:(?<3>[-])|(?<4>[ ])))?)?(?<Prefix>[1-9]\d{2})(?(AreaCode)(?:(?(1)(?(2)[- ]|[-]?))|(?(3)[-])|(?(4)[- ]))|[- ]?)(?<Suffix>\d{4})$

# Regular expression for validating US telephone numbers with OPTIONAL area code, and OPTIONAL extension. Matches various permutations of formatting characters (parenthesis, space, dash). Parses the telephone number area code, prefix, suffix, and extension to named groups to facilitate program manipulation. Area code is optional and can optionally be enclosed in parentheses. Rejects area codes that begin with 0 or 1 and prefixes that begin with 0. Extension is optional and can be optionally preceded by a space and/or "x" or "X", and matches on 2 to 4 digits. Rejects all telephone numbers that do not match on exactly 7 digits, or on exactly 10 digits with the optional area code, not counting the extension or the formatting characters.
# ID: 537
^(?:(?<1>[(])?(?<AreaCode>[2-9]\d{2})(?(1)[)])(?(1)(?<2>[ ])|(?:(?<3>[-])|(?<4>[ ])))?)?(?<Prefix>[1-9]\d{2})(?(AreaCode)(?:(?(1)(?(2)[- ]|[-]?))|(?(3)[-])|(?(4)[- ]))|[- ]?)(?<Suffix>\d{4})(?:[ ]?[xX]?(?<Ext>\d{2,4}))?$

# Example of a regular expression that can be used to parse a comma delimited string into constituent, named sub-strings. Add or remove regex subfield definitions (?<field1>[^,]+) and corresponding delimiting characters in the regular expression as necessary to accommodate the string and subfields you intend to parse. Optionally, rename the subfield names in the regular expression to more meaningful names if you are using the parsed sub-strings in a program. Replace all occurrences of the comma in the regular expression with any required alternative delimiting character. As long as the delimiting character used does not occur naturally in any of the sub-strings, you should be good-to-go. NOTE: To change the delimiter character you must replace all occurrences of the comma in the current regex (of which there are 5) with the new delimiter character. e.g. (?<field1>[^;]+); changes the delimiter character to a semi-colon for the first field.
# ID: 538
^(?<field1>[^,]+),(?<field2>[^,]+),(?<field3>[^,]+)$

# Updated on 3/4/2004 per feedback to additionally exclude SSNs that begin with 666 which, as reported, are also not valid.
# ID: 539
^(?!000)(?!666)(?<SSN3>[0-6]\d{2}|7(?:[0-6]\d|7[012]))([- ]?)(?!00)(?<SSN2>\d\d)\1(?!0000)(?<SSN4>\d{4})$

# Updated on 7 Jun 2005 --
# ID: 540
^(?:(?<Visa>4\d{3})|(?<Mastercard>5[1-5]\d{2})|(?<Discover>6011)|(?<DinersClub>(?:3[68]\d{2})|(?:30[0-5]\d))|(?<AmericanExpress>3[47]\d{2}))([ -]?)(?(DinersClub)(?:\d{6}\1\d{4})|(?(AmericanExpress)(?:\d{6}\1\d{5})|(?:\d{4}\1\d{4}\1\d{4})))$

# Regular expression for validating a US currency string field. Matches an unlimited number of digits to the left of an optional decimal point. Digits to the left of the decimal point can optionally be formatted with commas, in standard US currency format. If the decimal point is present, it must be followed by exactly two digits to the right. Matches an optional preceding dollar sign. Uses regex lookahead to preclude leading zeros and to match the optional formatting comma.
# ID: 551
(?n:(^\$?(?!0,?\d)\d{1,3}(?=(?<1>,)|(?<1>))(\k<1>\d{3})*(\.\d\d)?)$)

# Regular expression for validating a person's full name. Matches on two general formats: 1) first second third last (where first, second, and third names are optional and all present are separated by a space); 2) last, first second third (where second and third are optional, last is followed immediately by a comma and a space, and second, and third, if present, are separated by a space from each other and from first). First corresponds to surname and last corresponds to family name. Each name part is captured to a named group to facilitate program manipulation. Each name part must begin with an uppercase letter, followed by zero or more lowercase letters, except for the last name. Last name must begin with an uppercase letter, followed by one or more lowercase letters, but will match exceptions formatted like the following: McD..., MacD..., O'R... Only format is validated, not spelling. NOTE: This regular expression uses positive and negative regex lookahead to determine the general format of the name, i.e. the presence or the absence of the comma determines the general format that will match. Furthermore, this initial version is not designed to accommodate titles and things like "3rd".
# ID: 552
(?n:(^(?(?![^,]+?,)((?<first>[A-Z][a-z]*?) )?((?<second>[A-Z][a-z]*?) )?((?<third>[A-Z][a-z]*?) )?)(?<last>[A-Z](('|[a-z]{1,2})[A-Z])?[a-z]+))(?(?=,)(, (?<first>[A-Z][a-z]*?))?( (?<second>[A-Z][a-z]*?))?( (?<third>[A-Z][a-z]*?))?)$)

# Strong password with the following requirements.
# ID: 2062
(?-i)(?=^.{8,}$)((?!.*\s)(?=.*[A-Z])(?=.*[a-z]))(?=(1)(?=.*\d)|.*[^A-Za-z0-9])^.*$

# A pattern for matching both simple, and complex names. Will match up to 4 names within a single name. This is a regex expression I created using some of the expressions I have found here, and other places on the web. It has named patterns to make it easier to separate the parts in your application.
# ID: 2502
/^(?P<salutation>(Mr|MR|Ms|Miss|Mrs|Dr|Sir)(\.?))?\s*((?<first>[A-Za-z\-]*?) )?((?<second>[A-Za-z\-]*?) )?((?<third>[A-Za-z\-]*?) )?(?(?!(PHD|MD|3RD|2ND|RN|JR|II|SR|III))(?<last>([A-Za-z](([a-zA-Z\-\']{1,2})[A-Za-z\-\'])?[a-zA-Z\-\']+)))( (?P<suffix>(PHD|MD|3RD|2ND|RN|JR|II|SR|III)))?$/

# validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbitten.
# ID: 1139
^((\d|[1-9]\d|2[0-4]\d|25[0-5]|1\d\d)(?:\.(\d|[1-9]\d|2[0-4]\d|25[0-5]|1\d\d)){3})$

# parsing a linux ftp list string. result is a list of several groups like :
# ID: 1140
^((?<dir>[\-ld])(?<permission>([\-r][\-w][\-xs]){3})\s+(?<filecode>\d+)\s+(?<owner>\w+)\s+(?<group>\w+)\s+(?<size>\d+)\s+(?<timestamp>(?<year>\d{4})-(?<month>\d{2})-(?<day>\d?\d)\s+(?<hour>\d{2}):(?<minute>\d{2}))\s+(?<name>\w.+))$

# parsing a linux ftp list string. result is a list of several groups like : dir (-,l,d) permission (lrwxrwxrwx) filecode (any number) owner (what it says - number or text) group (same as owner) timestamp (what it says, including groups like day, month, hour, minute) name (the file, directory or linkname)
# ID: 1141
^((?<dir>[\-ld])(?<permission>([\-r][\-w][\-xs]){3})\s+(?<filecode>\d+)\s+(?<owner>\w+)\s+(?<group>\w+)\s+(?<size>\d+)\s+(?<timestamp>(?<month>[a-z|A-Z]{3})\s+(?<day>(\d?\d))\s+(?<hour>\d?\d):(?<minute>\d{2}))\s+(?<name>\w.+))$

# Matches ip addresses. Takes into account trailing left zeros.
# ID: 2948
^((0*[0-1]?[0-9]{1,2}\.)|(0*((2[0-4][0-9])|(25[0-5]))\.)){3}((0*[0-1]?[0-9]{1,2})|(0*((2[0-4][0-9])|(25[0-5]))))$

# [Default]
# ID: 165
\$[0-9]?[0-9]?[0-9]?((\,[0-9][0-9][0-9])*)?(\.[0-9][0-9])?$

# Matches almost all Israel phone numbers (without 1800). Generic means it doesn't have a list of allowed prefix (i.e 050,03) because it changes frequently. Instead it accepts any 2-3 digits prefix, with or without hyphen.
# ID: 2049
^\b\d{2,3}-*\d{7}\b$

# This will check that the string is made of up numbers in a D.XX with at least on number for D
# ID: 3504
^[\d]{1,}?\.[\d]{2}$

# Validates a UK Bank Sort code
# ID: 327
^[0-9]{2}[-][0-9]{2}[-][0-9]{2}$

# Validates a UK mobile phone number in International format
# ID: 331
^[+]447\d{9}$

# Accepts only positive decimal values. Zero and negative numbers are non-matching.Allows zeros after last non-zero numeric value after decimal place for significant digits
# ID: 1028
(^[+]?\d*\.?\d*[1-9]+\d*$)|(^[+]?[1-9]+\d*\.\d*$)

# Prueba
# ID: 1275
e(vi?)?

# Prueba
# ID: 1278
(vi(v))?d

# Regular expression for US (ZIP and ZIP+4) and Canadian postal codes.  It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long.  Canadain postal codes can contain a space and take form of A1A 1A1.  The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.
# ID: 417
^((\d{5}-\d{4})|(\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\d[A-Za-z]\s?\d[A-Za-z]\d))$

# This can be used to test, the entered email address is valid or not
# ID: 1755
^([a-zA-Z0-9]+)([\._-]?[a-zA-Z0-9]+)*@([a-zA-Z0-9]+)([\._-]?[a-zA-Z0-9]+)*([\.]{1}[a-zA-Z0-9]{2,})+$

# Simple Malaysian New IC Number Validation.
# ID: 3080
([0-9][0-9])((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\-([0-9][0-9])\-([0-9][0-9][0-9][0-9])

# Match diferent styles for brazilian Phone number code.
# ID: 34
\(([0-9]{2}|0{1}((x|[0-9]){2}[0-9]{2}))\)\s*[0-9]{3,4}[- ]*[0-9]{4}

# [Note: this regex was tested with Macromedia's ColdFusion MX.  I'm sure it'll need some massaging to work with other regex engines.]  Of the few domain validating regular expressions I found in my search I didn't find a single one that reliably handled multiple levels of subdomains or TLDs.  So, I wrote one and thoroughly tested it.  There are a ton of matching and non-matching examples that need to be included to show the completeness of this regex.
# ID: 275
^([a-z0-9]+([\-a-z0-9]*[a-z0-9]+)?\.){0,}([a-z0-9]+([\-a-z0-9]*[a-z0-9]+)?){1,63}(\.[a-z0-9]{2,7})+$

# XML Namespace ( xmlns ) matcher.  Properly matches one or more of either xmlns="blah" or xmlns:blah="blooey" .
# ID: 1105
((xmlns:.*?=[",'].*?[",'])|(xmlns=[",'].*?[",']))

# This simple pattern is useful for removing all HTML tags with or without atributes. It has no removing white spaces
# ID: 1611
<\s*?[^>]+\s*?>

# it's for date in the format: "yyyymmdd" and it validates the empty string and some special values (00000000,88888888,99999999) but you can delete these last values. It works with leap years.
# ID: 651
^(((\d{4})(0[13578]|10|12)(0[1-9]|[12][0-9]|3[01]))|((\d{4})(0[469]|11)([0][1-9]|[12][0-9]|30))|((\d{4})(02)(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)(02)(29))|(([13579][26]00) (02)(29))|(([0-9][0-9][0][48])(02)(29))|(([0-9][0-9][2468][048])(02)(29))|(([0-9][0-9][13579][26])(02)(29))|(00000000)|(88888888)|(99999999))?$

# Phone numbers validation for all country and allow all format for phone no ,contact no .
# ID: 2652
[()+-.0-9]*

# This reg is for validating the shared folder path
# ID: 3220
^((\\{2}\w+)\$?)((\\{1}\w+)*$)

# Extracts a phone number, including country code, from a sentence in natural language
# ID: 3686
.*?((?:\b|\+)\d[\d \-\(\)]+\d)\b.*

# netmask address. I know this is nod good enough :)
# ID: 2625
^(((0|128|192|224|240|248|252|254).0.0.0)|(255.(0|128|192|224|240|248|252|254).0.0)|(255.255.(0|128|192|224|240|248|252|254).0)|(255.255.255.(0|128|192|224|240|248|252|254)))$

# ip address/netmask couple
# ID: 2626
^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})(/([0-9]|[0-2][0-9]|3[0-2]))$

# I have written this regular expression for use in javascript. It sould work for other languages directly or with minor changes. The parsing logic in this regular expression works like this : Imagine a tree structure, input at the root, Level 1 : two branches one-non Feb months two-Feb month. In the Feb month again two branches one-leap year Feb and two-non leap year Feb. In the non-Feb branch, we have two branches again, one-30 days month and two-31 days month. Once you get this, I think it will be easier to figure out the rest.
# ID: 751
(^(((([1-9])|([0][1-9])|([1-2][0-9])|(30))\-([A,a][P,p][R,r]|[J,j][U,u][N,n]|[S,s][E,e][P,p]|[N,n][O,o][V,v]))|((([1-9])|([0][1-9])|([1-2][0-9])|([3][0-1]))\-([J,j][A,a][N,n]|[M,m][A,a][R,r]|[M,m][A,a][Y,y]|[J,j][U,u][L,l]|[A,a][U,u][G,g]|[O,o][C,c][T,t]|[D,d][E,e][C,c])))\-[0-9]{4}$)|(^(([1-9])|([0][1-9])|([1][0-9])|([2][0-8]))\-([F,f][E,e][B,b])\-[0-9]{2}(([02468][1235679])|([13579][01345789]))$)|(^(([1-9])|([0][1-9])|([1][0-9])|([2][0-9]))\-([F,f][E,e][B,b])\-[0-9]{2}(([02468][048])|([13579][26]))$)

# This RegEx will help to validate a physical file path with a specific file extension (here xls)
# ID: 101
([a-zA-Z]:(\\w+)*\\[a-zA-Z0_9]+)?.xls

# This one matches all strings that do not contain the single quotation mark (').
# ID: 159
^[^']*$

# Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked.
# ID: 775
^(((((0?[1-9])|(1\d)|(2[0-8]))\.((0?[1-9])|(1[0-2])))|((31\.((0[13578])|(1[02])))|((29|30)\.((0?[1,3-9])|(1[0-2])))))\.((20[0-9][0-9]))|(29\.0?2\.20(([02468][048])|([13579][26]))))$

# matches any day of
# ID: 209
^((0?[1-9])|((1|2)[0-9])|30|31)$

# The following validates dates with and without leading zeros in the following formats: MM/DD/YYYY and it also takes YYYY (this can easily be removed).  All months are validated for the correct number of days for that particular month except for February which can be set to 29 days. date day month year
# ID: 112
^((((0[13578])|([13578])|(1[02]))[\/](([1-9])|([0-2][0-9])|(3[01])))|(((0[469])|([469])|(11))[\/](([1-9])|([0-2][0-9])|(30)))|((2|02)[\/](([1-9])|([0-2][0-9]))))[\/]\d{4}$|^\d{4}$

# This will return the 3 parts of a date for you.  Splice out the empty array portions and use the 3 parts to build/verify the date.
# ID: 2735
(\d{1,2})\W+(\d{1,2})\W*(\d{2,4})?|(\d{4})\W(\d{1,2})\W(\d{1,2})|([a-zA-Z]+)\W*(\d{1,2})\W+(\d{2,4})|(\d{4})\W*([a-zA-Z]+)\W*(\d{1,2})|(\d{1,2})\W*([a-zA-Z]+)\W*(\d{2,4})|(\d{1,2})\W*([a-zA-Z]+)|([a-zA-Z]+)\W*(\d{1,2})|(\d{2})(\d{2})(\d{2,4})?

# Passwords with at least 1 letter, at least 1 non-letter, and at least 6 characters in length.  It is lenthy with a repeating pattern so that I could validate all three conditions in one expression without using a lookahead, "?=", which are not handled correctly in Internet Explorer.
# ID: 1871
^(.{0,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{4,})|(.{1,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{3,})|(.{2,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{2,})|(.{3,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{1,})|(.{4,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{0,})$

# \d[0-9]*
# ID: 2939
^\d[0-9]*[-/]\d[0-9]*$

# Just a simple US State regex.  Requires valid 2 letter abbreviations.
# ID: 1574
^(?:(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]))$

# Checks for the format yyyy-MM-dd HH:mm:ss
# ID: 798
^(19[0-9]{2}|[2-9][0-9]{3})-((0(1|3|5|7|8)|10|12)-(0[1-9]|1[0-9]|2[0-9]|3[0-1])|(0(4|6|9)|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(02)-(0[1-9]|1[0-9]|2[0-9]))\x20(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$

# This pattern can be used for validating a string as a valid element name (e.g. variable or class name) in Microsoft .NET. See also http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vbcn7/html/vbconelementnames.asp
# ID: 964
(^[a-zA-Z][a-zA-Z0-9_]*)|(^[_][a-zA-Z0-9_]+)

# Please guid me to have perfect refex which will return a string which contains +,- and that string should start with 0
# ID: 3450
[+-](^0.*)

# Date in DD/MM/YYYY or D/M/YYYY format.
# ID: 2278
(((0*[1-9]|[12][0-9]|3[01])([-./])(0*[13578]|10|12)([-./])(\d{4}))|((0*[1-9]|[12][0-9]|30)([-./])(0*[469]|11)([-./])(\d{4}))|((0*[1-9]|1[0-9]|2[0-8])([-./])(02|2)([-./])(\d{4}))|((29)(\.|-|\/)(02|2)([-./])([02468][048]00))|((29)([-./])(02|2)([-./])([13579][26]00))|((29)([-./])(02|2)([-./])([0-9][0-9][0][48]))|((29)([-./])(02|2)([-./])([0-9][0-9][2468][048]))|((29)([-./])(02|2)([-./])([0-9][0-9][13579][26])))

# Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:
# ID: 193
([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})

# Returns array of full A tag [0], href [1], title [2] and innerHTML [3]. href, title and innerHTML are optional in tag; will return empty if missing.
# ID: 2418
<a\s*(?:href=[\'"]([^\'"]+)[\'"])?\s*(?:title=[\'"]([^\'"]+)[\'"])?.*?>((?:(?!</a>).)*)</a>

# None of the other URL regex's seemed to work right for me, so i threw this together. works well with PHP's ereg().
# ID: 499
^(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&%\$\-]+)*@)?((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.[a-zA-Z]{2,4})(\:[0-9]+)?(/[^/][a-zA-Z0-9\.\,\?\'\\/\+&%\$#\=~_\-@]*)*$

# Ok here's an updated URL regex for you folks. It allows localhost and all TLDs. Feel free to add each country code individually if you want a tighter match.
# ID: 501
^(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(\:[0-9]+)*(/($|[a-zA-Z0-9\.\,\?\'\\\+&%\$#\=~_\-]+))*$

# <input[^>]*?value[/s]*=[/s]*(['|"])(.*?)\1[^>]*?type[/s]*=[/s]*(['|"]?)text\3[^>]*?>
# ID: 1199
<input[^>]*?type[/s]*=[/s]*(['|"]?)text\1[^>]*?value[/s]*=[/s]*(['|"])(.*?)\2[^>]*?>

# All useful examples are multi-line, so not displayed.
# ID: 1200
<select(.|\n)*?selected(.|\n)*?>(.*?)</option>(.|\n)*?</select>

# Matches any textarea block, and returns the text inside it.
# ID: 1201
<textarea(.|\n)*?>((.|\n)*?)</textarea>

# Validates US or Canadian phone numbers with the use of "-" or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The "9," is optional as well, which on some phone systems is needed to dial out.
# ID: 941
^(9,)*([1-9]\d{2}-?)*[1-9]\d{2}-?\d{4}$

# To parse the above type of detailed date and time format.
# ID: 2835
^(\s(SUN|MON|TUE|WED|THU|FRI|SAT)\s+(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+(0?[1-9]|[1-2][0-9]|3[01])\s+(2[0-3]|[0-1][0-9]):([0-5][0-9]):((60|[0-5][0-9]))\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2}))$

# Allows percent values from 0 to 100 without the % sign.  Can be used with up to 2 decimal places or without any.  Also works in ASP.NET regular expression validator control.
# ID: 2283
^100$|^100.00$|^\d{0,2}(\.\d{1,2})? *%?$

# Matches U.S. dates with leading zeros and without and with 2 or four digit years
# ID: 69
^(([1-9])|(0[1-9])|(1[0-2]))\/((0[1-9])|([1-31]))\/((\d{2})|(\d{4}))$

# Allows only positive integers that are greater than 0.  Also allows for infinite zeros leading the integer
# ID: 3120
^[0-9]*[1-9]+[0-9]*$

# Regex for IP Address validation.
# ID: 1411
^(([1-9]?\d|1\d\d|2[0-4]\d|25[0-5]).){3}([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])$

# Fairly universal regex for matching any US Phone number in .net.  It basically matches the 10 digit phone number using the common US patterns, and allows for any text after the fact.  I use it with the .replace method and pull out "$1$2$3" to get the pure 10-digit phone number, and anything after that is just stored as additional text.  this additional text could be an extension, daytime information, hours, etc.
# ID: 1722
\(?(\d{3})(?:\)*|\)\s*-*|\.*|\s*|/*|)(\d{3})(?:\)*|-*|\.*|\s*|/*|)(\d{4})(?:\s?|,\s?)

# Matches valids TCP/IP-Adresses
# ID: 1070
^((\d|\d\d|[0-1]\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|[0-1]\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|[0-1]\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|[0-1]\d\d|2[0-4]\d|25[0-5]))$

# Accept Russian, Latvian & English characters
# ID: 1562
[a-zA-Z\u0410-\u042F\u0430-\u044F\u0401\u0451\u0101\u0100\u010c\u010d\u0112\u0113\u011E\u011F\u012A\u012B\u0136\u0137\u013b\u013C\u0145\u0146\u0160\u0161\u016A\u016B\u017D\u017E]$

# My first Expression. This will match US postal codes (zip codes) using simple 5 digit format with optional 4 digit extention seperated by a space or hyphen. Will not accept letters.
# ID: 446
^[0-9]{5}([\s-]{1}[0-9]{4})?$

# A very crude url pattern.
# ID: 563
^http://([a-zA-Z0-9_\-]+)([\.][a-zA-Z0-9_\-]+)+([/][a-zA-Z0-9\~\(\)_\-]*)+([\.][a-zA-Z0-9\(\)_\-]+)*$

# This is a pretty flexable phone number validator for US numbers.  Allows optional country code and area code.  Allows separation of numbers with " ", "-", "." or nothing to seperate.  Area codes can be in parenthesis or not.  Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.
# ID: 764
^((\d[-. ]?)?((\(\d{3}\))|\d{3}))?[-. ]?\d{3}[-. ]?\d{4}$

# A simple expression to verify a FORTRAN variable name to within 31 chars.
# ID: 2868
^[a-zA-Z]\w{0,30}$

# Complies with the Canadian Postal Code requirements as described at http://www.infinitegravity.ca/postalcodeformat.htm
# ID: 3127
^[ABCEGHJKLMNPRSTVXY][0-9][A-Z]\s?[0-9][A-Z][0-9]$

# Ensures a given string matches the basic pattern of a bank routing transit number (RTN), used to identify financial institutions on instruments such as checks. Ensures number is nine digits long and has first two digits that comply with American Bankers Association rules.
# ID: 2057
^((0[0-9])|(1[0-2])|(2[1-9])|(3[0-2])|(6[1-9])|(7[0-2])|80)([0-9]{7})$

# This expression locates all BBCode style hyperlinks and breaks out the URL and linked text components. The URL attribute can be double-quoted or not, or not present at all. URL attributes (if present) are at $2, linked text is at $4.
# ID: 2483
(\[url=?"?)([^\]"]*)("?\])([^\[]*)(\[/url\])

# All positive non-zero integers between 1 and 999.  You can adjust the upper range of this expression by changing the second number (ie 2) in the {0,2} part of the expression.
# ID: 838
^[1-9][0-9]{0,2}$

# This finds the SELECT part of a SQL select statement.  It does not find the entire FROM statement.  That is a different RegEx I will post later.
# ID: 2171
(SELECT\s(?:DISTINCT)?[A-Za-z0-9_\*\)\(,\s\.'\+\|\:=]+?)\s(?:FROM\s[\w\.]+)

# matche standard scientific notation
# ID: 2760
^[-+]??(\\d++[.]\\d*?|[.]\\d+?|\\d+(?=[eE]))([eE][-+]??\\d++)?$

# This RE and MatchEvaluator will remove everything from inside HTML font tags EXCEPT the color declaration. (For ex: allow users to upload HTML content to site without their font tags overridding the font styles set in the CSS, except for the ability to change the font color for special emphasis.)
# ID: 645
# Multiline
<\*?font(?(?=[^>]+color.*>)(.*?color\s*?[=|:]\s*?)('+\#*?[\w\s]*'+|"+\#*?[\w\s]*"+|\#*\w*\b).*?>|.*?>)

# This is a simple expression for Swiss phone and Euro phone in general
# ID: 3224
^((\+\s?\d{2}|\(?00\s?\d{2}\)?)\s?\d{2}\s?\d{3}\s?\d{4})

# just another email validation perl regexp. I tryed to follow as much as possible the RFC 3696 don't hesitate to report.
# ID: 1231
^(?:(?:[^@,"\[\]\x5c\x00-\x20\x7f-\xff\.]|\x5c(?=[@,"\[\]\x5c\x00-\x20\x7f-\xff]))(?:[^@,"\[\]\x5c\x00-\x20\x7f-\xff\.]|(?<=\x5c)[@,"\[\]\x5c\x00-\x20\x7f-\xff]|\x5c(?=[@,"\[\]\x5c\x00-\x20\x7f-\xff])|\.(?=[^\.])){1,62}(?:[^@,"\[\]\x5c\x00-\x20\x7f-\xff\.]|(?<=\x5c)[@,"\[\]\x5c\x00-\x20\x7f-\xff])|"(?:[^"]|(?<=\x5c)"){1,62}")@(?:(?:[a-z0-9][a-z0-9-]{1,61}[a-z0-9]\.?)+\.[a-z]{2,6}|\[(?:[0-1]?\d?\d|2[0-4]\d|25[0-5])(?:\.(?:[0-1]?\d?\d|2[0-4]\d|25[0-5])){3}\])$

# India phone number, accept with optional +91 national code and 0 for land and mobile number prefix . Allows optional - after national code
# ID: 2724
^((\+)?(\d{2}[-])?(\d{10}){1})?(\d{11}){0,1}?$

# matches most most web URLs
# ID: 2508
(https?://)?((?:(\w+-)*\w+)\.)+(?:com|org|net|edu|gov|biz|info|name|museum|[a-z]{2})(\/?\w?-?=?_?\??&?)+[\.]?[a-z0-9\?=&_\-%#]*

# Password filter that matches the NSA Password filter DLL ENPASFILT.DLL.
# ID: 1330
(?=^.{8,30}$)(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()_+}{"":;'?/>.<,]).*$

# This Regex check protocol (ftp, http, https), extension should be between 2 and 4 chars example (.co.uk, .com, .us and .info), domain or subdomain name between protocol and extension should contain the following chars
# ID: 3366
(http|ftp|https)://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,4}(/\S*)?$

# Although written specifically to strip Newzbin version 2 and 3 prefixes and the [1] IE adds in Newsbin from NZB file names, this expression can be modified to search for any prefix/suffix combination.  It also provides an example of using of grouping constructs to remove matching text.
# ID: 1604
(?<=\d{7}_).+((?=\x5B\d\x5D)|.{3})

# A simple match for BBCode type strings.  I had to code my own BBCode scheme for a project that I had taken up and really this is my first RegEx so I thought that I would share.  You could modify this to work with any BBCode type of string that has the [TAG=VALUE]Desc[/TAG] syntax.
# ID: 870
[URL=[a-zA-Z0-9.:/_\-]+\][a-zA-Z0-9._/ ]+\[/URL\]

# The second type of BBCode that I had to write.  This one is an example of Bolding what is between the blocks though it can easily modified to match other Tags such as Underline or li.  Really anything that would match the BBCode that does not need a value in the first tag (ie. [TAG]Desc[/TAG]).
# ID: 871
[B\][a-zA-Z0-9._/ ]+\[/B\]

# matching times from 0[0]:0[0] to 23:59
# ID: 1650
^([0-9]|0[0-9]|1[0-9]|2[0-3]):([0-9]|[0-5][0-9])$

# I've created this regex expression to parse portuguese phone numbers from an webpage.
# ID: 3343
/(?<=[^a-zA-Z0-9])((\+351|00351|351)?)(2\d{1}|(9(3|6|2|1)))\d{7}(?=[^a-zA-Z0-9])/

# Zipcode should be of 5 numerics
# ID: 2350
^[0-9]{5}$

# The following is a powerful regular expression for e-mail address's validation. It was wrote respecting the e-mail addresses' syntax reported in the RFCs and supports both hostnames with multiple sub domains and IP addresses.
# ID: 3290
^([\!#\$%&'\*\+/\=?\^`\{\|\}~a-zA-Z0-9_-]+[\.]?)+[\!#\$%&'\*\+/\=?\^`\{\|\}~a-zA-Z0-9_-]+@{1}((([0-9A-Za-z_-]+)([\.]{1}[0-9A-Za-z_-]+)*\.{1}([A-Za-z]){1,6})|(([0-9]{1,3}[\.]{1}){3}([0-9]{1,3}){1}))$

# This returns the different parts of an Object Name (Database.Owner.Object).  This can be used for matching or pulling out the different pieces.
# ID: 2046
(((\[?(?<Database>[\w]+)\]?)?\.)?(\[?(?<Owner>[\w]+)\]?)?\.)?\[?(?<Object>[\w]+)\]?

# This expression finds all Column within a Select, Update, or Delete query (ex. Column1 = 2, Column2 = 3).  This is useful if you need to refactor a SQL Statement to include a owner prefix before all columns but you aren't sure how many columns there are in the statement.
# ID: 2047
((?<Owner>\[?[\w\d]+\]?)\.{1})?(?<Column>\[?[\w\d]+\]?)(\s*(([><=]{1,2})|(Not|In\(|Between){1,2})\s*)(?<Value>[\w\d\']+)

# this regex eleminates all parameters from a html querry e.g.
# ID: 1054
([^\=&]+)(?<!param1|param2|param3)\=([^\=&]+)(&)?

# For credit card numbers from MC, Visa, Amex, Diners/CarteBlanche, Discover/Novus, Enroute, and JCB.  Does as much as I feel is possible using regex (doesn't do MOD 10).  Javascript safe.
# ID: 1288
^3(?:[47]\d([ -]?)\d{4}(?:\1\d{4}){2}|0[0-5]\d{11}|[68]\d{12})$|^4(?:\d\d\d)?([ -]?)\d{4}(?:\2\d{4}){2}$|^6011([ -]?)\d{4}(?:\3\d{4}){2}$|^5[1-5]\d\d([ -]?)\d{4}(?:\4\d{4}){2}$|^2014\d{11}$|^2149\d{11}$|^2131\d{11}$|^1800\d{11}$|^3\d{15}$

# matches a date in dd/mm/yyyy format
# ID: 1271
^(((((0[1-9])|(1\d)|(2[0-8]))\/((0[1-9])|(1[0-2])))|((31\/((0[13578])|(1[02])))|((29|30)\/((0[1,3-9])|(1[0-2])))))\/((20[0-9][0-9])|(19[0-9][0-9])))|((29\/02\/(19|20)(([02468][048])|([13579][26]))))$

# matches a double number
# ID: 1272
^(0|(-?(((0|[1-9]\d*)\.\d+)|([1-9]\d*))))$

# Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service™ began using an expanded ZIP Code™ number called called the "ZIP+4®" Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office™ facility or Delivery Area. [-]Required "dash" or "hyphen". [67]Sector or Several Blocks. [89]Segment or One Side of a Street. Also just FYI, ZIP codes in the northeast US frequently start with '0' or '00'. [00988-Carolina, PR] [03110-Bedford, NH].  Thanks, Ryan v-
# ID: 837
^\d{5}(-\d{4})?$

# Matches dutch telephone numbers WITHOUT country code prefix
# ID: 860
([0]{1}[6]{1}[-\s]*([1-9]{1}[\s]*){8})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\s]*([1-9]{1}[\s]*){6})|([0]{1}[1-9]{1}[0-9]{1}[-\s]*([1-9]{1}[\s]*){7})

# It allow number and comma. But on start and end it does not allow comma.
# ID: 3329
\d+,?\d+\$?

# simple expression for excluding a given list of characters.  simply change the contents of [^] to suite your needs.  for example ^(/w|/W|[^<>])+$ would allow everything except the characters < and >.
# ID: 218
^(/w|/W|[^<>+?$%{}&])+$

# First letter cannot be: D, F, I, Q, U, or V
# ID: 2950
\b([A-CEGHJ-PR-TW-Z]{1}[A-CEGHJ-NPR-TW-Z]{1}(?<!BG|GB|NK|KN|TN|NT|ZZ))[0-9]{6}[A-DFM]{1}\b

# This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits.
# ID: 2031
^(((0[1-9]{1})|(1[0-2]{1}))\/?(([0-2]{1}[1-9]{1})|(3[0-1]{1}))\/?(([12]{1}[0-9]{1})?[0-9]{2}) ?(([01]{1}[0-9]{1})|(2[0-4]{1}))\:?([0-5]{1}[0-9]{1}))$

# This will match US most common telephones format with extension or with out extension.  Works with both Java and .NET.
# ID: 682
((\(\d{3}\) ?)|(\d{3}[- \.]))?\d{3}[- \.]\d{4}(\s(x\d+)?){0,1}$

# this is about land line number in AP .
# ID: 2042
\d{3}-\d{6}

# Captures Submatches, problem:domainname length can be longer than 64 chars, because every [a-zA-Z0-9][\.\-_] is only countet as one char.
# ID: 608
^((?:(?:(?:[a-zA-Z0-9][\.\-\+_]?)*)[a-zA-Z0-9])+)\@((?:(?:(?:[a-zA-Z0-9][\.\-_]?){0,62})[a-zA-Z0-9])+)\.([a-zA-Z0-9]{2,6})$

# Not a 100% email validation. It doesn't work with IP-Adresses, but it's good for most common cases. At least I hope so.
# ID: 600
^((?:(?:(?:\w[\.\-\+]?)*)\w)+)\@((?:(?:(?:\w[\.\-\+]?){0,62})\w)+)\.(\w{2,6})$

# formatação de placas de carros brasileiros.
# ID: 2789
^(([a-zA-Z]{3})?([0-9]{4}))$

# This can be used in conjunction with the replace method to provide pseudo-code support without having to enable HTML. The replacement string (in ASP.NET, use RegExp.Replace(SourceString, RegularExpressionPattern, ReplacementString) is <a href="${link}">${text}</a>.
# ID: 64
\[link="(?<link>((.|\n)*?))"\](?<text>((.|\n)*?))\[\/link\]

# Following expression can be used to validate a datetime column from SQL Server.  This expression is an enhanced version of Scott Watermasysk's date/time submission.  It now accepts leading zeros in months, days, and hours.  In addition, this expression properly handles the 11th hour.   Watermasysk's would take the 10th and 12th hour but not the 11th.  This regex has been tweaked to do so.  Does not handle the February 29th problem on non-leap years yet.  Will learn a little more about RegEx and do so in later submission.
# ID: 361
^(((((0[13578])|([13578])|(1[02]))[\-\/\s]?((0[1-9])|([1-9])|([1-2][0-9])|(3[01])))|((([469])|(11))[\-\/\s]?((0[1-9])|([1-9])|([1-2][0-9])|(30)))|((02|2)[\-\/\s]?((0[1-9])|([1-9])|([1-2][0-9]))))[\-\/\s]?\d{4})(\s(((0[1-9])|([1-9])|(1[0-2]))\:([0-5][0-9])((\s)|(\:([0-5][0-9])\s))([AM|PM|am|pm]{2,2})))?$

# This expression will fail if the host/domain does not end with @gmail.com
# ID: 3689
(\w+([-+.']\w+)*@(gmail.com))

# Matches U.S. military time with option leading zero and required seconds.
# ID: 1589
^([0]?\d|1\d|2[0-3]):([0-5]\d):([0-5]\d)$

# D&D dice:
# ID: 804
(?<dice>\d*)(?<dsides>(?<separator>[\d\D])(?<sides>\d+))(?<modifier>(?<sign>[\+\-])(?<addend>\d))?

# accepts malaysian mobile number example (011,012,013...) plus 7 additional numbers
# ID: 3586
^([0])([1])([1,2,3,4,6,7,8,9])([0-9][0-9][0-9][0-9][0-9][0-9][0-9])

# allows the new 8 digit numbers aswell as 7 digit numbers without the 015
# ID: 3605
^01[1,2,3,4,6,7,8,9]\d{7,8}$

# Very easy expression for using with arachnoWare XmlDbelt for obtaining information about data store connection string and XPath based query over the store.
# ID: 928
'(?<document>.*)'\)(?<path>.*)

# [Default]
# ID: 647
^(?=\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\x20|$))|(?:2[0-8]|1\d|0?[1-9]))([-./])(?:1[012]|0?[1-9])\1(?:1[6-9]|[2-9]\d)?\d\d)?(\x20?((0?[1-9]|1[012])(:[0-5]\d){0,2}(\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$

# It validates Indian Vehicle Registration Number
# ID: 888
^([A-Z|a-z]{2}-\d{2}-[A-Z|a-z]{2}-\d{1,4})?([A-Z|a-z]{3}-\d{1,4})?$

# i've merged two regular expression those i found on this site. thanks to the owners "Aleš Potocnik and
# ID: 1289
<a[a-zA-Z0-9 ="'.:;?]*(href=[\"\'](http:\/\/|\.\/|\/)?\w+(\.\w+)*(\/\w+(\.\w+)?)*(\/|\?\w*=\w*(&\w*=\w*)*)?[\"\'])*(>[a-zA-Z0-9 ="'<>.:;?]*</a>)

# you can find all the hyperlinks with their caption and attributes. in other words you can find anchors with their attributes and label or value.
# ID: 1290
<a [a-zA-Z0-9 ="'.:;?]*href=*[a-zA-Z0-9 ="'.:;>?]*[^>]*>([a-zA-Z0-9 ="'.:;>?]*[^<]*<)\s*/a\s*>

# this Expression use conditional expression to eveluate parameter after "HREF" and executes the yes/no part of the expression. this expression finds <A>  TAG and returns value of "HREF" and the value hold in between <a></a> tags. the expression returns maximum 3 sub matches. the first match returns the "HREF" tag value and rest of two holds the value of the tag alternativly. so after executing the expression you need to itarate through all the submatches and need to find out non NULL tags to get value.
# ID: 1313
<a.*?href=(.*?)(?((?:\s.*?)>.*?</a>)(?:(?:\s.*?)>(.*?)</a>)|(?:>(.*?)</a>))

# it will check for the +ve decimal numbers
# ID: 1013
^[0-9]*(\.)?[0-9]+$

# It validates Indian Vehicle Registration Number
# ID: 998
^([A-Z|a-z]{2}\s{1}\d{2}\s{1}[A-Z|a-z]{1,2}\s{1}\d{1,4})?([A-Z|a-z]{3}\s{1}\d{1,4})?$

# Returns the value from a CSV line.
# ID: 2308
\A[^,"]*(?=,)|(?:[^",]*"[^"]*"[^",]*)+|[^",]*"[^"]*\Z|(?<=,)[^,]*(?=,)|(?<=,)[^,]*\Z|\A[^,]*\Z

# This will match single numbers,the first block [1346] checks for single digits of 1, 3, 4 or 6, could easily by [1-5] as well. The second block [10] checks for 10 only.
# ID: 420
^[1]$|^[3]$|^[4]$|^[6]$|^[1]0$

# This is for matching Single uppercase Letters inclusively
# ID: 421
^[A]$|^[C]$|^[D]$|^[F]$|^[H]$|^[K]$|^[L]$|^[M]$|^[O]$|^[P]$

# This was designed to match a single name field which required a minimum length of 2 characters and no triplicate characters.
# ID: 3324
^(?i:([a-z])\1?(?!\1)){2,}$

# This regular expression can be used for validating a strong password. It expects at least 1 lowercase letter, 1 uppercase letter, and 1 digit. It will also allow for some special characters. The length should be greater than 8 characters. The sequence of the characters is not important.
# ID: 1923
(?=^.{8,}$)(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s)[0-9a-zA-Z!@#$%^&*()]*$

# <b>MAC Address Validator</b><br><br>Works with ":" linux style separator or "-" windows style separator and groups each octet to the corresponding group.<br>Quite extensive, but functional.<br><br>Any suggestions, feel free to comment.<br><br>
# ID: 1383
^(?:(?'1'[0-9a-fA-F]{2})(?:\:)(?'2'[0-9a-fA-F]{2})(?:\:)(?'3'[0-9a-fA-F]{2})(?:\:)(?'4'[0-9a-fA-F]{2})(?:\:)(?'5'[0-9a-fA-F]{2})(?:\:)(?'6'[0-9a-fA-F]{2}))$|^(?:(?'1'[0-9a-fA-F]{2})(?:\-)(?'2'[0-9a-fA-F]{2})(?:\-)(?'3'[0-9a-fA-F]{2})(?:\-)(?'4'[0-9a-fA-F]{2})(?:\-)(?'5'[0-9a-fA-F]{2})(?:\-)(?'6'[0-9a-fA-F]{2}))$

# <b>MAC Address Catcher</b><br><br>Catches MAC Addresses on any string.<br>Works with ":" linux style separator or "-" windows style separator and groups each octet to the corresponding group.<br>Quite extensive, but functional.<br><br>Any suggestions, feel free to comment.<br><br>
# ID: 1384
(?:(?'1'[0-9a-fA-F]{2})(?:\:)(?'2'[0-9a-fA-F]{2})(?:\:)(?'3'[0-9a-fA-F]{2})(?:\:)(?'4'[0-9a-fA-F]{2})(?:\:)(?'5'[0-9a-fA-F]{2})(?:\:)(?'6'[0-9a-fA-F]{2}))|(?:(?'1'[0-9a-fA-F]{2})(?:\-)(?'2'[0-9a-fA-F]{2})(?:\-)(?'3'[0-9a-fA-F]{2})(?:\-)(?'4'[0-9a-fA-F]{2})(?:\-)(?'5'[0-9a-fA-F]{2})(?:\-)(?'6'[0-9a-fA-F]{2}))

# It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314
# ID: 1136
^[0-9,+,(), ,]{1,}(,[0-9]+){0,}$

# Validate that the string contains only alphanumeric characters or an underscore. The first character cannot be anything else than alphabetic character.
# ID: 879
^[a-zA-Z][a-zA-Z0-9_]+$

# Matches internet web address.
# ID: 3323
^(http(s?)\:\/\/)*[0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*(:(0-9)*)*(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&%\$#_]*)?$

# Password with minimum 1 Letter (A-Za-z), 1 Number (0-9) and Special Character (\W). It doesn't matter the charaters position. See the Mathching Examples.
# ID: 1281
^(([A-Za-z]+[^0-9]*)([0-9]+[^\W]*)([\W]+[\W0-9A-Za-z]*))|(([A-Za-z]+[^\W]*)([\W]+[^0-9]*)([0-9]+[\W0-9A-Za-z]*))|(([\W]+[^A-Za-z]*)([A-Za-z]+[^0-9]*)([0-9]+[\W0-9A-Za-z]*))|(([\W]+[^0-9]*)([0-9]+[^A-Za-z]*)([A-Za-z]+[\W0-9A-Za-z]*))|(([0-9]+[^A-Za-z]*)([A-Za-z]+[^\W]*)([\W]+[\W0-9A-Za-z]*))|(([0-9]+[^\W]*)([\W]+[^A-Za-z]*)([A-Za-z]+[\W0-9A-Za-z]*))$

# This pattern can intercept img like < img src="src1" alt="alt1"> or < img alt="alt1" src="src1"> or < img src="src1"> or < img src="src1" width=3 height=4> then values of src can be found in $5 or $8, the value of tag alt can be found in $3 or $10.
# ID: 1435
<img[\s]+[^>]*?((alt*?[\s]?=[\s\"\']+(.*?)[\"\']+.*?)|(src*?[\s]?=[\s\"\']+(.*?)[\"\']+.*?))((src*?[\s]?=[\s\"\']+(.*?)[\"\']+.*?>)|(alt*?[\s]?=[\s\"\']+(.*?)[\"\']+.*?>)|>)

# This pattern could intercept the value of the tag title in every web pages, it could be found in $1.
# ID: 1439
<title>+(.*?)</title>

# This pattern intercept meta tags, the name can be found in $1 the content value in $2.
# ID: 1440
<meta[\s]+[^>]*?name[\s]?=[\s\"\']+(.*?)[\s\"\']+content[\s]?=[\s\"\']+(.*?)[\"\']+.*?>

# Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM. If this don't woik, I wrote it, lemmy know.
# ID: 398
^(([0]?[1-9]|1[0-2])/([0-2]?[0-9]|3[0-1])/[1-2]\d{3})? ?((([0-1]?\d)|(2[0-3])):[0-5]\d)?(:[0-5]\d)? ?(AM|am|PM|pm)?$

# Match any number between 1 and 50, no characters, no empty sets, and not zero. Match numbers greater than 1 and less than 51, no spaces, no characters.
# ID: 242
^[1-9]{1}$|^[1-4]{1}[0-9]{1}$|^50$

# Clock regular expression
# ID: 1537
((\0[0-9])|(\1[0-9])|(\2[0-3])):([0-5][0-9])

# Once , use first regex to find groups. and then use the second regex. first results to second regex source.
# ID: 2016
\[(?<GroupName>.*)\](?<GroupContent>[^\[]+)       --------        [\s]*(?<Key>.+)[\s]*=[\s]*(?<Value>[^\r]+)

# Take in account the fact that the first letter cannot be a w or a z  moreover the fact that letters cannot be any of DFIOQU
# ID: 2665
^([a-z-[dfioquwz]]|[A-Z-[DFIOQUWZ]])\d([a-z-[dfioqu]]|[A-Z-[DFIOQU]])(\s)?\d([a-z-[dfioqu]]|[A-Z-[DFIOQU]])\d$

# Orginally on this site search for Path, go to next page
# ID: 970
^\\([^\\]+\\)*[^\/:*?"<>|]?$

# Validates email addresses (except those using IP) according to list of TLD's http://data.iana.org/TLD/tlds-alpha-by-domain.txt .
# ID: 3289
^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9]+([a-z0-9-]*[a-z0-9]+)*(\.[a-z0-9]+([a-z0-9-]*[a-z0-9]+)*)*\.([a-z]{2}|xn\-{2}[a-z0-9]{4,18}|arpa|aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|xxx)$

# Meets almost all email address, whacky ones included
# ID: 2755
^([0-9a-zA-Z]+[-._+&])*[0-9a-zA-Z_-]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$

# Us phone number validation
# ID: 2130
1?[ \.\-\+]?[(]?([0-9]{3})?[)]?[ \.\-\+]?[0-9]{3}[ \.\-\+]?[0-9]{4}

# This expression will match almost all variations of PO Box.
# ID: 2043
\b[P|p]*(OST|ost)*\.*\s*[O|o|0]*(ffice|FFICE)*\.*\s*[B|b][O|o|0][X|x]\b

# Finds all the zips in Los Angeles County.  This regex is useful in Ubercart if you have a business presence in L.A. County but not elsewhere in CA.
# ID: 3498
^(900[0-9][0-9]|902[0-9][0-9]|9030[1-5]|9040[1-5]|9050[1-6]|9060[1-6]|90608|90631|90638|90639|90640|90650|90660|90670|90680|9070[1-4]|90706|90710|90712|90713|90715|90716|90717|90723|9073[1-3]|9074[4-6]|90747|90755|9080[2-8]|90810|9081[3-5]|90822|9083[1-2]|90840|90846|910[0-4][0-9]|91101|9110[3-8]|9112[5-6]|9120[1-8]|91214|913[0-6][0-9]|91372|91381|91384|9140[1-3|5-6]|91411|91423|91436|9150[1-2|4|6]|91510|91523|9160[1-2|4-8]|91702|91706|91711|9172[2-4]|9173[1-3]|9174[0-1|4-6|8]|9175[0|4-6]|9176[5-8]|9177[0|3|5-6]|9178[0-1|3]|91789|92621|93510|93523|9353[2|4-6]|93543|93544|9355[0-3]|93563|93591)(-[0-9]{4})?$

# This expression will be useful to check mobile
# ID: 2416
(\+91(-)?|91(-)?|0(-)?)?(9)[0-9]{9}

# This expression will be useful to check postal code or pin code of India. This expression will check postal code or pin code in two format. One is code is separated by space after 3 digit and another is code is written in 6 digit.
# ID: 2417
([0-9]{6}|[0-9]{3}\s[0-9]{3})

# This expression will help you to match chennai telephone numbers. chennai bsnl telephone numbers will start from 2.
# ID: 2500
^(0)44[\s]{0,1}[\-]{0,1}[\s]{0,1}2[\s]{0,1}[1-9]{1}[0-9]{6}$

# It allows separators ',' & '.', max. 2 decimals, value must be between 1 & 9999999,99
# ID: 3511
^[1-9][0-9]{0,6}(|.[0-9]{1,2}|,[0-9]{1,2})?

# This checks whether the string is equals to "*" i.e., contains only "*(Asterisk)" or begins with Asterisk.
# ID: 2226
^[:*:]

# Tries to find the proper nouns in a text
# ID: 1699
((?!(This|It|He|She|[MTWFS][a-z]+day|[JF][a-z]+ary|March|April|May|June|July|August|[SOND][a-z]+ber))(?:[A-Z]+\.\s?)*(?:(?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+)(?:(\b\s?((?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+|[A-Z]+\.|on|of|the|von|der|van|de|bin|and))*(?:\s*(?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+))?)

# Pull Hostname from URI/URL
# ID: 3273
(([a-zA-Z0-9\-]*\.{1,}){1,}[a-zA-Z0-9]*)

# allows positive none-to-3-decimal values between 0.000 and 1000.000
# ID: 615
^1000([.][0]{1,3})?$|^\d{1,3}$|^\d{1,3}([.]\d{1,3})$|^([.]\d{1,3})$

# allows positive and negative none-to-3-decimal values between -1000.000 and 1000.000
# ID: 616
^(\-)?1000([.][0]{1,3})?$|^(\-)?\d{1,3}$|^(\-)?\d{1,3}([.]\d{1,3})$|^(\-)?([.]\d{1,3})$

# currency format that allows optional $, optional "-"(MinusSignNegative) OR "()" (ParenNegative) but not both, optional cents, and optional commas separating thousands. Minus sign can be before or after $, but parens must be outside the $. UPDATED: now fails to match a "$" without any further numbers
# ID: 625
^\$?\-?([1-9]{1}[0-9]{0,2}(\,\d{3})*(\.\d{0,2})?|[1-9]{1}\d{0,}(\.\d{0,2})?|0(\.\d{0,2})?|(\.\d{1,2}))$|^\-?\$?([1-9]{1}\d{0,2}(\,\d{3})*(\.\d{0,2})?|[1-9]{1}\d{0,}(\.\d{0,2})?|0(\.\d{0,2})?|(\.\d{1,2}))$|^\(\$?([1-9]{1}\d{0,2}(\,\d{3})*(\.\d{0,2})?|[1-9]{1}\d{0,}(\.\d{0,2})?|0(\.\d{0,2})?|(\.\d{1,2}))\)$

# Pattern for user name input form validation <br />Expression pour tester la validité des noms propres lors de la validation des formulaires.  <br />Syntaxe: <br />Les particules (de della, von, op, …..) peuvent être en minuscule  <br />Après les particules doit apparaître un nom, écrit en minuscule, mais avec la première lettre en majuscule. <br />Les éléments du nom peuvent être séparés par un seul espace, un moins ou une apostrophe
# ID: 1426
^([a-z]{1,6}[ ']){0,3}([ÉÈÊËÜÛÎÔÄÏÖÄÅÇA-Z]{1}[éèëêüûçîôâïöäåa-z]{2,}[- ']){0,3}[A-Z]{1}[éèëêüûçîôâïöäåa-z]{2,}$

# This expression will match a 10 or 11 digit US phone number with optional area code parenthesis, non-standard seperators such as spaces or dot's (.), and an extension up to 6 digits long
# ID: 3217
^[1]?[-\.\s]?(\(\d{3}\)|\d{3}){1}[-\.\s]?\d{3}[-\.\s]?\d{4}(\s+|\s*[-\.x]{1}\d{1,6})?$

# This expression validation for price.
# ID: 3232
^(([$])?((([0-9]{1,3},)+[0-9]{3})|[0-9]+)(\.[0-9]{2})?)$

# Information about Regular Expression Syntax
# ID: 2853
^*[]!#

# Regex to validate strong password for .NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.
# ID: 2513
(?=^[!@#$%\^&*()_\-+=\[{\]};:<>|\./?a-zA-Z\d]{7,}$)(?=([!@#$%\^&*()_\-+=\[{\]};:<>|\./?a-zA-Z\d]*\W+){1,})[!@#$%\^&*()_\-+=\[{\]};:<>|\./?a-zA-Z\d]*$

# Meets dutch phone number requirements.. One posted here before didn't allow the 0 after the first digit of the call ID (so the second number or later after the prefix), which should be allowed. I modified that one to meet full requirements now..
# ID: 935
([0]{1}[6]{1}[-\s]*[1-9]{1}[\s]*([0-9]{1}[\s]*){7})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\s]*[1-9]{1}[\s]*([0-9]{1}[\s]*){5})|([0]{1}[1-9]{1}[0-9]{1}[-\s]*[1-9]{1}[\s]*([0-9]{1}[\s]*){6})

# This Expression checks if the value is an integer, positive, not zero and not a decimal.
# ID: 734
^[0-9]*[1-9]+$|^[1-9]+[0-9]*$

# matches all rapidshare.com links /files / 8 numbers / filename
# ID: 2235
/rapidshare\.com\/files\/(\d+)\/([^\'^\"^\s^>^<^\\^\/]+)/

# Matches international formated phonenumber. More info on http://maartendeblock.blogspot.com
# ID: 1767
^\+[0-9]{1,3}\.[0-9]+\.[0-9]+$

# 
# ID: 889
".*?"|".*$|'.*?'|'.*$

# This is a Perl regular expression which matches any valid URI. I've extensively tested it (with the help of Wikipedia, and the actual URI specification written by Sir Tim Burners Lee himself), and it seems to work in all cases. Whether it will actually work to validate a URI is questionable... But any URI that is valid, will match. Including those with IPv6 addresses.
# ID: 3246
^([a-z0-9+\-.]+):([/]{0,2}([a-z0-9\-._~%!\$&'\(\)\*+,;=:]+@)?([\[\]a-z0-9\-._~%!\$&'\(\)\*+,;=:]+(:[0-9]+)?))([a-z0-9\-._~%!\$&'\(\)\*+,;=:@/]*)(\?[\?/a-z0-9\-._~%!\$&'\(\)\*+,;=:@]+)?(\#[a-z0-9\-._~%!\$&'\(\)\*+,;=:@/\?]+)?

# Matches any legal java class (inclusive package name).
# ID: 1367
^[a-zA-Z]([a-zA-Z0-9])*([\.][a-zA-Z]([a-zA-Z0-9])*)*$

# Hi, this is my first try at regular expressions. I was having trouble understanding the syntax and finally I got it work!
# ID: 423
(^\-?[0-9]*\.?[0-9]+$)

# search special character form a given sting space is ignored.
# ID: 2752
[^A-Za-z0-9 ]

# This RegExp matches a space (" ") character with lookahead condition if there is an ASCII text in front of it and it is followed by a single decimal number which in turn is followed by a dot or nothing. It's useful to seperate scientific notation numbers from a text, i.e. when classifying with the bow toolkit.
# ID: 822
(?=([\W]*[\w][\W]*\b))\s(?=\d\.|\d\b)

# Registro Federal de Contribuyentes (RFC) , used in Mexico as a unique set of caracters for a person or corporation registration .
# ID: 1065
^([A-Z|a-z|&]{3}\d{2}((0[1-9]|1[012])(0[1-9]|1\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)(\w{2})([A|a|0-9]{1})$|^([A-Z|a-z]{4}\d{2}((0[1-9]|1[012])(0[1-9]|1\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)((\w{2})([A|a|0-9]{1})){0,3}$

# RFC Registro Federal de Contribuyentes en Mexico para el SAT
# ID: 3550
^([A-ZÑ\x26]{3,4}([0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-9]|3[0-1])[A-Z|\d]{3})$

# Can handle a variety of standard phone formats.
# ID: 2816
([(]?\d{3}[)]?(-| |.)?\d{3}(-| |.)?\d{4})

# To allow for checking of Singapore mobile numbers. Numbers are 8 digits starting with an 8 or 9 in Singapore.
# ID: 3144
^[89]\d{7}$

# This expression was written for C#, and as such you should just be able to drop it in.
# ID: 2285
^((\\\\[a-zA-Z0-9-]+\\[a-zA-Z0-9`~!@#$%^&(){}'._-]+([ ]+[a-zA-Z0-9`~!@#$%^&(){}'._-]+)*)|([a-zA-Z]:))(\\[^ \\/:*?""<>|]+([ ]+[^ \\/:*?""<>|]+)*)*\\?$

# This was written for C# and so you should just be able to drop it into your C# program.
# ID: 2286
^[^ \\/:*?""<>|]+([ ]+[^ \\/:*?""<>|]+)*$

# First word and second word should be a single space
# ID: 2186
# Multiline
^[\w\s]+$
^[[A-Z]\s]$

# will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days.
# ID: 808
^(?:(?:0?[13578]|1[02])|(?:0?[469]|11)(?!\/31)|(?:0?2)(?:(?!\/3[01]|\/29\/(?:(?:0[^48]|[13579][^26]|[2468][^048])00|(?:\d{2}(?:0[^48]|[13579][^26]|[2468][^048]))))))\/(?:0?[1-9]|[12][0-9]|3[01])\/\d{4}$

# this works with ASP.net regular expression valiadtors, ecma script compliant
# ID: 187
^(\d{5}-\d{4}|\d{5})$

# validate mobile and land phone numbers.
# ID: 3271
^(([0-9]{2,4})([-\s\/]{0,1})([0-9]{4,8}))?$

# Prefixes for Italian mobiles
# ID: 3299
^3[234689][0-9]$

# Matches the date format "YYYY-mm-dd" and also validates month and number of days in a month. All leap year dates "YYYY-02-29" passes trough. Could easily be changed to another format.
# ID: 933
^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$

# This expression matches url that starts with or without http(s)
# ID: 2863
^(((h|H)(t|T))(t|T)(p|P)((s|S)?)\:\/\/)?((www|WWW)+\.)+(([0-9]{1,3}){3}[0-9]{1,3}\.|([\w!~*'()-]+\.)*([\w^-][\w-]{0,61})?[\w]\.[a-z]{2,6})(:[0-9]{1,4})?((\/*)|(\/+[\w!~*'().;?:@&=+$,%#-]+)+\/*)$

# This expression validates alphanumeric with one alphabet compulsory and one numeric compulsory and accepts minimum 6 characters and max 15 characters irrespective of the order and case.It doesnt accept special characters
# ID: 2864
(?!^[0-9 ]*$)(?!^[a-zA-Z ]*$)^([a-zA-Z0-9 ]{6,15})$

# This expression validates urls that starts with http/HTTP/https/HTTPS/ftp/FTP/www/WWW.Its accepts either capital letters or small letters.Address is not case sensitive
# ID: 2865
^((http|HTTP|https|HTTPS|ftp|FTP?)\:\/\/)?((www|WWW)+\.)+(([0-9]{1,3}){3}[0-9]{1,3}\.|([\w!~*'()-]+\.)*([\w^-][\w-]{0,61})?[\w]\.[a-z]{2,6})(:[0-9]{1,4})?((\/*)|(\/+[\w!~*'().;?:@&=+$,%#-]+)+\/*)$

# a simple expression to validate Persian dates.
# ID: 2966
^1[34][0-9][0-9]\/((1[0-2])|([1-9]))\/(([12][0-9])|(3[01])|[1-9])$

# Trying to remove all these characters in the regular expression: still working on it
# ID: 469
[^!~/><\|/#%():;{}`_-]

# this is a very little regex for use within a content management software.  links within textfields has not to be written in html.  the editor of the cms is instructed to use it like this:  1. mention spaces in front and behind the url  2. start url with http://, mailto://, ftp:// ...  3. use optional linktext within #linktext# (separated with single space)  4. if there is no linktext the url/email will show up as linktext  5. avoid url with spaces in filename (use %20 urldecode)   replace pattern (space in front):   <a href="\\1\\3\\4" target="_blank">\\3\\6</a>
# ID: 422
(mailto\:|(news|(ht|f)tp(s?))\://)(([^[:space:]]+)|([^[:space:]]+)( #([^#]+)#)?)

# Matches the Common Name (CN) of the subject of a US Department of Defense (DoD) Common Access Card (CAC). In the plain-text part of the client certificate stored on a CAC, a subject, or the person named as the user of the certificate is represented by their Common Name. This regex identifies CNs and groups the parts that represent first and last name and the unique 10-digit identifying number at the end. I optionally matches the middle name or initial and ordinal (or generation) (II,III,IV, etc), if present.
# ID: 2566
^\s*(?<Last>[-A-Za-z ]+)[.](?<First>[-A-Za-z ]+)(?:[.](?<Middle>[-A-Za-z ]+))?(?:[.](?<Ordinal>[IVX]+))?(?:[.](?<Number>\d{10}))\s*$

# Vat percentage format for Indian and Germany.Maximum two digit before decimal and after decimal
# ID: 2858
^([1-9]{0,1})([0-9]{1})((\.[0-9]{0,1})([0-9]{1})|(\,[0-9]{0,1})([0-9]{1}))?$

# Validate Germany postcode contains only 5 digits and starting with 0 to 9.
# ID: 2859
^([012346789][0-9]{4})$

# Checks for filename of any version of minified jquery in string.
# ID: 3108
jquery\-(\d|\.)*\.min\.js

# Replacing match for bold formatting as DokuWiki writes it
# ID: 3109
(\*\*)(.+)(\*\*)

# Replacing match for italic formatting as DokuWiki writes it
# ID: 3110
(\/\/)(.+)(\/\/)

# Replacing match for underline formatting as DokuWiki writes it
# ID: 3111
(\_\_)(.+)(\_\_)

# This regular expression pattern can be used to check the validity of paths for file upload controls. The uploaded file can be either stored locally or accessible through UNC. It cannot contain illegal characters for the windows OS - that may be supported e.g. on Mac OS – and cannot be a URL (Yes, as weird as it may seem, some users enter URLs in the file upload box, even though there is a browse button...)
# ID: 127
([A-Z]:\\[^/:\*\?<>\|]+\.\w{2,6})|(\\{2}[^/:\*\?<>\|]+\.\w{2,6})

# This is world's best solution
# ID: 1921
^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

# indian mobile number perfect validation for three number series's that start with 9,8,7. if you want you can easily add one more series that you want in feature. it validates 10 digit number starting with 9,8,7 and followed by 9 digits 0-9 in any order.
# ID: 3535
^([987]{1})(\d{1})(\d{8})

# Regexp to find all external links in a HTML string.
# ID: 232
^<a\s+href\s*=\s*"http:\/\/([^"]*)"([^>]*)>(.*?(?=<\/a>))<\/a>$

# Swedish person number. Don't work on persons older then 100 years, but they are so few that it shouldn't be a problem. Easy to fix, but I choose not to accept oldies...
# ID: 927
[1-2][0|9][0-9]{2}[0-1][0-9][0-3][0-9][-][0-9]{4}

# This will match an entire HTML tag and will capture the href portion into the named capture "url". It will match any anchor tag with any number of attributes.
# ID: 1525
<a\s+(?:(?:\w+\s*=\s*)(?:\w+|"[^"]*"|'[^']*'))*?\s*href\s*=\s*(?<url>\w+|"[^"]*"|'[^']*')(?:(?:\s+\w+\s*=\s*)(?:\w+|"[^"]*"|'[^']*'))*?>[^<]+</a>

# This regex will match all html link tags and captures the url into a named capture "url". There can be any html code between the opening and closing link tags. You must use this with the multiline and ignore case options selected.
# ID: 1526
<a\s+(?:(?:\w+\s*=\s*)(?:\w+|"[^"]*"|'[^']*'))*?\s*href\s*=\s*(?<url>\w+|"[^"]*"|'[^']*')(?:(?:\s+\w+\s*=\s*)(?:\w+|"[^"]*"|'[^']*'))*?>.+?</a>

# This expression shows result for the alphanumeric value starts with only alpha bates.
# ID: 3099
^([a-zA-Z][a-zA-Z0-9]{1,100})$

# Matches that an input string is a valid namespace definition.  It also captures each word / section in the namespace in case they are needed.
# ID: 858
^(?:(?:((?![0-9_])[a-zA-Z0-9_]+)\.?)+)(?<!\.)$

# Will not validate numbers starting with 0 or 1.  Only validates digits.
# ID: 3259
^[2-9]{2}[0-9]{8}$

# Used for a dropdown list that might have a couple of default selections you want to include.
# ID: 2925
^[^ ,0]*$

# Recently I've been forced to validate phone numbers in a variety of formats, with all sorts of whitespace, dashes, parenthesis, etc. I didn't want to hassel with matching all that junk, I just wanted the 10 numbers!
# ID: 832
^[^0-9]*(?:(\d)[^0-9]*){10}$

# Matches Visa, American Express, Discover, and Mastercard only.
# ID: 1908
^((4(\d{12}|\d{15}))|(5\d{15})|(6011\d{12})|(3(4|7)\d{13}))$

# This is a bit shorter than the first CVV2/CVC2/CID regex found on the site. It matches any 3 or 4 character number.
# ID: 1891
^(?!000)\d{3,4}$

# Matches percentages from 0-100 inclusive with two decimal places.
# ID: 1734
^100(\.0{0,2}?)?$|^\d{0,2}(\.\d{0,2})?$

# Optional Amount, with optional thousands seperator (using the point) and optional decimal comma. If decimal comma is in string, then 2 trailing digits are required. Also checks for the optional euro sign
# ID: 2243
^([\u20AC]?[1-9]\d*\.\d{3}(?:,\d{2})?|[\u20AC]?[1-9]\d*(?:,\d{2})?|[\u20AC]?[1-9]\d*)$

# match for 0 - 65535
# ID: 664
^([0-5]?\d?\d?\d?\d|6[0-4]\d\d\d|65[0-4]\d\d|655[0-2]\d|6553[0-5])$

# Just test in C#.
# ID: 962
^(?<national>\+?(?:86)?)(?<separator>\s?-?)(?<phone>(?<vender>13[0-4])(?<area>\d{4})(?<id>\d{4}))$

# Matches java Documentation only with no code inside.
# ID: 3114
# Multiline
/\*.*(\R.+)+\*/
# or
/\*.*((\r\n).+)+\*/

# Validate  HTM/HTML/ASP/ASPX
# ID: 2462
^([a-zA-Z1-9]*)\.(((a|A)(s|S)(p|P)(x|X))|((h|H)(T|t)(m|M)(l|L))|((h|H)(t|T)(M|m))|((a|A)(s|S)(p|P)))

# Validate URL
# ID: 2463
(((ht|f)tp(s?):\/\/)(www\.[^ \[\]\(\)\n\r\t]+)|(([012]?[0-9]{1,2}\.){3}[012]?[0-9]{1,2})\/)([^ \[\]\(\),;"\'<>\n\r\t]+)([^\. \[\]\(\),;"\'<>\n\r\t])|(([012]?[0-9]{1,2}\.){3}[012]?[0-9]{1,2})

# First digit can be 7 or 8 or 9.
# ID: 3332
^(((0|((\+)?91(\-)?))|((\((\+)?91\)(\-)?)))?[7-9]\d{9})?$

# Currency expression, accepts 4 commas and 4 groups of 3 numbers and 1 number before the first comma, this first number will have to be different from zero. It accepts a number of, two or three decimal. It accepts zero numbers after the point. You can change the number of groups and numbers accespts before and after the point.
# ID: 1559
^\$?(([1-9],)?([0-9]{3},){0,3}[0-9]{3}|[0-9]{0,16})(\.[0-9]{0,3})?$

# Password must be 6-40 characters - {6,40}
# ID: 2656
^(?=.*[\d])(?=.*[A-Z])(?=.*[a-z])[\w\d!@#$%_]{6,40}$

# I had some mailing contacts in a text file in mailing lable layout, and needed to extract them to database I used this regex to fix capitalization for name and address. THE JIM thomas FAMILY becomes The Jim Thomas Family
# ID: 2051
s/\b(\w+)\b/ucfirst($1)/ge

# View the description correctly formatted here:
# ID: 2052
\s*([a-z\. ]+)\s*\n\s*([a-z0-9\. #]+)\s*\n\s*([a-z \.]+)\s*,\s*([a-z \.]+)\s*\n?(?:\s*(\d{1,15}(?:-\d{1,4})?)\s*\n)?(?:\s*(\+?(?:1\s*[-\/\.]?)?(?:\((?:\d{3})\)|(?:\d{3}))\s*[-\/\.]?\s*(?:\d{3})\s*[-\/\.]?\s*(?:\d{4})(?:(?:[ \t]*[xX]|[eE][xX][tT])\.?[ \t]*(?:\d+))*))?

# I wrote this regex to validate first names or last names separately.  Allows for 2 names separated by space or hyphen.  Will accept an abbreviated second name with period.  Has to start with a letter and end with a letter or capital letter with period.
# ID: 862
^((?:[A-Z](?:('|(?:[a-z]{1,3}))[A-Z])?[a-z]+)|(?:[A-Z]\.))(?:([ -])((?:[A-Z](?:('|(?:[a-z]{1,3}))[A-Z])?[a-z]+)|(?:[A-Z]\.)))?$

# Filters out VB.NET and VB6.0 comments.
# ID: 2160
(REM [\d\D]*?[\r\n])|(?<SL>\'[\d\D]*?[\r\n])

# This regex searches multi-line, single-line, and XML comments present in C# file.
# ID: 2143
(/\*[\d\D]*?\*/)|(\/\*(\s*|.*?)*\*\/)|(\/\/.*)|(/\\*[\\d\\D]*?\\*/)|([\r\n ]*//[^\r\n]*)+

# This expression will validate if a string represents a time in 24 hour format.
# ID: 2335
^([0-1]?[0-9]{1}|2[0-3]{1}):([0-5]{1}[0-9]{1})$

# To maintain both uppercase letters and the digits in the expression.
# ID: 2033
^([A-Z]{2}?(\d{7}))$

# Año con formato dd/mm/yyyy permitiendo también d/m/yyyy o dd/m/yyyy y d/mm/yyyy. Además controla los meses con 31 y 30 días y si es año bisiesto o no para el mes de febrero.
# ID: 1590
^((((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\d{4}))|((0[469]|1­1)([-./])([0][1-9]|[12][0-9]|30)([-./])(\d{4}))|((2)([-./])(0[1-9]|1[0-9]|2­[0-8])([-./])(\d{4}))|((2)(\.|-|\/)(29)([-./])([02468][048]00))|((2)([-./])­(29)([-./])([13579][26]00))|((2)([-./])(29)([-./])([0-9][0-9][0][48]))|((2)­([-./])(29)([-./])([0-9][0-9][2468][048]))|((2)([-./])(29)([-./])([0-9][0-9­][13579][26]))))$

# Entero o fracción de enteros separados por el símbolo barra /
# ID: 1591
\d+(/\d+)?

# This expression finds all opening and closing tags.  Good for stripping out tags in an XML or HTML document.
# ID: 270
<[^>]+>

# Check that a valid date has been entered. Uses mm/dd/yyyy or m/d/yy format or various combinations. Checks for valid leap years.
# ID: 2944
^((((0?[13578]|1[02])\/([0-2]?[1-9]|20|3[0-1]))|((0?[469]|11)\/([0-2]?[1-9]|20|30))|(0?2\/([0-1]?[1-9]|2[0-8])))\/((19|20)?\d{2}))|(0?2\/29\/((19|20)?(04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96)|2000))$

# A simple email checking regex . Works with all regular email addresses . Allows only 'a-z' '-' '_' and '.'  to be included withing the user name which must to be started and teminated with 'a-z' and could not have any symbol sequence (like '-_' '._') in it's body .
# ID: 2889
^((([a-z0-9])+([\w.-]{1})?)+([^\W_]{1}))+@((([a-z0-9])+([\w-]{1})?)+([^\W_]{1}))+\.[a-z]{2,3}(\.[a-z]{2,4})?$

# This regex validates a persons last name. Acceptable names can include a single quote, compound names seperated by a hyphen, or followed by "Jr." or "I", "II", "III".
# ID: 3193
(/^[A-Z][a-z]*(([\'\,\.\-]?[A-Z])?[a-z]*)((\s)?((Jr.(\.))|I|II|III]))?$/,

# This syntax matches most surname prefixes and suffixes with the surname appropriately placed.  Assumes all caps.  Useful if you want a precise match of surname prefixes and suffixes.
# ID: 1516
((A[FGIKLMNPRSUZ]S?X?|DAL?L?A?E?S?|DE|DE[LNRST]L?A?E?H?I?O?S?|DI[AE]?|DOS?|DU|EIT?N?E?|ELS?|EN|ETT?|HAI?|HE[NT]|HIN?A?I?N?R?|HOI|IL|IM|ISA|KA|KE|LAS|LES?|LH?IS?|LOS?|LO?U|MA?C|N[AIY]|O[IP]|SI|T[AEO]N?R?|U[MN][AEOS]?|VAN|VE[LR]|VO[MN]|Y[ENR]|ZU[MR]?) )?((LAS?|LOS?|DEN?R?|ZU) )?[A-Z0/'\.-]+( |$)(SR|JR|II+V?|VI+|[1-9][STRDH]+)?

# This pattern requires at least two lowercase letters, two uppercase letters, two digits, and two special characters.  There must be a minimum of 9 characters total, and no white space characters are allowed.
# ID: 1613
^(?=.*[a-z].*[a-z])(?=.*[A-Z].*[A-Z])(?=.*\d.*\d)(?=.*\W.*\W)[a-zA-Z0-9\S]{9,}$

# GUID Tester.
# ID: 134
^[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}$

# Latvia's post code
# ID: 2026
^(LV-)[0-9]{4}$

# select ID,PerName,Sr1,Sr2,Kc1,Kc2 from PitTable
# ID: 3298
(?<=select).*(?]from)

# This accepts html's tables, with rows and colums.
# ID: 1283
<table>(<tr>((<td>([A-Za-z0-9])*</td>)+)</tr>)*</table>

# it accepts Granada's numbers telephone.
# ID: 1284
^(958([0-9])+([0-9])+([0-9])+([0-9])+([0-9])+([0-9])+)|(958-([0-9])+([0-9])+([0-9])+([0-9])+([0-9])+([0-9])+)$

# C++ prototipes.
# ID: 1285
(\s)*(int|void|float|char|double|string)((\s)|(\*))*(\&?)(\s)+([a-z])([a-z0-9])*(\s)*(\()(\s)*((int|void|float|char|double|string)((\s)|(\*))*(\&?)(\s)+([a-z])([a-z0-9])*((\s)*[,](\s)*(int|void|float|char|double|string)((\s)|(\*))*(\&?)(\s)+([a-z])([a-z0-9])*)*)?(\s)*(\))(\s)*;

# Valiadation IP RegExp.
# ID: 2118
^(?:(?:1\d{0,2}|[3-9]\d?|2(?:[0-5]{1,2}|\d)?|0)\.){3}(?:1\d{0,2}|[3-9]\d?|2(?:[0-5]{1,2}|\d)?|0)$

# Finds all public or private C# methods with a return type, with or without parameters. Excludes private and public members which may look like a method.  Private and public members that can be confused with methods typically have a semicolon after the closing parentheses.
# ID: 1783
(private|public|protected)\s\w(.)*\((.)*\)[^;]

# For testing 24H based time entry.  Tests if there is a colon to separate the hours from the minutes
# ID: 360
^(([0-9])|([0-1][0-9])|([2][0-3])):?([0-5][0-9])$

# Matches a comma-seperated list of year(s).
# ID: 414
^([1-9]{1}[0-9]{3}[,]?)*([1-9]{1}[0-9]{3})$

# Regular expression to limit types of files accepted. This example matches .aspx files only.
# ID: 2368
^([a-zA-Z].*|[1-9].*|[:./].*)\.(((a|A)(s|S)(p|P)(x|X)))$

# Matches the UK Drivers License format as laid down by the DVLA / dvla. See http
# ID: 3132
^([A-Z]{2}[9]{3}|[A-Z]{3}[9]{2}|[A-Z]{4}[9]{1}|[A-Z]{5})[0-9]{6}([A-Z]{1}[9]{1}|[A-Z]{2})[A-Z0-9]{3}[0-9]{2}$

# This is a pattern for Regular and Cell Phone Numbers of israel,
# ID: 2040
^[0][5][0]-\d{7}|[0][5][2]-\d{7}|[0][5][4]-\d{7}|[0][5][7]-\d{7}|[0][7][7]-\d{7}|[0][2]-\d{7}|[0][3]-\d{7}|[0][4]-\d{7}|[0][8]-\d{7}|[0][9]-\d{7}|[0][5][0]\d{7}|[0][5][2]\d{7}|[0][5][4]\d{7}|[0][5][7]\d{7}|[0][7][7]\d{7}|[0][2]\d{7}|[0][3]\d{7}|[0][4]\d{7}|[0][8]\d{7}|[0][9]\d{7}$

# Validar o do CEP Brasileiro com 8 posicoes podendo usar
# ID: 188
(^\d{5}-\d{3}|^\d{2}.\d{3}-\d{3}|\d{8})

# Valida os todos Estados Brasileiros (UF)
# ID: 199
^(ac|AC|al|AL|am|AM|ap|AP|ba|BA|ce|CE|df|DF|es|ES|go|GO|ma|MA|mg|MG|ms|MS|mt|MT|pa|PA|pb|PB|pe|PE|pi|PI|pr|PR|rj|RJ|rn|RN|ro|RO|rr|RR|rs|RS|sc|SC|se|SE|sp|SP|to|TO)$

# It will allow for alphanumeric characters only, with the exception of spacing.
# ID: 1510
^[a-zA-Z0-9\040]+$

# This was used to process a bunch of lines of information to determine if a line was a North American phone number or not.  It accepts numbers with or without area code with or without parenthesis and sepearated by space, dash or period.
# ID: 485
([\(]?(?<AreaCode>[0-9]{3})[\)]?)?[ \.\-]?(?<Exchange>[0-9]{3})[ \.\-](?<Number>[0-9]{4})

# This expression extract all class names from a php source code. E.g. it will extract A from the following declarations
# ID: 2995
/class\s+([a-z0-9_]+)(?:\s+extends\s+[a-z0-9_]+)?(?:\s+implements\s+(?:[a-z0-9_]+\s*,*\s*)+)?\s*\{/Usi

# Positive real number greater than zero.
# ID: 1063
(^[0-9]*[1-9]+[0-9]*\.[0-9]*$)|(^[0-9]*\.[0-9]*[1-9]+[0-9]*$)|(^[0-9]*[1-9]+[0-9]*$)

# Simple email matching expression, that allows for a friendly name string similar to what you see in outlook 2007.
# ID: 2520
(".+"\s)?<?[a-z\._0-9]+[^\._]@([a-z0-9]+\.)+[a-z0-9]{2,6}>?;?

# My goal with this was to have a pretty loose and flexible validation, accept a number of different input strings, but still inforce the core of what a phone number is. Country Code optional, Area Code required, with optional extension as well for business numbers.
# ID: 2521
[\+]?[\s]?(\d(\-|\s)?)?(\(\d{3}\)\s?|\d{3}\-?)\d{3}(-|\s-\s)?\d{4}(\s(ex|ext)\s?\d+)?

# I needed a clean string of keywords submitted in a form. This expression will select every word that doesn't have a vowel, every word that is shorter than 2 characters. It will select all non alphabetical characters.
# ID: 2056
([^\w]+)|([^A-Za-z])|(\b[^aeiouy]+\b)|(\b(\w{2})\b)

# International Phone Number conventions are really difficult to get a one-size-fits-all regex for. This version forces numbers to start with a plus sign (international dialling symbol), then a country code and then the phone number
# ID: 3172
^\+(?:[0-9] ?){6,14}[0-9]$

# Email validation for domain or IP
# ID: 1315
^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+$

# With this regex you can find or replace any CSS commentary in your stylesheets in once. Build for use with dreamweaver. Probably works also fine in any other circumstances.
# ID: 2229
/\*[^\/]+/

# Big or small A letter
# ID: 1939
(a|A)

# This Expression will help you in Validating Multiple e-Mail IDs in a single line seperated by ";"
# ID: 2312
^(\w+([_.]{1}\w+)*@\w+([_.]{1}\w+)*\.[A-Za-z]{2,3}[;]?)*$

# Matches all kind of URIs: mailto's, http(s), (s)ftp(s), ..., or just www addresses without protocol prefix.
# ID: 2467
(((s*)(ftp)(s*)|(http)(s*)|mailto|news|file|webcal):(\S*))|((www.)(\S*))

# The first field consist of 10 numbers, then 3 characters (GBP as its for UK passports), 7 numbers, 1 character and 7 numbers. The final field is for the 2 numbers at the right-hand end of the <<<<< symbols.
# ID: 2390
^[0-9]{10}GBR[0-9]{7}[U,M,F]{1}[0-9]{9}$

# These are identified from the driving license as follows:
# ID: 2391
^([A-Z]{2}[9]{3}|[A-Z]{3}[9]{2}|[A-Z]{4}[9]{1}|[A-Z]{5})[0-9]{6}([A-Z]{1}[9]{1}|[A-Z]{2})[A-Z0,9]{3}$

# • 9 characters made up of a combination of numbers and/or letters. Where less than 9 characters it will be padded out to the right with chevrons (<).
# ID: 2392
^[A-Z0-9<]{9}[0-9]{1}[A-Z]{3}[0-9]{7}[A-Z]{1}[0-9]{7}[A-Z0-9<]{14}[0-9]{2}$

# Validates dates that are in month/year (MMYYYY) format without slashes, periods, dashes, or spaces.  No special characters or letters allowed.  MM values allowed are 01 thru 12.  YYYY values allowed are 1900 - 2999.
# ID: 2426
(((0[123456789]|10|11|12)(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))

# 1 to 10 digits are allowed before the decimal.  1 to 2 digits are allowed after decimal.   Zero is allowed.  Whole numbers allowed.
# ID: 3553
(?!^0*\.0*$)^\d{1,10}(\.\d{1,2})?$

# I've come to this expression according with (most of) the naming conventions provided by MS in this page:
# ID: 3039
^((?:(?:[a-zA-Z]:)|\\)\\)?((?:\.\.?\\)|(?:[^\0-\31<>:"/\\|?*]+(?<![ .])\\))*([^\0-\31<>:"/\\|?*]+(?<![ .]))?$

# Matches all common horizontal smileys facing from left to right in its own "word". To match horizontal smileys in the reverse direction (.ie D:) see horozontal smileys (reverse).
# ID: 1452
(\A|\s)(((>[:;=+])|[>:;=+])[,*]?[-~+o]?(\)+|\(+|\}+|\{+|\]+|\[+|\|+|\\+|/+|>+|<+|D+|[@#!OoPpXxZS$03])|>?[xX8][-~+o]?(\)+|\(+|\}+|\{+|\]+|\[+|\|+|\\+|/+|>+|<+|D+))(\Z|\s)

# Matches all common horizontal smileys from right to left in its own "word".
# ID: 1453
(\A|\s)((\)+|\(+|\}+|\{+|\]+|\[+|\|+|\\+|/+|>+|<+|D+|[@#!OoXxZS$0])[-~+o]?[,*]?((<[:;=+])|[<:;=+])|(\)+|\(+|\}+|\{+|\]+|\[+|\|+|\\+|/+|>+|<+|D+)[-~+o]?[xX8]<?)(\Z|\s)

# Matches all common vertical smileys in a "word".
# ID: 1454
(\A|\s)[({\[]*([\^\*\-@#$%<>XxVvOo0ZzTt+'¬](_+|\.)[\^\*\-@#$%<>XxVvOo0ZzTt+'¬]|\._\.|[\^\*@#$%<>XxVOo0ZTt']\-[\^\*@#$%<>XxVOo0ZTt']|>>|><|<<|o[O0]|[O0]o)[)}\]]*[;.?]*['"]?(\Z|\s)

# Use this regular expression pattern to get the string1, string2, string3 .... from <blockquote>string1<br>string2<br>string3<br></blockquote>
# ID: 234
<blockquote>(?:\s*([^<]+)<br>\s*)+</blockquote>

# I made this to validate offsets to GMT
# ID: 847
^([-]?[0-9])$|^([-]?[1][0-2])$

# This was made for specifying GMT offsets with 2 decimal places.  It will validate any number from -12 to 13 with 2 decimal places.
# ID: 848
^([-]?[0-9]?(\.[0-9]{0,2})?)$|^([-]?([1][0-1])(\.[0-9]{0,2})?)$|^([-]?([1][0-3](\.[0]{0,2})))$

# This will pull the HREF values out of any HTML tag in a query and present only the HREF values.  It's very versatile, it can accept a number of nonstandard formats.
# ID: 1581
(?<=<(\S|\s)*)((?<=(href=('|")+))|(?<=(href=))[^('|")])([^'>"\s)]*)(?=('|"|[\S])?)

# retrieve all tagname in XML/HTML string
# ID: 1189
(?<=<[\/?]?)\w+(?::\w+)?

# Get all string definition in C# code
# ID: 1192
@"([^"]|["]{2})*"|".*?(?<=[^\\]|[\\]{2})"

# Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for widely available classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).
# ID: 2821
^([a-z]{2,3}(\.[a-zA-Z][a-zA-Z_$0-9]*)*)\.([A-Z][a-zA-Z_$0-9]*)$

# Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for local classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).
# ID: 2824
^(([a-zA-Z][a-zA-Z_$0-9]*(\.[a-zA-Z][a-zA-Z_$0-9]*)*)\.)?([a-zA-Z][a-zA-Z_$0-9]*)$

# Regex for validating format of Hungarian phone numbers.
# ID: 2825
^(\+?36)?[ -]?(\d{1,2}|(\(\d{1,2}\)))/?([ -]?\d){6,7}$

# Test a valid dutch licenceplate. Uppercase and with hyphens
# ID: 2064
^[A-Z]{2}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[0-9]{2}-[A-Z]{2}|[0-9]{2}-[A-Z]{2}-[0-9]{2}|[A-Z]{2}-[0-9]{2}-[A-Z]{2}|[A-Z]{2}-[A-Z]{2}-[0-9]{2}|}|[0-9]{2}-[A-Z]{2}-[A-Z]{2}|[0-9]{2}-[A-Z]{3}-[0-9]{1}|[0-9]{1}-[A-Z]{3}-[0-9]{2}$

# This expression is used to validate fractions (entered as strings). It will also accept non-fractional entries. Simple, but effective.
# ID: 281
^\d* \d*\/{1}\d*$|^\d*$

# [Default]
# ID: 123
(a|b|c).(a.b)*.b+.c

# Used in my SVG parser.
# ID: 3098
[-+]?((\.[0-9]+|[0-9]+\.[0-9]+)([eE][-+][0-9]+)?|[0-9]+)

# Accepts data of time in format h:mm and hh:mm
# ID: 261
^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$

# An expression for .NET regular expression validation controls intended to facilitate the entry of percentage values both a whole numbers or as their decimal representations. Also compatible with the default US format for string formatting for percentages. Recommend that if you intended accept a value passing this express that you strip the percentage signs and take measures to ensure that any whole values are converted to percentages.
# ID: 1513
^[+-]?\d+(\.\d{1,4})? *%?$

# checks for valid South African cellular numbers
# ID: 141
(^0[78][2347][0-9]{7})

# This RegularExpression is used to validate the US - SSN. This regular expression wont allow characters as well as all zeros
# ID: 1988
(^(?!000)\d{3}) ([- ]?) ((?!00)\d{2}) ([- ]?) ((?!0000)\d{4})

# This Regular Expression is used to validate the EIN of Employer in US.
# ID: 1989
(^(?!00)\d{2}) ([- ]?) ((?!0000000)\d{7})

# this is a regular expression that for chinese programer!
# ID: 253
^([2][0]\d{2}\/([0]\d|[1][0-2])\/([0-2]\d|[3][0-1]))$|^([2][0]\d{2}\/([0]\d|[1][0-2])\/([0-2]\d|[3][0-1])\s([0-1]\d|[2][0-3])\:[0-5]\d\:[0-5]\d)$

# Matches the HTML "target" attribute.  I had an editor that edited pages but whe wysiwyg editor would break on link that had a target to say "_top" or another window.  So I needed an expression to match the target attribute on links in HTML.
# ID: 1324
target[ ]*[=]([ ]*)(["]|['])*([_])*([A-Za-z0-9])+(["])*

# Matches URLS that start with numbers and  any TLD that is 2 to 6 characters long. Matches most URLs.  Thanks to eveyone for suggesting modifications!
# ID: 765
^((((H|h)(T|t)|(F|f))(T|t)(P|p)((S|s)?))\://)?(www.|[a-zA-Z0-9].)[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,6}(\:[0-9]{1,5})*(/($|[a-zA-Z0-9\.\,\;\?\'\\\+&%\$#\=~_\-]+))*$

# Identifies http, https, ftp, and ftps
# ID: 766
^(((ht|f)tp(s?))\://).*$

# Java only postcodecheck for the Netherlands, case insensitive.
# ID: 2753
^[1-9]\d{3}\s?(?i)(?!(S[ADS]))([A-Z&&[^FIOQUY]]{2})$

# this expression identify application version. the input should contains one or more numbers separated by . (Dot) sign
# ID: 3164
^\d*((\.\d+)?)*$

# Peseudo-HTML code matcher. Allows for one parameter within the first tag (name is optional), the value of which can be optionally delimited by either double or single quotes. Uses backreferencing to ensure that the end and start tags match, and that any single or double quotes match. Very useful for web forums or any situation where users may be prompted to enter text for display on a webpage somewhere, as it can be quickly processed into HTML without allowing HTML to be specified within the input itself (which may pose a security risk).
# ID: 520
(\[(\w+)\s*(([\w]*)=('|")?([a-zA-Z0-9|:|\/|=|-|.|\?|&]*)(\5)?)*\])([a-zA-Z0-9|:|\/|=|-|.|\?|&|\s]+)(\[\/\2\])

# Checks Email
# ID: 2223
[a-zA-Z0-9_\\-]+@([a-zA-Z0-9_\\-]+\\.)+(com)

# Simple checker for user's float types input.
# ID: 823
^[\-]{0,1}[0-9]{1,}(([\.\,]{0,1}[0-9]{1,})|([0-9]{0,}))$

# This script attempts to return phrases from a string (Example above looks for {3} word phrases)  Combine this with some .Net code, you can display most popular X word phrases in a string.
# ID: 1008
(\b)(\w+(\b|\n|\s)){3}

# Integers with optional positive/negative sign, miles separator (,) and exponential notation
# ID: 2201
/^[-+]?[1-9](\d*|((\d{1,2})?,(\d{3},)*(\d{3})))?([eE][-+]\d+)?$/

# Valids decimal numbers with optional support for:
# ID: 2202
/^[-+]?((\d*|((\d{1,3})?,(\d{3},)*(\d{3})))?)(\.\d*)?([eE][-+]\d+)?$/

# Matches on MMDDYYYY only, requires all 8 digits
# ID: 500
((^(10|12|0?[13578])(3[01]|[12][0-9]|0?[1-9])((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(11|0?[469])(30|[12][0-9]|0?[1-9])((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(0?2)(2[0-8]|1[0-9]|0?[1-9])((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(0?2)(29)([2468][048]00)$)|(^(0?2)(29)([3579][26]00)$)|(^(0?2)(29)([1][89][0][48])$)|(^(0?2)(29)([2-9][0-9][0][48])$)|(^(0?2)(29)([1][89][2468][048])$)|(^(0?2)(29)([2-9][0-9][2468][048])$)|(^(0?2)(29)([1][89][13579][26])$)|(^(0?2)(29)([2-9][0-9][13579][26])$))

# NonStop or Guardian OS process or disk volume name. Must start with a "$" and have an initial letter character with up to six more alpha numberic characters
# ID: 1857
^\${1}[a-z]{1}[a-z\d]{0,6}$

# v2
# ID: 1004
(((ht|f)tp(s?):\/\/)|(www\.[^ \[\]\(\)\n\r\t]+)|(([012]?[0-9]{1,2}\.){3}[012]?[0-9]{1,2})\/)([^ \[\]\(\),;"'<>\n\r\t]+)([^\. \[\]\(\),;"'<>\n\r\t])|(([012]?[0-9]{1,2}\.){3}[012]?[0-9]{1,2})

# This Regex allows usernames with or without special char .
# ID: 2476
^([a-zA-Z]+)[0-9]*\.*[a-zA-Z0-9]+$|^[a-zA-Z]+[0-9]*$

# This will validate all of the most common email addresses, and then others that are not so common.
# ID: 3145
^[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\.[a-zA-Z]{2,4}\s*$

# This will match any valid RFC2822 e-mail address typed into web forms.  If does not support comments, display name, or line folding.  It does support quoted-strings in the local-part and domains by the RFC 1035 and proper ip addresses.  It does relax the RFC1035 rule of not allowing numbers as the first character of a domain name (since they do exist in real life)
# ID: 1336
^([A-Za-z0-9\!\#\$\%\&\'\*\+\-\/\=\?\^\_\`\{\}\|\~]+|"([\x01-\x08\x0B\x0C\x0E-\x1F\x21\x23-\x5B\x5D-\x7F]|\\[\x0-\x7F])*")(\.([A-Za-z0-9\!\#\$\%\&\'\*\+\-\/\=\?\^\_\`\{\}\|\~]+|"([\x01-\x08\x0B\x0C\x0E-\x1F\x21\x23-\x5B\x5D-\x7F]|\\[\x0-\x7F])*"))*@([A-Za-z0-9]([A-Za-z0-9\-]*[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9\-]*[A-Za-z0-9])?)*|(1[0-9]{0,2}|2([0-4][0-9]?|5[0-4]?|[6-9])?|[3-9][0-9]?)(\.(0|1[0-9]{0,2}|2([0-4][0-9]?|5[0-5]?|[6-9])?|[3-9][0-9]?)){2}\.(1[0-9]{0,2}|2([0-4][0-9]?|5[0-4]?|[6-9])?|[3-9][0-9]?))$

# Integer numbers with decimals. Only positives match. This expression doesn't match numbers with group separators
# ID: 573
^([0-9]*\,?[0-9]+|[0-9]+\,?[0-9]*)?$

# Checks for the format alphanumeric\alphanumeric
# ID: 2147
^([a-zA-Z0-9])+\\{1}([a-zA-Z0-9])+$

# Filter US telephone numbers.  This particular one accepts only area code 939 or 787.  Area code parentesis or hyphens optional.
# ID: 641
^(\()?(787|939)(\)|-)?([0-9]{3})(-)?([0-9]{4}|[0-9]{4})$

# 7750 Birthday & Anniversary report
# ID: 3472
(\w+),\s+(\w+)\s+ (\((\w+)\)\s+)? (\w+),\s+(\w+)[^\d]+ (\d+)\s+(\w+)

# 7750 Birthday & Anniversary report
# ID: 3473
(\w+),[^(]+\((\w+)\)\s+(\d+)\s+(\w+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)

# 7750 Birthday & Anniversayr Report
# ID: 3474
(\w+),[^(]+\((\w+)\)\s+(\w+)\s+(\d+)/(\d+)\s+(\d+)?

# Regex to match valid folder paths.  can be local, UNC with server name, or UNC with IP address
# ID: 1104
^((([a-zA-Z]:)|(\\{2}\w+)|(\\{2}(?:(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d)(?(?=\.?\d)\.)){4}))(\\(\w[\w ]*)))

# Validates any line begining with an alpha-numeric. If you need a regular expression that fails only for a zero length string.  Remove the \w+. I originally attempted to post was ^.*$ but the input form would not allow it.
# ID: 389
^\w+.*$

# Returns the TLD from a URL.
# ID: 2338
([.])([a-z,1-9]{3,4})(\/)

# This small regular expression strips newline characters from a CSS file, except where preceded by a right-curly-bracket/brace. This enhances the 'scanability' of your CSS, saving scroll time.
# ID: 2714
(?<!})\n

# Sometimes I want to store some key value mapped data in xml or text file, and then retrieve them into hashtable in program. Authough this can be done by split the string by comma and colon, and then trim the white space, I think regular expression should be easier. Note, the key must be single word or single white space separated words, and value can be any none colon or comma charactor serial.
# ID: 2230
(?<key>[^\s]+(\s\w)*)(?=([\s]*:[\s]*))\2(?<=\2)(?<value>\b[^,:]+\b)

# This regular expression is for parsing feet and inches measurements.
# ID: 216
(\d*)'*-*(\d*)/*(\d*)"

# A combination of W. D. and JP Honeywell's U.S./Canada phone expressions, but this does allow the legal (but rare) 555 exchange number and forces an area code.
# ID: 1196
^[01]?[- .]?\(?(?!\d[1]{2})[2-9]\d{2}\)?[- .]?(?!\d[1]{2})\d{3}[- .]?\d{4}$

# IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port. More to come, maybe :)
# ID: 937
^((?:2[0-5]{2}|1\d{2}|[1-9]\d|[1-9])\.(?:(?:2[0-5]{2}|1\d{2}|[1-9]\d|\d)\.){2}(?:2[0-5]{2}|1\d{2}|[1-9]\d|\d)):(\d|[1-9]\d|[1-9]\d{2,3}|[1-5]\d{4}|6[0-4]\d{3}|654\d{2}|655[0-2]\d|6553[0-5])$

# This will validate most legal e-mail adresses with the correct syntax.
# ID: 2628
^[a-zA-Z][a-zA-Z0-9_\.\-]+@([a-zA-Z0-9-]{2,}\.)+([a-zA-Z]{2,4}|[a-zA-Z]{2}\.[a-zA-Z]{2})$

# This will validate most legal websites, including ftp.
# ID: 2629
^((http|https|ftp):\/\/(www\.)?|www\.)[a-zA-Z0-9\_\-]+\.([a-zA-Z]{2,4}|[a-zA-Z]{2}\.[a-zA-Z]{2})(\/[a-zA-Z0-9\-\._\?\&=,'\+%\$#~]*)*$

# This validates most telephone numbers in Sweden.
# ID: 2631
^(([0-9]{3})[-]?)*[0-9]{6,7}$

# match almost all kind of USPhone number
# ID: 2793
[\+]?[1]?[-. ]?(\(\d{3}\)|\d{3})(|[-. ])?\d{3}(|[-. ])\d{4}|\d{3}(|[-. ])\d{4}

# Zip code validation for Switzerland.
# ID: 2164
^[1-9][0-9][0-9][0-9]$

# This RegEx will match boolean values, either numeric or literal. It will accept MS Access "-1" values for "true",
# ID: 905
^([Vv]+(erdade(iro)?)?|[Ff]+(als[eo])?|[Tt]+(rue)?|0|[\+\-]?1)$

# Validates UK domestic landline phone numbers.
# ID: 982
(02\d\s?\d{4}\s?\d{4})|(01\d{2}\s?\d{3}\s?\d{4})|(01\d{3}\s?\d{5,6})|(01\d{4}\s?\d{4,5})

# Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.
# ID: 983
(077|078|079)\s?\d{2}\s?\d{6}

# Matches any valid e-mail... Kind of large, but worth it to those who really care............email, e-mail, e mail
# ID: 1425
/^([a-z0-9])(([\-.]|[_]+)?([a-z0-9]+))*(@)([a-z0-9])((([-]+)?([a-z0-9]+))?)*((.[a-z]{2,3})?(.[a-z]{2,6}))$/i

# Colombian identification numbers are a combination of digits, can be 8, 10 or 11 digits long, there is an identity card, which can be 6 digits separated by - and followed by 5 digits
# ID: 2556
^((\d{8})|(\d{10})|(\d{11})|(\d{6}-\d{5}))?$

# We had a need to cleanse webservice replies where the call behind the webmethod went to a legacy mainframe through a thunked middle tier. The escaped chars being in the reply broke the reply stream.  This exp when used in regex.replace within the webmethod will replace the garbage with chars of your choice.
# ID: 1211
[\x01-\x08,\x0A-\x1F,\x7F,\x81,\x8D,\x8F,\x90,\x9D]

# Checks domain names. This validates domains based on latest specifications (RFCs 952 and 1123 dealing with hostnames and RFC 1035 dealing with domain name system requirements) except that it only includes realistic fully-qualified domains: 1. requires at least one subdomain 2. allows shortest top-level domains like "ca", and "museum" as longest.
# ID: 391
^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}$

# UK Mobile phone regular expression.
# ID: 308
^07([\d]{3})[(\D\s)]?[\d]{3}[(\D\s)]?[\d]{3}$

# This regex is good for finding image tags without alt tags.  I used this for working on Section 508 compliance.  This is a M$ flavored regex and probably won't work with anything else.
# ID: 1495
\<img ((src|height|width|border)=:q:Wh*)*/\>

# Had to handle both "," and "." as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish Högskoleprov (SAT).
# ID: 1474
^([0-1](?:\.\d)|[0-1](?:\,\d)|(2\.0)|(2\,0))$

# A simple regex to check for only Visa and MasterCard with no dashes or spaces. Visa starts with a 4 and is 13 or 16 digits long, MasterCard starts with a 51 through 55 and is 16 digits long. I noticed that some of the other formulas don't account for Visa being valid with only 13 digits. I used this for a PayPal processor (which doesn't allow dashes or spaces) and modified it from others on this site. Enjoy.
# ID: 1840
^(5[1-5]\d{2})\d{12}|(4\d{3})(\d{12}|\d{9})$

# Dates
# ID: 80
^(([1-9])|(0[1-9])|(1[0-2]))\/(([0-9])|([0-2][0-9])|(3[0-1]))\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))$

# Validates subnet specified by CIDR notation. A valid CIDR notation begins with the IP address followed by a '/' character and a decimal number specifying the length, in bits, of the subnet mask or routing prefix (number from 0 to 32).
# ID: 2717
/^(([01]?\d?\d|2[0-4]\d|25[0-5])\.){3}([01]?\d?\d|2[0-4]\d|25[0-5])\/(\d{1}|[0-2]{1}\d{1}|3[0-2])$/

# This RegEx requires a US phone number WITH area code. It is written to all users to enter whatever delimiters they want or no delimiters at all (i.e. 111-222-3333, or 111.222.3333, or (111) 222-3333, or 1112223333, etc...).
# ID: 45
^\D?(\d{3})\D?\D?(\d{3})\D?(\d{4})$

# This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix (e.g. user@domain.123), simply delete the last two occurrences of "\d".
# ID: 46
^([\w\d\-\.]+)@{1}(([\w\d\-]{1,67})|([\w\d\-]+\.[\w\d\-]{1,67}))\.(([a-zA-Z\d]{2,4})(\.[a-zA-Z\d]{2})?)$

# Check italian fiscal code (codice fiscale) with "OMOCODIA" control
# ID: 643
# Multiline
^[A-Za-z]{6}[0-9LMNPQRSTUV]{2}[A-Za-z]{1}[0-9LMNPQRSTUV]{2}[A-Za-z]{1}[0-9LMNPQRSTUV]{3}[A-Za-z]{1}$

# Numbers ranging from 1 through 10
# ID: 2921
^[1-9]0?$

# I used this regex to check to make sure the file type being uploaded through an input tag was a zip file. Changing the '.zip' to another extension will change the file extension being verified.
# ID: 1471
^([a-zA-z]:((\\([-*\.*\w+\s+\d+]+)|(\w+)\\)+)(\w+.zip)|(\w+.ZIP))$

# Matches valid UK residential telephone numbers in all expected formats, including international.
# ID: 2632
^((\(44\))( )?|(\(\+44\))( )?|(\+44)( )?|(44)( )?)?((0)|(\(0\)))?( )?(((1[0-9]{3})|(7[1-9]{1}[0-9]{2})|(20)( )?[7-8]{1})( )?([0-9]{3}[ -]?[0-9]{3})|(2[0-9]{2}( )?[0-9]{3}[ -]?[0-9]{4}))$

# Jason West (jason.west@mail.state.ky.us) date validator with leap years using a strict dd/mm/yyyy  (ITALIAN) format
# ID: 226
(((0[1-9]|[12][0-9]|3[01])([-./])(0[13578]|10|12)([-./])(\d{4}))|(([0][1-9]|[12][0-9]|30)([-./])(0[469]|11)([-./])(\d{4}))|((0[1-9]|1[0-9]|2[0-8])([-./])(02)([-./])(\d{4}))|((29)(\.|-|\/)(02)([-./])([02468][048]00))|((29)([-./])(02)([-./])([13579][26]00))|((29)([-./])(02)([-./])([0-9][0-9][0][48]))|((29)([-./])(02)([-./])([0-9][0-9][2468][048]))|((29)([-./])(02)([-./])([0-9][0-9][13579][26])))

# >=0 & <100????
# ID: 2233
^[0-9]$|[1-9]+[0-9]$

# Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.
# ID: 971
^-?[0-9]{0,2}(\.[0-9]{1,2})?$|^-?(100)(\.[0]{1,2})?$

# This regular expression is used to validate any supportable email ID over the Internet.
# ID: 1869
^([\w-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([\w-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$

# I know this is very simple but this is the indian zip code and will allow only 6 digits.
# ID: 1803
/^[1-9][0-9][0-9][0-9][0-9][0-9]$/

# This is indian phone number. where it will take a format of std code 3 to 4 digits, hypen and rest of the 6 to 8 digits,
# ID: 1804
/^[0-9]\d{2,4}-\d{6,8}$/

# Regular expression that accepts positive numbers with or with decimal places, but will not allow zero or 0.000
# ID: 2137
^(([1-9]{1}(\d+)?)(\.\d+)?)|([0]\.(\d+)?([1-9]{1})(\d+)?)$

# Integer with comma and dot
# ID: 2128
^[-+]?(\d?\d?\d?,?)?(\d{3}\,?)*(\.\d{1,2})?$

# Matches any single characters that don't belong to a windows new line character sequence.
# ID: 1817
[^\r\n]|(?:\r(?!\n))|(?:(?<!\r)\n)

# Strong passwords with min 8 - max 15 character length, at least two letters (not case sensitive), one number, one special character (all, not just defined), space is not allowed.
# ID: 2799
^(?=(.*[a-zA-Z].*){2,})(?=.*\d.*)(?=.*\W.*)[a-zA-Z0-9\S]{8,15}$

# Strong passwords with min 8 - max 15 character length, at least one uppercase letter, one lowercase letter, one number, one special character (all, not just defined), space is not allowed.
# ID: 2802
^(?=.*[a-z])(?=.*[A-Z])(?=.*\d.*)(?=.*\W.*)[a-zA-Z0-9\S]{8,15}$

# This regex splits comma or semicolon separated lists of optionally quoted strings. It handles quoted delimiters and escaped quotes. Whitespace inside quotes is preserved, outside is eaten.
# ID: 1325
\s*[;,]\s*(?!(?<=(?:^|[;,])\s*"(?:[^"]|""|\\")*[;,]\s*)(?:[^"]|""|\\")*"\s*(?:[;,]|$))

# Validates Spain Phones
# ID: 657
^[0-9]{2,3}-? ?[0-9]{6,7}$

# Matches canonical Uniform Resource Names (URNs) as defined in RFC 2141.
# ID: 907
urn:[a-z0-9]{1}[a-z0-9\-]{1,31}:[a-z0-9_,:=@;!'%/#\(\)\+\-\.\$\*\?]+

# ICD9 code pattern
# ID: 274
^\d{3,3}\.\d{0,2}$|^E\d{3,3}\.\d{0,2}$

# A simplified user agent match for Apple's iDevices
# ID: 3154
/iP(?:[ao]d|hone)/

# Matches all 5 formats for Belgian cars. Only hyphens will match as separators between groups
# ID: 2913
^[A-Z]-\d{3}(?>\d|-[A-Z])$|^[A-Z]{2,3}-\d{3}$|^\d{3}-[A-Z]{3}$

# Matches all 7 side code formats for cars. Only hyphens will match as separators between groups
# ID: 2914
^(?>[A-Z]{2}|\d\d)-(?>[A-Z]{2}|\d\d)-(?<!\d\d-\d\d-)\d\d$|^(?>[A-Z]{2}|\d\d)-(?>[A-Z]{2}|\d\d)-(?<![A-Z]{2}-[A-Z]{2}-)[A-Z]{2}$|^\d\d-[A-Z]{3}-\d$

# Limits days to 31 and months to 12. Hyphen, dot and slash are valid separators and have to be consistent.
# ID: 2915
^[0-3]{1}(?(?<=3)[01]{1}|\d)([-.\/]{1})[01]{1}(?(?<=1)[0-2]{1}|\d)\1(\d{2}|\d{4})$

# Email validation intended for javascript: use of lookahead ('.' not followed by '@') instead of lookbehind ('@' not preceded by '.'). It doesn't allow ip addresses.
# ID: 3072
^(?:[^@<>;:,.()\s\[\]\\]+(?:\.(?!@))?)+@(?:[\w\-]+(?:\.(?!\.))?)+\.[A-Za-z]{2,6}$

# This validates a number between 1 and 255. Could be modified to IP, or just to verify a number in a range.
# ID: 160
^([1-9]|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])$

# Validates windows path and invalidates UNC path
# ID: 631
^([a-zA-Z]\:) (\\{1}| ((\\{1}) [^\\] ([^/:*?<>"|]*(?<![ ])))+)$

# [Default]
# ID: 663
^([a-zA-Z]\:)(\\{1}|((\\{1})[^\\/:*?<>"|]([^\\/:*?<>"|]*(?![ ])))+)$

# Switzerland phone number expression
# ID: 3305
^+41 [0-9]{2}[ ][0-9]{3}[ ][0-9]{2}[ ][0-9]{2}$

# Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - /
# ID: 932
^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$

# Validate brazilian date formats: dd/mm/yyyy or d/m/yy or d.m.yyyy
# ID: 250
^([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0]?[1-9]|[1][0-2])[./-]([0-9]{4}|[0-9]{2})$

# A regular expression which allows to find most of valid URL's and it is including some picture or packing-format prefixes at the end of an URL.
# ID: 1918
# Multiline
^((http|https|ftp|ftps)+(:\/\/))?(www\.)?(([a-z0-9\.-]{2,})\.(ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|dd|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|fk|fm|fo|fr|fx|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|aero|asia|cat|coop|edu|gov|jobs|mil|mobi|museum|tel|travel|pro|post|biz|com|info|int|name|net|org|pro|arpa)|((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])))(:([1-9][0-9]?[0-9]?[0-9]?|[1-5][0-9][0-9][0-9][0-9]|6[0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|))?(((\/(([a-zA-Z0-9_\-\%\~\+\&\;]{1,})+)*)*)|\/$)?(\.(php|html|htm|zip$|arj$|rar$|sit$|pdf$|gif$|jpg$|jpeg$|jpe$|tif$|tiff$))?(\?([a-zA-Z0-9_\-]+\=[a-z-A-Z0-9_\-\%\~\+]+)?(\&([a-zA-Z0-9_\-]+\=[a-z-A-Z0-9_\-\%\~\+]+))*)?(\=\?([a-zA-Z0-9_\-])*)?(((\+([a-zA-Z0-9_])*)?(\-([a-zA-Z0-9_])*)?)*)?(\#([a-z-A-Z0-9_\-\%\~\+\&\;]*$))?$

# matches the most of the email addresses.
# ID: 2546
[_\w-]+(?:\.[_\w-]+)*@(?:[\w-]+\.)+(?:[\w-]{2,4})(?![\w]+)

# Have you accidentally deleted school or college assignments from USB drive? Just try Free Recovery Software available on link www.datadoctor.biz that quickly gives you solution for restoration of missing data in few simple steps. DDR professional data retrieval application helps in recovering lost images or text documents saved in numerous file extensions. Highly interactive Data rescue program conveniently salvage accidentally misplaced digital snapshots or videos from pen drive or USB data storage media device
# ID: 3688
http://www.datadoctor.biz

# This is a bit strict validation format for a telephone number. It has been tested and used on live server and it works fine without any error. +91 indicates ISD code for India. Numbers inside brackets() indicates STD code and at last the is the phone number. It works with all the indian STD codes and phone numbers existing till date.
# ID: 1522
^((\+){1}[1-9]{1}[0-9]{0,1}[0-9]{0,1}(\s){1}[\(]{1}[1-9]{1}[0-9]{1,5}[\)]{1}[\s]{1})[1-9]{1}[0-9]{4,9}$

# South African
# ID: 2839
^(27|0)[0-9]{9}

# This regex find valid <h1-6> html tags
# ID: 1443
<h([1-6])>([^<]*)</h([1-6])>

# I needed to have a birthday regular expression in dutch format with full year (1900) so i wrote this one.
# ID: 1764
^([0-9]{0,2})-([0-9]{0,2})-([0-9]{0,4})$

# matches the Protocol, Domain  with port and the distinguishedName of the directory container.
# ID: 2149
(?<Protocol>\w+):\/\/(?<Domain>[\w@][\w.:\-@]+)\/(?<Container>[\w= ,@-]+)*

# Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q, ' or -.
# ID: 3028
^[^iIoOqQ'-]{10,17}$

# This expression separates a Visual Basic (VB) source code line into the code part and the comment part (if any, following an apostrophe character not enclosed in quote marks).
# ID: 371
^(?<Code>([^"']|"[^"]*")*)'(?<Comment>.*)$

# Allows for all kinds of generic international phone numbers, including that of the USA, may include () around area code as well as period, dash, space or nothing seperating numbers. International code needs to be seperated from rest by period, space or dash and my be prefixed with plus. Not overly restrictive but limits size and repetition of codes
# ID: 3009
^((\+)?[1-9]{1,2})?([-\s\.])?((\(\d{1,4}\))|\d{1,4})(([-\s\.])?[0-9]{1,12}){1,2}$

# I am publishing this regex that was written by Stephen M. Redd and taken from the following URL:  http://www.reddnet.net/regular-expression-for-validating-a-social-security-number-ssn-issued-after-june-25-2011/.  It allows a dash or space separator and accounts for the new numbers that were previously restricted prior to June 25, 2011.
# ID: 3633
^(?!000)(?!666)(?!9)\d{3}[- ]?(?!00)\d{2}[- ]?(?!0000)\d{4}$

# detect javascript function in HTML
# ID: 2609
function[\s]+[\S]+[\s]*([\s]*)[\s]*{[\s]*([\S]|[\s])*[\s]*}

# validate 12-hour time with am/pm after it, with optional spaces before or after, and optionally between time and am/pm.
# ID: 238
^ *(1[0-2]|[1-9]):[0-5][0-9] *(a|p|A|P)(m|M) *$

# Validates MS FQDNs. 1) Entire fqdn less than 255 chars. 2) Host and domain names may contain an underscore. 3) 1st char can be a number. 4) No part can be all numbers. 5) Allows any TLD Works in C#. Based on Remi Sabourin's regex.  Based on anonymous feedback I've corrected it to no longer match domains that start or end with a hyphen.
# ID: 1735
(?=^.{1,254}$)(^(?:(?!\d+\.|-)[a-zA-Z0-9_\-]{1,63}(?<!-)\.?)+(?:[a-zA-Z]{2,})$)

# This pattern was based on this reference: http://www.remote.org/jochen/mail/info/chars.html
# ID: 2119
^([a-zA-Z0-9]+([\.+_-][a-zA-Z0-9]+)*)@(([a-zA-Z0-9]+((\.|[-]{1,2})[a-zA-Z0-9]+)*)\.[a-zA-Z]{2,6})$

# it matches percentage from 1 to 100%. It ignores 0 or 0%. It only support integer matching.
# ID: 1967
^[0]*?(?<Percentage>[1-9][0-9]?|100)%?$

# File Name Validator. Validates both UNC (\\server\share\file) and regular MS path (c:\file).
# ID: 345
^(([a-zA-Z]:|\\)\\)?(((\.)|(\.\.)|([^\\/:\*\?"\|<>\. ](([^\\/:\*\?"\|<>\. ])|([^\\/:\*\?"\|<>]*[^\\/:\*\?"\|<>\. ]))?))\\)*[^\\/:\*\?"\|<>\. ](([^\\/:\*\?"\|<>\. ])|([^\\/:\*\?"\|<>]*[^\\/:\*\?"\|<>\. ]))?$

# I used this in C#.NET to check the validity of UK postcode entries.  It successfully matches all acceptable formats (with or without a space) but does not check that the actual postcode is valid due to constant changes.  Hope this helps - Jon
# ID: 2555
\A(([a-zA-Z]{1,2}\d{1,2})|([a-zA-Z]{2}\d[a-zA-Z]{1}))\x20{0,1}\d[a-zA-Z]{2}\Z

# matches australian phone numbers
# ID: 3549
(^13((\ )?\d){4}$)|(^1[38]00((\ )?\d){6}$)|(^(((\(0[23478]\))|(0[23478]))(\ )?)?\d((\ )?\d){7}$)

# This checks for the specific syntax ((A,((b,c,d),(e,f,g))), ..).  No limit on number of occurances.
# ID: 142
(^\(\)$|^\(((\([0-9]+,(\((\([0-9]+,[0-9]+,[0-9]+\),)*(\([0-9]+,[0-9]+,[0-9]+\)){1}\))+\),)*(\([0-9]+,(\((\([0-9]+,[0-9]+,[0-9]+\),)*(\([0-9]+,[0-9]+,[0-9]+\)){1}\))+\)){1}\)))$

# Postalcode Danmark
# ID: 517
^[D-d][K-k]-[1-9]{1}[0-9]{3}$

# match all danish postal code
# ID: 518
^[D-d][K-k]( |-)[1-9]{1}[0-9]{3}$

# Swedish postcodes (as far as i know)
# ID: 519
^[S-s]( |-)?[1-9]{1}[0-9]{2}( |-)?[0-9]{2}$

# Pattern must match 8-12 character, numeric, and symbol combination 1) at least one uppercase letter, 2) at least on lowercase letter, 3) at least one number, 4) and one special charater, that is specified in advanced.  The first character must be a character upper or lower, and no spaces allowed.
# ID: 1396
^(?=[a-zA-Z])(?=.*[0-9])(?=.*[#\$_])(?=.*[A-Z])(?=.*[a-z])(?!.*[^a-zA-Z0-9#\$_])(?!.*\s).{8,12}$

# Validates major credit card expiration dates in MM/YY, MM.YY, MM-YY, or MMYY. Year range is 08-19.
# ID: 2306
^((0[1-9])|(1[0-2]))[\/\.\-]*((0[8-9])|(1[1-9]))$

# used to match standard province codes in upper case.
# ID: 1246
^(^N[BLSTU]$)|(^[AMN]B$)|(^[BQ]C$)|(^ON$)|(^PE$)|(^SK$)$

# Tests that a password contains between 6 and 12 characters, and contains at least one number.
# ID: 2436
^(?=.*\d)(?=.*[a-zA-Z])(?!.*\s).{6,12}$

# Tests that a screen name begins and ends with an alphanumeric, and otherwise use alphanumeric characters, hyphens, and underscores.  Dictates length between 6 and 20 characters
# ID: 2437
^([\w][\w\-_\u0020]{4,18}[\w])$

# Classic gender descriptor regex.
# ID: 2441
^(?:m|M|male|Male|f|F|female|Female)$

# Checks the format of a North American phone number with area code.
# ID: 2442
^\(\d{3}\)\s?|\d{3}(\.|-|\s)?)\d{3}(\.|-|\s)?\d{4}$

# Useful for determining whether a string constitutes a valid local or UNC path.
# ID: 2396
^[a-zA-Z]\:\\.*|^\\\\.*

# Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W) ,degrees,minutes,seconds.
# ID: 1102
^[NS]([0-8][0-9](\.[0-5]\d){2}|90(\.00){2})\040[EW]((0\d\d|1[0-7]\d)(\.[0-5]\d){2}|180(\.00){2})$

# Password matching expression. Password must be at least 8 characters, no more than 15 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.
# ID: 598
^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,15}$

# A regex that attempts to accurately parse the elements from a proper name where the format is in <<First, Last>> order or some permutation of that order.  Critiques and suggestions for improvement are welcome.
# ID: 426
(?<FirstName>[A-Z]\.?\w*\-?[A-Z]?\w*)\s?(?<MiddleName>[A-Z]\w*|[A-Z]?\.?)\s?(?<LastName>[A-Z]\w*\-?[A-Z]?\w*)(?:,\s|)(?<Suffix>Jr\.|Sr\.|IV|III|II|)

# Fine-tuned the previous version to handle surnames with embedded caps like McCoy and DeCarlo.
# ID: 427
(?<FirstName>[A-Z]\.?\w*\-?[A-Z]?\w*)\s?(?<MiddleName>[A-Z]\w+|[A-Z]?\.?)\s(?<LastName>[A-Z]?\w{0,3}[A-Z]\w+\-?[A-Z]?\w*)(?:,\s|)(?<Suffix>Jr\.|Sr\.|IV|III|II|)

# Getting closer now...  this one has the functionality of the previous two and matches on names like "Jill St. John" as well.
# ID: 428
(?<FirstName>[A-Z]\.?\w*\-?[A-Z]?\w*)\s?(?<MiddleName>[A-Z]\w+|[A-Z]?\.?)\s(?<LastName>(?:[A-Z]\w{1,3}|St\.\s)?[A-Z]\w+\-?[A-Z]?\w*)(?:,\s|)(?<Suffix>Jr\.|Sr\.|IV|III|II|)

# Regex parses elements from a proper name in <<Last, First>> order and permutations.  Comments and critiques are welcome.
# ID: 429
(?<LastName>[A-Z]\w+\-?[A-Z]?\w*),\s(?<Suffix>Jr\.|Sr\.|IV|III|II)?,?\s?(?<FirstName>[A-Z]\w*\-?[A-Z]?\w*\.?)\s?(?<MiddleName>[A-Z]?\w*\.?)

# This regular expression will remove all invalid chars from a string
# ID: 3189
^[^<>`~!/@\#},.?"-$%:;)(_ ^{&*=|'+]+$

# This will match any positive integer less than or equals to 10
# ID: 1829
^\d$|^[1][0]$

# Pattern to match European VAT codes based on the formats described at http://www.hmrc.gov.uk/vat/managing/international/esl/country-codes.htm. The pattern is written long-hand and does not follow the character rules to the letter, but in the absence of a true VAT code checking service (the only accurate way to do this) it is pretty good.
# ID: 3138
^(AT ?U[0-9]{7}|BE ?[0-9]{10}|BG ?[0-9]{9,10}|CY ?[0-9]{8}[A-Z]{1}|CZ ?[0-9]{8,10}|DE ?[0-9]{9}|DK ?[0-9]{8}|EE ?[0-9]{9}|EL ?[0-9]{9}|ES ?[0-9A-Z]{9}|FI ?[0-9]{8}|FR ?[0-9A-Z]{11}|HU ?[0-9]{8}|IE ?[0-9A-Z]{8}|IT ?[0-9]{11}|LT ?([0-9]{9}|[0-9]{12})|LU ?[0-9]{8}|LV ?[0-9]{11}|MT ?[0-9]{8}|NL ?[0-9B]{12}|PL ?[0-9]{10}|PT ?[0-9]{9}|RO ?[0-9]{2,10}|SE ?[0-9]{12}|SI ?[0-9]{8}|SK ?[0-9]{10})$

# Based on a regular expression from Michael Ash, this captures US street addresses and mailing addresses, single or multi-line (multi-line is more reliable), and breaks them into discrete parts for address line 1 and 2, city, state, and postal code.  This expression is not perfect - with the interpreter I am using, some addresses refuse to match correctly.  It should however work for most addresses, particularly when lines are delimited with carriage returns, tabs, or some other whitespace line delimiter that is not a space (\x20).  Note: For improved compatibility, this expression does not use named groups.
# ID: 986
^\s*((?:(?:\d+(?:\x20+\w+\.?)+(?:(?:\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\.?)?)|(?:(?:P\.\x20?O\.|P\x20?O)\x20*Box\x20+\d+)|(?:General\x20+Delivery)|(?:C[\\\/]O\x20+(?:\w+\x20*)+))\,?\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\x23)\.?\x20*(?:[a-zA-Z0-9\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)\,?\s+((?:(?:\d+(?:\x20+\w+\.?)+(?:(?:\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\.?)?)|(?:(?:P\.\x20?O\.|P\x20?O)\x20*Box\x20+\d+)|(?:General\x20+Delivery)|(?:C[\\\/]O\x20+(?:\w+\x20*)+))\,?\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\x23)\.?\x20*(?:[a-zA-Z0-9\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)?\,?\s+((?:[A-Za-z]+\x20*)+)\,\s+(A[LKSZRAP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])\s+(\d+(?:-\d+)?)\s*$

# Matches either an explicitly input percentage or dollar amount, variety of formats of currency borrowed from another example on this board. This is useful when you want to prompt the user to specify either dollars or percent using only one field, and want to validate the entered text is one or the other.
# ID: 579
(^\$(\d{1,3},?(\d{3},?)*\d{3}(\.\d{1,3})?|\d{1,3}(\.\d{2})?)$|^\d{1,2}(\.\d{1,2})? *%$|^100%$)

# Matches positive whole numbers with exactly zero or two decimal points if a . is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.
# ID: 543
^\d+(?:\.\d{0,2})?$

# Based on Morten Henriksen's expression, I just added the check for a . as well as a :
# ID: 2333
^([0-1]?[0-9]|[2][0-3])[:|.]([0-5][0-9])$

# This simple expression is used to validate fractions or UK odds.
# ID: 2232
^\d+\/?\d*$

# Expression to validate currency formatted numbers without the currency symbol
# ID: 2296
^(\d?)*(\.\d{1}|\.\d{2})?$

# This expression stops the characters <>/?&{};# from a string of any length passing the regular expression validator in Visual Studio thereby stopping the HttpRequestValidationException (if client side validation and javascript is on)
# ID: 2126
[^<>/?&{};#]+

# This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters.
# ID: 3227
^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$

# This pattern allow a first and last name to be tested to ensure that each name begins with a capital letter and is separated by just one space.  The pattern also ensures that only one hyphen can be placed in either the first or last name and the succeeding character must be capitalized.  If an apostrophe is used in the last name it too must be succeeded by a capital letter.
# ID: 3505
^(?-i:[A-Z]{1}[a-z]+(?<fnh>[-]{1})?(?(fnh)[A-Z]{1}[a-z]+)\s[A-Z]{1}(?<apos>[']{1})?(?(apos)[A-Z]{1})[a-z]+(?<lnh>[-]{1})?(?(lnh)[A-Z]{1}[a-z]+))$

# This pattern matches is for validating Names, Cities, States, Countries etc that require only alphabet inputs with white spaces. It requires atleast 2 characters & there's no limit on maximum number of characters.
# ID: 910
^([a-zA-z\s]{2,})$

# This is the simplest RegEx for validating someone's name. The name can contain only alphabets(in either case) & should be of minimum length 4 & maximum length 32. Only white spaces are allowed apart from alphabets.
# ID: 904
^([a-zA-z\s]{4,32})$

# This regex matches fully qualified external urls (http, https, or ftp).  It uses the ms specific group-naming structure to present friendly named groups back to the user.
# ID: 1577
(?<protocol>http(s)?|ftp)://(?<server>([A-Za-z0-9-]+\.)*(?<basedomain>[A-Za-z0-9-]+\.[A-Za-z0-9]+))+((/?)(?<path>(?<dir>[A-Za-z0-9\._\-]+)(/){0,1}[A-Za-z0-9.-/]*)){0,1}

# This is a standard perl-compatible regexp for ip4 address validation
# ID: 2942
^(([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])\.){3}([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])$

# This pattern matches link tags in html and returns the contents of the href attribute and the text of the link.
# ID: 1592
^<a[^>]*(http://[^"]*)[^>]*>([ 0-9a-zA-Z]+)</a>$

# Matches common ASCII names without special characters.
# ID: 1887
^[^\x00-\x1f\x21-\x26\x28-\x2d\x2f-\x40\x5b-\x60\x7b-\xff]+$

# Expressão Regular para validação de números decimais.
# ID: 2797
^(\d{1,})$|^(\d{1,}\.)$|^(\d{0,}?\.\d{1,})$|^([+-]\d{1,}(\.)?)$|^([+-](\d{1,})?\.\d{1,})$

# This just a minor mod to Steven Smith's credit card re to accept spaces as separators, as well as return the four parts of the card.  [Updated Oct-18-2002 to work with Diners Club/Carte Blanche (prefix must be 36, 38, or 300-305)]
# ID: 100
^((?:4\d{3})|(?:5[1-5]\d{2})|(?:6011)|(?:3[68]\d{2})|(?:30[012345]\d))[ -]?(\d{4})[ -]?(\d{4})[ -]?(\d{4}|3[4,7]\d{13})$

# For currency: strips out leading non-numeric characters. Numbers may use a comma for the decimal place, but cannot use anything for the thousands separator.
# ID: 1455
([^,0-9]\D*)([0-9]*|\d*\,\d*)$

# Allows any integer, signed (+/-) or not, with or without commas, or zero (0), or blank.
# ID: 1638
(^\-|\+)?([1-9]{1}[0-9]{0,2}(\,\d{3})*|[1-9]{1}\d{0,})$|^0?$

# European short hours
# ID: 3368
^((([0-9]|([0-1][0-9])|(2[0-3]))[hH:][0-5][0-9])|(([0-9]|(1[0-9])|(2[0-3]))[hH]))$

# Password matching expression. Match all alphanumeric character and predefined wild characters. Password must consists of at least 8 characters and not more than 15 characters.
# ID: 213
^([a-zA-Z0-9@*#]{8,15})$

# This regular expression allows to verify mobile phone numbers (600) and telephone numbers (900). Not provide premium charging phones (line 800). The number may be separated by spaces in groups of three digits, or  one group of three number plus two groups of three numbers for fixed phones.
# ID: 3129
(([+]?34) ?)?(6(([0-9]{8})|([0-9]{2} [0-9]{6})|([0-9]{2} [0-9]{3} [0-9]{3}))|9(([0-9]{8})|([0-9]{2} [0-9]{6})|([1-9] [0-9]{7})|([0-9]{2} [0-9]{3} [0-9]{3})|([0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2})))

# Allows to check a identity card (DNI) with a valid verification letter. Not all letters of the alphabet are valid
# ID: 3130
(0?[1-9]|[1-9][0-9])[0-9]{6}(-| )?[trwagmyfpdxbnjzsqvhlcke]

# This regex will extract the link and the link title for every a href in HTML source. Useful for crawling sites.
# ID: 968
<a[\s]+[^>]*?href[\s]?=[\s\"\']+(.*?)[\"\']+.*?>([^<]+|.*?)?<\/a>

# simple email validation
# ID: 1775
^.+\@.+\..+$

# url validation with tiped errors
# ID: 1776
(((ht|f)tp(s?):\/\/)|(([\w]{1,})\.[^ \[\]\(\)\n\r\t]+)|(([012]?[0-9]{1,2}\.){3}[012]?[0-9]{1,2})\/)([^ \[\]\(\),;"'<>\n\r\t]+)([^\. \[\]\(\),;"'<>\n\r\t])|(([012]?[0-9]{1,2}\.){3}[012]?[0-9]{1,2})

# asas
# ID: 2270
^(NAME)(\s?)<?(\w*)(\s*)([0-9]*)>?$

# Good For Validating Phone numbers that are 0 to 9 in length
# ID: 1123
(^[0-9]{0,10}$)

# it will match a valid date & time string which looks like this : 2006-12-31 23:59:59
# ID: 1407
^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-2]) ([0-1][0-9]|2[0-4]):([0-4][0-9]|5[0-9]):([0-4][0-9]|5[0-9])$

# ISIN must be located inside a html tag eg. <td>JP3756600007</td>. Just remove the (..) at the beginning and the end if you wish to match all ISINs.
# ID: 1583
(?<=>)[A-Z]{2}[\d|\w]{9}\d{1}(?=(<))

# Will match an image with the most common attributes.
# ID: 3128
<img\s((width|height|alt|align|style)="[^"]*"\s)*src="(\/?[a-z0-9_-]\/?)+\.(png|jpg|jpeg|gif)"(\s(width|height|alt|align|style)="[^"]*")*\s*\/>

# [Default]
# ID: 955
(\d{6}[-\s]?\d{12})|(\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4})

# This is a combination of a few regular expressions found on this site.  It allows for a flexible date and time combination, but requires a 12-hour clock (am/pm).  Many versions of the am/pm are supported.
# ID: 233
^([0]\d|[1][0-2])\/([0-2]\d|[3][0-1])\/([2][01]|[1][6-9])\d{2}(\s([0]\d|[1][0-2])(\:[0-5]\d){1,2})*\s*([aApP][mM]{0,2})?$

# matches dates in the format day/month/year.
# ID: 2307
^(((((0?[1-9]|[12]\d|3[01])[-/]([0]?[13578]|1[02]))|((0?[1-9]|[12]\d|30)[-/]([0]?[469]|11))|(([01]?\d|2[0-8])[-/]0?2))[-/]((20|19)?\d{2}|\d{1,2}))|(29[-/]0?2[-/]((19)|(20))?([13579][26]|[24680][048])))$

# will match anything EXCEPT  what you replace "dont match me" with.
# ID: 2438
(?s)(?i)^(?!^.*(dont match me).*$).*$

# This expression can be used validate a datetime column from SQL Server. Big parts of it where taken from other samples on RegexLib. Please feel free to take it apart and improve it.
# ID: 110
^((((([13578])|(1[0-2]))[\-\/\s]?(([1-9])|([1-2][0-9])|(3[01])))|((([469])|(11))[\-\/\s]?(([1-9])|([1-2][0-9])|(30)))|(2[\-\/\s]?(([1-9])|([1-2][0-9]))))[\-\/\s]?\d{4})(\s((([1-9])|(1[02]))\:([0-5][0-9])((\s)|(\:([0-5][0-9])\s))([AM|PM|am|pm]{2,2})))?$

# [Default]
# ID: 454
^[a-z]+[0-9]*[a-z]+$

# This pattern validates email address. it allows (1)numeric characters and underscore(_) in an address.(2)numeric characters in domain name. it doesn't match user names with a dot(.). doesn;t allow username starting or ending with @ underscore.
# ID: 1839
([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$

# This regular expression accepts SEDOL (Stock Exchange Daily Official List number, a code used by the London Stock Exchange to identify foreign stocks).
# ID: 1044
(?<Sedol>[B-Db-dF-Hf-hJ-Nj-nP-Tp-tV-Xv-xYyZz\d]{6}\d)

# This simple reg-ex accepts any vowel letter.
# ID: 1046
[AaEeIiOoUuYy]

# Regular expression to fetch <key-value> pairs from the old-fashioned .ini files. Key and Value appears in form of named captures with whitespaces stripped on both ends.
# ID: 1269
# Multiline
((\s)*(?<Key>([^\=^\s^\n]+))[\s^\n]*\=(\s)*(?<Value>([^\n^\s]+(\n){0,1})))

# Croatian phone numbers (old style). Area code and phone number, area code optional. Area code in $2 (if specified) phone number is in $4 or $5+$6+$7 or $8+$9.
# ID: 1913
^((\d{2,4})/)?((\d{6,8})|(\d{2})-(\d{2})-(\d{2,4})|(\d{3,4})-(\d{3,4}))$

# This pattern can be used to match EU style dates of formad d.m.yyyy where d and m can be two digits d <= 31 and m <= 12
# ID: 1914
^(([1..9])|(0[1..9])|(1\d)|(2\d)|(3[0..1])).((\d)|(0\d)|(1[0..2])).(\d{4})$

# It matches % value from 0 - 100. The two decimal places are used.
# ID: 1386
^100$|^\d{0,2}(\.\d{1,2})? *%?$

# Finds single characters strings in a comma separated string. For example:
# ID: 2227
(?<=(\A|,))(?<val>(\w|\W){1})(?=(,|\Z))

# grab all tags attributes...
# ID: 464
<([^\s>]*)(\s[^<]*)>

# All tags in first submatche
# ID: 465
<([^<>\s]*)(\s[^<>]*)?>

# Used to match windows filenames.  Fails if there is leading or trailing spaces. Fails if the input contains /\:*?"<>| . Fails if the input begins or ends with '.'
# ID: 1029
# Multiline
\A([A-Za-z0-9'~`!@#$%&^_+=\(\){},\-\[\]\;])+?([ A-Za-z0-9'~`!@#$%&^_+=\(\){},\-\[\];]|([.]))*?(?(3)(([ A-Za-z0-9'~`!@#$%&^_+=\(\){},\-\[\]\;]*?)([A-Za-z0-9'~`!@#$%&^_+=\(\){},\-\[\];])+\z)|(\z))

# PCRE (PHP) regular expression for validating US telephone numbers with OPTIONAL area code, and OPTIONAL extension. Promiscuous formatting (parenthesis or slash, space, dash, dot or no separator). Captures the telephone number area code, prefix, suffix, and extension to named groups. Rejects area codes that begin with 0 or 1 and prefixes that begin with 0. Rejects all telephone numbers that do not match on exactly 7 digits, or on exactly 10 digits with the optional area code, not counting the extension or the format. Seperators, when used, must be in the right place. Extension can be preceded by a space(s) and/or "x", "X", or "Ext" and matches on 1 to 5 digits.
# ID: 629
# Multiline
^(?:(?<1>[(])?(?<AreaCode>[2-9]\d{2})(?(1)[)][ ]?|[- \/.]?))?(?<Prefix>[1-9]\d{2})[- .]?(?<Suffix>\d{4})(?:(?:[ ]+|[xX]|Ext\.?[ ]?){1,2}(?<Ext>\d{1,5}))?$

# Validates UK postcodes  and aligns in parenthesized subpatterns according to standard UK postcode elements. Validation is according to guidelines outlined at http://www.govtalk.gov.uk/gdsc/html/noframes/PostCode-2-1-Release.htm
# ID: 695
^((([A-PR-UWYZ])([0-9][0-9A-HJKS-UW]?))|(([A-PR-UWYZ][A-HK-Y])([0-9][0-9ABEHMNPRV-Y]?))\s{0,2}(([0-9])([ABD-HJLNP-UW-Z])([ABD-HJLNP-UW-Z])))|(((GI)(R))\s{0,2}((0)(A)(A)))$

# Username start only with alphabet, and then can combine with any digit, space, and underscore. Reject other special character and space in the begin and the end of characters.
# ID: 3190
^[a-zA-Z]{1}[\w\sa-zA-Z\d_]*[^\s]$

# This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point.
# ID: 173
(?!^0*$)(?!^0*\.0*$)^\d{1,5}(\.\d{1,3})?$

# This regex will remove all markup tag except <p></p> and line break tag.
# ID: 3486
<[^/bp][^><]*>|<p[a-z][^><]*>|<b[^r][^><]*>|<br[a-z][^><]*>|</[^bp]+>|</p[a-z]+>|</b[^r]+>|</br[a-z]+>

# This Validator Validates any date from 1800 - 9999. It takes special care of Leap years and validates any format of type mm/dd/yyyy , m/dd/yyyy , mm/d/yyyy , m/d/yyyy.
# ID: 279
((^(10|12|0?[13578])([/])(3[01]|[12][0-9]|0?[1-9])([/])((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(11|0?[469])([/])(30|[12][0-9]|0?[1-9])([/])((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(0?2)([/])(2[0-8]|1[0-9]|0?[1-9])([/])((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(0?2)([/])(29)([/])([2468][048]00)$)|(^(0?2)([/])(29)([/])([3579][26]00)$)|(^(0?2)([/])(29)([/])([1][89][0][48])$)|(^(0?2)([/])(29)([/])([2-9][0-9][0][48])$)|(^(0?2)([/])(29)([/])([1][89][2468][048])$)|(^(0?2)([/])(29)([/])([2-9][0-9][2468][048])$)|(^(0?2)([/])(29)([/])([1][89][13579][26])$)|(^(0?2)([/])(29)([/])([2-9][0-9][13579][26])$))

# Matches any integer, float or currency.
# ID: 3031
(\d+)([,|.\d])*\d

# It is used for simple validation. This regular expression will match the all type of credit card patterns, like AMEX,VISA,MASTER, Dinnerclub, JCB, enRoute ,Discover
# ID: 1835
^[3|4|5|6]([0-9]{15}$|[0-9]{12}$|[0-9]{13}$|[0-9]{14}$)

# [Default]
# ID: 940
^[A-Za-z0-9](([_\.\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\.\-]?[a-zA-Z0-9]+)*)\.([A-Za-z]{2,})$

# another uk telephone number regex.  This was adapted from another on this site http://www.regexlib.com/REDetails.aspx?regexp_id=297
# ID: 683
(\s*\(?0\d{4}\)?(\s*|-)\d{3}(\s*|-)\d{3}\s*)|(\s*\(?0\d{3}\)?(\s*|-)\d{3}(\s*|-)\d{4}\s*)|(\s*(7|8)(\d{7}|\d{3}(\-|\s{1})\d{4})\s*)

# Validates and extracts URI components.
# ID: 1731
^((http|https|ftp):\/\/)?((.*?):(.*?)@)?([a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])((\.[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])*)(:([0-9]{1,5}))?((\/.*?)(\?(.*?))?(\#(.*))?)?$

# ID: 1906
# Multiline
^(([A-Z]{1,2}[ ]?[0-9]{1,4})|([A-Z]{3}[ ]?[0-9]{1,3})|([0-9]{1,3}[ ]?[A-Z]{3})|([0-9]{1,4}[ ]?[A-Z]{1,2})|([A-Z]{3}[ ]?[0-9]{1,3}[ ]?[A-Z])|([A-Z][ ]?[0-9]{1,3}[ ]?[A-Z]{3})|([A-Z]{2}[ ]?[0-9]{2}[ ]?[A-Z]{3})|([A-Z]{3}[ ]?[0-9]{4}))$

# Pattern for Indian Postal Code.
# ID: 1114
^[1-9]{3}\s{0,1}[0-9]{3}$

# This regex performs a crude test on the given input string.
# ID: 1534
^[0-3][0-9][0-1]\d{3}-\d{4}?

# Incorporated other people's examples; removed extraneous parenthesis on 10/7/04.  Currently the SSA site says 772 is the highest AREA number generated (http://www.ssa.gov/employer/highgroup.txt).  Old expression was:  (^|\s)\d{3}(-?|[\. ])\d{2}\2\d{4}($|\s|[;:,!\.\?]).  Looks for either the beginning of a line or whitespace before the beginning of the social security number, then either zero or one hyphen OR one of a period or space, then uses the \3 to reference the value returned in the parenthesis that includes the -?|[\. ] (basically says if the first dash, period, or space is there, then the second one is required; and if the first dash, period, or space is not there, then the second one can't be either), and finally looks for the end of a line, whitespace, or punctuation characters after the social security number.
# ID: 266
(^|\s)(00[1-9]|0[1-9]0|0[1-9][1-9]|[1-6]\d{2}|7[0-6]\d|77[0-2])(-?|[\. ])([1-9]0|0[1-9]|[1-9][1-9])\3(\d{3}[1-9]|[1-9]\d{3}|\d[1-9]\d{2}|\d{2}[1-9]\d)($|\s|[;:,!\.\?])

# Matches a complete ini-file section
# ID: 2406
\[\w+\]\s+((.*=.*\s+)*|[^\[])

# Using other regular experssions from this page, combining others for email addresses, and mixing in my own ideas - I came up with this regular expression.  Can be used to validate input into a database.
# ID: 161
^((https?|ftp)\://((\[?(\d{1,3}\.){3}\d{1,3}\]?)|(([-a-zA-Z0-9]+\.)+[a-zA-Z]{2,4}))(\:\d+)?(/[-a-zA-Z0-9._?,'+&%$#=~\\]+)*/?)$

# [Default]
# ID: 240
[^abc]

# Matches any positive decimal number > 0 with optional leading '+' symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional.
# ID: 3230
^[+]?((\d*[1-9]+\d*\.?\d*)|(\d*\.\d*[1-9]+\d*))$

# Javascript matches US zipcodes not allowing all zeros in first 5 or +4
# ID: 920
(^(?!0{5})(\d{5})(?!-?0{4})(-?\d{4})?$)

# This expression for validate
# ID: 3266
^(\[a-zA-Z '\]+)$

# suppose you have a exe/command take options like "a b c" or "b c a", the sequence doesn't matter, but on option should only appear at most once.
# ID: 3202
\s*((a|b|c)\s+(?!.*\2.*))*(a|b|c)\s*

# Matches US phone numbers in just about any format which doesn't try to break the 3-3-4 number set. Captures anything after the 4 digit set, such as an extension, for use later. 3 digit area code (ignoring a leading 1), 3 digit prefix, 4 digit line number and any additional extension info are all separated in to different groups for easy formatting. This expression is designed for a replacement, where the replacement string is ($1)$2-$3$4
# ID: 1825
^[ 1(]{0,3}?([02-9][0-9]{2})\D{0,2}([0-9]{3})\D?([0-9]{4})($|\D+.+$)

# Telephone number validation. Validates a telephone number which contains either 0-9,(,),+,- and space. Let me know if it works for you. :)
# ID: 1203
^[0-9\s\(\)\+\-]+$

# This is an extension of already existing expression submitted. It checks for characters, hyphen and single quotes. Single quote and hyphen cannot appear at the beginning or at the end.
# ID: 1168
^[a-zA-Z]+((\s|\-|\')[a-zA-Z]+)?$

# Accepts valid US Postal Code - either 5 digit, or extended
# ID: 1109
^(([0-9]{5})*-([0-9]{4}))|([0-9]{5})$

# This expression validates dates in the mm/dd/yyyy format and ya..expression will take care of the leap year dates
# ID: 1937
^(?:(?:(?:0?[13578]|1[02])(\/|-)31)|(?:(?:0?[1,3-9]|1[0-2])(\/|-)(?:29|30)))(\/|-)(?:[1-9]\d\d\d|\d[1-9]\d\d|\d\d[1-9]\d|\d\d\d[1-9])$|^(?:(?:0?[1-9]|1[0-2])(\/|-)(?:0?[1-9]|1\d|2[0-8]))(\/|-)(?:[1-9]\d\d\d|\d[1-9]\d\d|\d\d[1-9]\d|\d\d\d[1-9])$|^(0?2(\/|-)29)(\/|-)(?:(?:0[48]00|[13579][26]00|[2468][048]00)|(?:\d\d)?(?:0[48]|[2468][048]|[13579][26]))$

# This is a basic/simple  expression i have come out to check 10digit mobile number and then any valid email ....
# ID: 1938
\d{10,12}@[a-zA-Z].[a-zA-Z].*

# This Expression that accept combination of Alphanumeric.
# ID: 3431
^[a-zA-Z]{4}\d{7}$

# Matches Canadian style postal codes
# ID: 3328
^[a-zA-Z]{1}[0-9]{1}[a-zA-Z]{1}[- ]{0,1}[0-9]{1}[a-zA-Z]{1}[0-9]{1}

# Very useful if you want to use ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use "($1) $2-$3$4" to get Number in form: "(234) 567-8901".
# ID: 2880
^\D{0,2}[0]{0,3}[1]{0,1}\D{0,2}([2-9])(\d{2})\D{0,2}(\d{3})\D{0,2}(\d{3})\D{0,2}(\d{1})\D{0,2}$

# A very short pattern for extracting hrefs from HTML, does not validate they are within a tag
# ID: 774
href[\s]*=[\s]*"[^\n"]*"

# Use with "/i" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts.  Group $2 will contain the table name, $4 the field list, and $6 the value list.
# ID: 1749
(INSERT INTO\s+)(\w+)(\s+\()([\w+,?\s*]+)(\)\s+VALUES\s+\()(['?\w+'?,?\s*]+)(\))

# Use with "/i" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the all of the value lists.
# ID: 1750
(INSERT INTO\s+)(\w+)(\s+\()([\w+,?\s*]+)(\)\s+VALUES\s+)((\(['?\w+'?,?\s*]+\)\,?;?\s*)+)

# Use with "/i" flag (case-insensitive) to match any valid SQL UPDATE statement, and to parse it into it's component parts.  Most useful will be group $2, the table name, group $4, the field=value list, and group $5, the WHERE clause.
# ID: 1742
(UPDATE\s+)(\w+)\s+(SET)\s+([\w+\s*=\s*\w+,?\s*]+)\s+(WHERE.+)

# Best Use validation to accept a valid "MonthName(,) Year".
# ID: 514
^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\,*\s\s*\d{4}$|^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\,*\s\d{4}$|^(January|February|March|April|May|June|July|August|September|October|November|December)\,*\s\d{4}$|^(january|february|march|april|may|june|july|august|september|october|november|december)\,*\s\d{4}$

# This pattern matches an image url attribute of an img html tag.  It searches for the src attribute and grabs the value as a grouped match - "imgSrc".
# ID: 1437
src=(?:\"|\')?(?<imgSrc>[^>]*[^/].(?:jpg|bmp|gif|png))(?:\"|\')?

# This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year.
# ID: 197
^(((((0[1-9])|(1\d)|(2[0-8]))-((0[1-9])|(1[0-2])))|((31-((0[13578])|(1[02])))|((29|30)-((0[1,3-9])|(1[0-2])))))-((20[0-9][0-9]))|(29-02-20(([02468][048])|([13579][26]))))$

# Matches full and compressed IPv6 addresses as defined in RFC 2373 (http://www.faqs.org/rfcs/rfc2373.html). No useful captures.
# ID: 1000
^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$

# Will match a Windows filename containing alphanumerics, hyphens (-) and underscores (_). There is no length limit on the first part of the filename, but the extension must be between 1 and 3 characters.
# ID: 1934
([0-9a-z_-]+[\.][0-9a-z_-]{1,3})$

# Matches whole numbers only, including comma separated. Does not allow leading zeros. To match comma separated numbers only, change "\d{0,}" to "\d{0,2}". To match 0, add "|([0])" before ")$". If you want to use it with Java's regexp match(), remove "^(" and ")$" since they are not needed.
# ID: 1541
^(([1-9]{1}\d{0,2},(\d{3},)*\d{3})|([1-9]{1}\d{0,}))$

# If it is more then 7 numbers then it will not detect.
# ID: 3163
^[A-Za-z]{1}[0-9]{7}$

# Matches a South African landline or cellphone number. Can use dashes or spaces. Can be prefexed with +27 or 27 or 0. With support for extensions.
# ID: 3225
^(\+27|27|0)[0-9]{2}( |-)?[0-9]{3}( |-)?[0-9]{4}( |-)?(x[0-9]+)?(ext[0-9]+)?

# This regular expression will match date given in any format expcept (mmm). Its speciality is that it divides dates into <from> part and <to> part. Use Groups to access these parts.
# ID: 481
^(?<From>(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER|[ ]|,|/|[0-9])+)(-|–|:|TO)?(?<To>(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER|[ ]|,|/|[0-9]|PRESENT)+)+(:)*

# Its extracts telephone numbers
# ID: 482
(?<Telephone>([0-9]|[ ]|[-]|[\(]|[\)]|ext.|[,])+)([ ]|[:]|\t|[-])*(?<Where>Home|Office|Work|Away|Fax|FAX|Phone)|(?<Where>Home|Office|Work|Away|Fax|FAX|Phone|Daytime|Evening)([ ]|[:]|\t|[-])*(?<Telephone>([0-9]|[ ]|[-]|[\(]|[\)]|ext.|[,])+)|(?<Telephone>([(]([0-9]){3}[)]([ ])?([0-9]){3}([ ]|-)([0-9]){4}))

# This is HTTP Url extractor
# ID: 483
(?<http>(http:[/][/]|www.)([a-z]|[A-Z]|[0-9]|[/.]|[~])*)

# E-mail addresses matcher
# ID: 484
(?<email>(?![ ])(\w|[.])*@(\w|[.])*)

# [\s0-9a-zA-Z\;\"\,]* match any text just add character or symbol to be matched  inside[ ] like [\<] for  (<) symbol. if u want find between two word then just use  Eg : <div>[\s0-9a-zA-Z\;\"\,]* </div> it will return the  content between <div> tags. Just add all  format  to match all .It is better than (.*) because (.*) is difficult to end at particular part  as we needed.
# ID: 1866
[\s0-9a-zA-Z\;\"\,\<\>\\?\+\=\)\(\\*\&\%\\$\#\.]*

# Pattern test for general validity of a Url.  It is a little stricter than many others here, as I found they often passed obviously invalid strings like 'http://foo', but is still fairly concise.
# ID: 3171
^((f|ht)tp(s)?)\://([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.[a-zA-Z]{2,6}((/|\?)[a-zA-Z0-9\.\?=/#%&\+-]+|/|)$

# Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the .Net framework, to ensure that the string can be parsed without throwing an exception.  The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.
# ID: 2081
^\s*-?(\d{0,7}|10[0-5]\d{0,5}|106[0-6]\d{0,4}|1067[0-4]\d{0,3}|10675[0-1]\d{0,2}|((\d{0,7}|10[0-5]\d{0,5}|106[0-6]\d{0,4}|1067[0-4]\d{0,3}|10675[0-1]\d{0,2})\.)?([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9](\.\d{1,7})?)?)\s*$

# Matches any VBScript method declaration (= no "As [datatype]" support), supports line wraps, only matches valid argument/method names, Public/Private and arguments are optional.
# ID: 1715
^[\s]*(?:(Public|Private)[\s]+(?:[_][\s]*[\n\r]+)?)?(Function|Sub)[\s]+(?:[_][\s]*[\n\r]+)?([a-zA-Z][\w]{0,254})(?:[\s\n\r_]*\((?:[\s\n\r_]*([a-zA-Z][\w]{0,254})[,]?[\s]*)*\))?

# Matches Canadian postal codes from http://en.wikipedia.org/wiki/Canadian_postal_code. Originally I was going to use http://regexlib.com/REDetails.aspx?regexp_id=1676 but C# did not like it. I rewrote it to this version which works correctly.
# ID: 1816
\b(?([A-Z])[^DFIOQUWZ])\d(?([A-Z])[^DFIOQU])\d(?([A-Z])[^DFIOQUWZ])\d\b

# Matches Canadian provincial codes. Similar to the one already posted but smaller, faster, and will correctly return the results in one match group rather than using several so it's much friendlier.
# ID: 1250
^(N[BLSTU]|[AMN]B|[BQ]C|ON|PE|SK)$

# \1 references the method signature (eg main(String[] args)), \2 references the method name (eg main), \3 references the args (eg String[] args), and \4 and up reference each arg in turn (including type names). Supports @interfaces, java keywords/primitives, generic classes (including bounded and unbounded parameters), varargs, and array classes, but due to recursion limitations, generic types can only go one level deep (List<String> is ok, but List<List<String>> isn't).
# ID: 3618
(?:@[A-Z]\w*\s+)*(?:(?:public|private|protected)\s+)?(?:(?:(?:abstract|final|native|transient|static|synchronized)\s+)*(?:<(?:\?|[A-Z]\w*)(?:\s+(?:extends|super)\s+[A-Z]\w*)?(?:(?:,\s*(?:\?|[A-Z]\w*))(?:\s+(?:extends|super)\s+[A-Z]\w*)?)*>\s+)?(?:(?:(?:[A-Z]\w*(?:<[A-Z]\w*>)?|int|float|double|char|byte|long|short|boolean)(?:(?:\[\]))*)|void)+)\s+(([a-zA-Z]\w*)\s*\(\s*(((?:[A-Z]\w*(?:<(?:\?|[A-Z]\w*)(?:\s+(?:extends|super)\s+[A-Z]\w*)?(?:(?:,\s*(?:\?|[A-Z]\w*))(?:\s+(?:extends|super)\s+[A-Z]\w*)?)*>)?|int|float|double|char|boolean|byte|long|short)(?:(?:\[\])|\.\.\.)?\s+[a-z]\w*)(?:,\s*((?:[A-Z]\w*(?:<[A-Z]\w*>)?|int|float|double|char|byte|long|short|boolean)(?:(?:\[\])|\.\.\.)?\s+[a-z]\w*))*)?\s*\))

# This matches simple dates against 1 or 2 digits for the month, 1 or 2 digit for the day, and either 2 or 4 digits for the year
# ID: 71
((\d{2})|(\d))\/((\d{2})|(\d))\/((\d{4})|(\d{2}))

# This time validation expression accepts an hour between 1 and 9 (with optional leading zero) and minutes between 01 and 59.  This is primarily for use with an AM/PM drop down list or radio button.
# ID: 237
^(([0]?[1-9]|1[0-2])(:)([0-5][0-9]))$

# This is a basic telephone number vaildation which needs a compulsory prefix of a '+' sign with three digits and followed by a hipen, another three digits and finally followed by another hipen and four more digits.
# ID: 586
^[+][0-9]\d{2}-\d{3}-\d{4}$

# Matches quoted string, using \" as an escape to place quotes in the string
# ID: 124
"((\\")|[^"(\\")])+"

# After looking for a date regular expression, I could not find one that meet my need, so I develop one that handles 1 or 2 digets in the month and day and also handle feb up to 29.  This will allow both / and - for separators, which is what I needed.  I hope this helps others too.  Thanks,
# ID: 591
^((((0?[13578])|(1[02]))[\/|\-]?((0?[1-9]|[0-2][0-9])|(3[01])))|(((0?[469])|(11))[\/|\-]?((0?[1-9]|[0-2][0-9])|(30)))|(0?[2][\/\-]?(0?[1-9]|[0-2][0-9])))[\/\-]?\d{2,4}$

# Mapea los nombres. Cualquier caracter, incluyendo la ñ exeptuando los números.
# ID: 2065
[a-zA-Z Á-Úá-ú][^1234567890]+$

# Regular expression to recognise messages formed with "beeps" of IBM mainboards, when the computer makes the Power On Self Test. "b" means "short beep", and "l" means "long beep".
# ID: 1287
^((l((ll)|(b)|(bb)|(bbb)))|(bb*))$

# Expression to match decimal number with 2 digits.
# ID: 2072
^([1-9]([0-9])?)(\.(([0])?|([1-9])?|[1]([0-1])?)?)?$

# Matches the UK Drivers License format:
# ID: 3234
\b[A-Z0-9]{5}\d{1}[01567]\d{1}([0][1-9]|[12][0-9]|[3][0-1])\d{1}[A-Z0-9]{3}[A-Z]{2}\b

# Is there an easier way of doing this??
# ID: 3235
\b([Jj](([Aa][Nn][Uu][Aa][Rr][Yy]|[Aa][Nn])|([Uu][Nn][Ee]|[Uu][Nn])|([Uu][Ll][Yy]|[Uu][Ll])))\b|\b((([Ss][Ee][Pp][Tt]|[Nn][Oo][Vv]|[Dd][Ee][Cc])[Ee][Mm])|[Oo][Cc][Tt][Oo])[Bb][Ee][Rr]|([Ss][Ee][Pp]|[Nn][Oo][Vv]|[Dd][Ee][Cc]|[Oo][Cc][Tt])\b|\b([Mm][Aa]([Yy]|([Rr][Cc][Hh]|[Rr])))\b|\b[Aa](([Pp][Rr][Ii][Ll]|[Pp][Rr])|([Uu][Gg][Uu][Ss][Tt]|[Uu][Gg]))\b|\b[Ff]([Ee][Bb][Rr][Uu][Aa][Rr][Yy]|[Ee][Bb])\b

# This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.
# ID: 892
^[9]9\d{10}|^[5]\d{10}

# Regular expression that only allows expression in the format: MM/DD/YYYY
# ID: 850
^([01][012]|0[1-9])/([0-2][0-9]|[3][0-1])/([0-9][0-9][0-9][0-9])$

# Checks for properly formatted Mime-Types. Checks that the Content-Type (before the '/') is one registered with IANA. No spaces allowed.
# ID: 2381
/^(application|audio|example|image|message|model|multipart|text|video)\/[a-zA-Z0-9]+([+.-][a-zA-z0-9]+)*$/

# This pattern matches the password from a SQL Server connection string.
# ID: 1428
(pwd|password)\s*=\s*(?<pwd>('(([^'])|(''))+'|[^';]+))

# for checking a value is between 99.99% and 00.00%
# ID: 627
^((\d{1,2})?([.][\d]{1,2})?){1}[%]{1}$

# This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required.
# ID: 912
^((0?[1-9]|1[012])(:[0-5]\d){1,2}(\ [AaPp][Mm]))$

# Basic expression to validate a 10 digit number. Does not allow for any delimiters between numbers. Specifies that numbers cannot start with a one.
# ID: 2516
(([2-9]{1})([0-9]{2})([0-9]{3})([0-9]{4}))$

# Checks whether the string specified is in the same format as the UK postcode format defined on:
# ID: 200
^([A-Z]{1,2}[0-9]{1,2}|[A-Z]{3}|[A-Z]{1,2}[0-9][A-Z])( |-)[0-9][A-Z]{2}

# Postcode for Belgium
# ID: 201
^[1-9]{1}[0-9]{3}$

# Postcode for Germany
# ID: 202
^[A-Z]{1}( |-)?[1-9]{1}[0-9]{3}$

# Postcode check for France (including colonies)
# ID: 203
^(F-)?((2[A|B])|[0-9]{2})[0-9]{3}$

# Postcode check for Italy (including possible Vatican/Italy indications)
# ID: 204
^(V-|I-)?[0-9]{4}$

# Postcode check for Netherlands
# ID: 205
^[1-9]{1}[0-9]{3} ?[A-Z]{2}$

# Postcode check for Spain
# ID: 206
^([1-9]{2}|[0-9][1-9]|[1-9][0-9])[0-9]{3}$

# This re matches numbers with our without commas and with or without exactly two decimal places.
# ID: 1594
((^([\d]{1,3})(,{1}([\d]{3}))*)|(^[\d]*))((\.{1}[\d]{2})?$)

# Matches dates in mm/dd/yyyy format. Matches only valid dates -except is unable to test for a leapyear. Always allows February 29th. Allows years from 1901 to 2199.
# ID: 1595
(?:(?:(?:04|06|09|11)\/(?:(?:[012][0-9])|30))|(?:(?:(?:0[135789])|(?:1[02]))\/(?:(?:[012][0-9])|30|31))|(?:02\/(?:[012][0-9])))\/(?:19|20|21)[0-9][0-9]

# Matches tags
# ID: 264
\w?<\s?\/?[^\s>]+(\s+[^"'=]+(=("[^"]*")|('[^\']*')|([^\s"'>]*))?)*\s*\/?>

# That pattern will filter for words that contain more than 1 instance of any of the following characters: ! $ % @.
# ID: 614
(?<=^|[\s ]+)[^\!\@\%\$\s ]*([\!\@\%\$][^\!\@\%\$\s ]*){2,}(?=[\s ]+|$)

# This pattern matches a simple Decimal Literal.  Leading digits limited to 8 and does not support commification.
# ID: 637
# Multiline
(?n)^-?(\d{1,8}(\.\d{1,2})?|\d{0,8}(\.\d{1,2}))$

# Match the VB Language specification BNF for DateTime literal.  http://msdn.microsoft.com/library/en-us/vbls7/html/vblrfvbspec2_4_6.asp?frame=true
# ID: 638
# Multiline
(?'DateLiteral'\#\s*(?'DateOrTime'(?'DateValue'((?'Month'(0?[1-9])|1[0-2])(?'Sep'[-/])(?'Day'0?[1-9]|[12]\d|3[01])\k'Sep'(?'Year'\d{1,4})\s+(?'HourValue'(0?[1-9])|1[0-9]|2[0-4])[:](?'MinuteValue'0?[1-9]|[1-5]\d|60)[:](?'SecondValue':0?[1-9]|[1-5]\d|60)?\s*(?'AMPM'[AP]M)?)|((?'Month'(0?[1-9])|1[0-2])(?'Sep'[-/])(?'Day'0?[1-9]|[12]\d|3[01])\k'Sep'(?'Year'\d{4}))|((?'HourValue'(0?[1-9])|1[0-9]|2[0-4])[:](?'MinuteValue'0?[1-9]|[1-5]\d|60)[:](?'SecondValue':0?[1-9]|[1-5]\d|60)?\s*(?'AMPM'[AP]M)?)))\s*\#)

# This pattern validates ISBN numbers.  I've written a full description about it here:  http://regexblogs.com/dneimke/posts/201.aspx
# ID: 487
^ISBN\s(?=[-0-9xX ]{13}$)(?:[0-9]+[- ]){3}[0-9]*[xX0-9]$

# [Default]
# ID: 445
(?s)/\*.*\*/

# Simple Postcode - this is the first test of the new WebService :-)
# ID: 436
(\d{4,6})

# Tests for all numbers OR all letters (upper or lower case)
# ID: 438
^(\d+|[a-zA-Z]+)$

# Matches a string to ensure that it does not end with .aspx; sure, you'd probably use string handling to do something this simple but, in the real world you'd whack a regex which validates a valid url to the front of this.
# ID: 457
.*?$(?<!\.aspx)

# Matches C style strings allowing for escaped string delimiters to be included in the match.
# ID: 355
"([^"](?:\\.|[^\\"]*)*)"

# This is my all-time favourite e-mail validator.  I've used it for years and it's never failed me :-)
# ID: 356
(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})

# Matches filenames.
# ID: 357
^([a-zA-Z]\:)(\\[^\\/:*?<>"|]*(?<![ ]))*(\.[a-zA-Z]{2,6})$

# [Default]
# ID: 359
# Multiline
(\b\w+\b)\s+\1

# Matches and segments the sections of an opening tag. For more detailed information refer to this blog entry: http://weblogs.asp.net/dneimke/posts/25616.aspx
# ID: 373
# Multiline
(?'openingTag'<)\s*?(?'tagName'\w+)(\s*?(?>(?!=[\/\?]?>)(?'attribName'\w+)(?:\s*(?'attribSign'=)\s*)(?'attribValue'(?:\'[^\']*\'|\"[^\"]*\"|[^ >]+))))\s*?(?'closeTag'[\/\?]?>)

# [Default]
# ID: 386
# Multiline
# Greedy, no-backtracking and only named groups capture.
(?n)^((?'allowDay'Sun|Mon|Fri)|(Sat(?'allowDay'ur(?=d))?)|(((T(ue?|h(ur?)?))|(Wed(ne(?=sd))?))((?<=(e|r))(?'allowDay's))?))((?(allowDay)day)|\.)?$

# Matches a percentage between 0 and 100 (inclusive).  Accepts up to 2 decimal places.
# ID: 667
# Multiline
^(100(?:\.0{1,2})?|0*?\.\d{1,2}|\d{1,2}(?:\.\d{1,2})?)%$

# This expression matches ICD-10 code
# ID: 2276
^[A-Z]\d{2}(\.\d){0,1}$

# Checks all Iban numbers on the first 2 characters example NL has 18 characters less or more is not allowed
# ID: 3002
^((NO)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(NO)[0-9A-Z]{15}|(BE)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}|(BE)[0-9A-Z]{16}|(DK|FO|FI|GL|NL)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{2}|(DK|FO|FI|GL|NL)[0-9A-Z]{18}|(MK|SI)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(MK|SI)[0-9A-Z]{19}|(BA|EE|KZ|LT|LU|AT)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}|(BA|EE|KZ|LT|LU|AT)[0-9A-Z]{20}|(HR|LI|LV|CH)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{1}|(HR|LI|LV|CH)[0-9A-Z]{21}|(BG|DE|IE|ME|RS|GB)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{2}|(BG|DE|IE|ME|RS|GB)[0-9A-Z]{22}|(GI|IL)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(GI|IL)[0-9A-Z]{23}|(AD|CZ|SA|RO|SK|ES|SE|TN)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}|(AD|CZ|SA|RO|SK|ES|SE|TN)[0-9A-Z]{24}|(PT)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{1}|(PT)[0-9A-Z]{25}|(IS|TR)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{2}|(IS|TR)[0-9A-Z]{26}|(FR|GR|IT|MC|SM)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(FR|GR|IT|MC|SM)[0-9A-Z]{27}|(AL|CY|HU|LB|PL)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}|(AL|CY|HU|LB|PL)[0-9A-Z]{28}|(MU)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{2}|(MU)[0-9A-Z]{30}|(MT)[0-9A-Z]{2}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{4}[ ][0-9A-Z]{3}|(MT)[0-9A-Z]{31})$

# Gets all text before the last capital (no whitespace allowed).
# ID: 1385
^(?<BeforeLastCapital>([^\s]*))(?<LastCapital>[A-Z])(?<AfterLastCapital>([^A-Z])*)$   #Last Capital

# Updated: 5-15-2007 @ 2:30pm ---
# ID: 1778
^(?:(?:(?:(?:[1-2][0-9]{3}) *(?:[\/\-\., ]) *(?:1[0-2]|0?[1-9]) *(?:[\/\-\., ]) *(?:[12][0-9]|3[01]|0?[1-9]))|(?:(?:1[0-2]|0?[1-9]) *(?:[\/\-\., ]) *(?:[12][0-9]|3[01]|0?[1-9]) *(?:[\/\-\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:[12][0-9]|3[01]|0?[1-9]) *(?:[\/\-\., ]) *(?:1[0-2]|0?[1-9]) *(?:[\/\-\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)) *(?:[\/\-\., ]) *(?:(?:[12][0-9]|3[01]|0?[1-9])|(?:(?i:[23]?1st|2?2nd|2?3rd|[4-9]th|1[0-9]th|20th|2[4-9]th|30th))) *(?:[\/\-\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:(?:[12][0-9]|3[01]|0?[1-9])|(?:(?i:[23]?1st|2?2nd|2?3rd|[4-9]th|1[0-9]th|20th|2[4-9]th|30th))) *(?:[\/\-\., ]) *(?:(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)) *(?:[\/\-\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3}))))|(?:(?:(?:(?:[1-2][0-9]{3}) *(?:[\/\-\., ]) *(?:1[0-2]|0?[1-9]) *(?:[\/\-\., ]) *(?:[12][0-9]|3[01]|0?[1-9]))|(?:(?:1[0-2]|0?[1-9]) *(?:[\/\-\., ]) *(?:[12][0-9]|3[01]|0?[1-9]) *(?:[\/\-\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:[12][0-9]|3[01]|0?[1-9]) *(?:[\/\-\., ]) *(?:1[0-2]|0?[1-9]) *(?:[\/\-\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)) *(?:[\/\-\., ]) *(?:(?:[12][0-9]|3[01]|0?[1-9])|(?:(?i:[23]?1st|2?2nd|2?3rd|[4-9]th|1[0-9]th|20th|2[4-9]th|30th))) *(?:[\/\-\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:(?:[12][0-9]|3[01]|0?[1-9])|(?:(?i:[23]?1st|2?2nd|2?3rd|[4-9]th|1[0-9]th|20th|2[4-9]th|30th))) *(?:[\/\-\., ]) *(?:(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)) *(?:[\/\-\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))) *(?:(?:(?:1[0-2]|0?[1-9])(?: *(?:\:) *(?:[1-5][0-9]|0?[0-9]))?(?: *(?:\:) *(?:[1-5][0-9]|0?[0-9]))? *(?:(?i:[ap]m)))|(?:(?:2[0-3]|[01]?[0-9])(?: *(?:\:) *(?:[1-5][0-9]|0?[0-9]))(?: *(?:\:) *(?:[1-5][0-9]|0?[0-9]))?))))$

# Matches month Full names and Abbreviations. If you can find anyway to optimize its performance, please do so and add a comment with it.
# ID: 1781
(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)

# Matches week Full names and Abbreviations. If you can find anyway to optimize its performance, please do so and add a comment with it.
# ID: 1782
(?i:t(?:ue(?:sday)?|hu(?:rsday)?))|s(?:un(?:day)?|at(?:urday)?)|(?:wed(?:nesday)?|(?:mon|fri)(?:day)?)

# Validate full names (w/ accents). A first/last name needed, at least, 2 letters. See examples.
# ID: 2515
^(?i)([À-ÿa-z\-]{2,})\x20([À-ÿa-z\-']{2,})(?-i)

# Validate hours with seconds returning mirrors correctly.
# ID: 2657
^([0-1][0-9]|[2][0-3]|[0-9]):([0-5][0-9])(?::([0-5][0-9]))?$

# Validate a date format: d/m/Y.
# ID: 2658
^([0-2]\d|3[0-1]|[1-9])\/(0\d|1[0-2]|[1-9])\/(\d{4})$

# Match numbers with or without a number before a decimal. If there is a decimal there must be a number after it though
# ID: 3522
^(^[0-9]*(^[0-9]*[\.][0-9]+){0,1}$)

# Pulls out comments (both Rem and ') and string literals from VB or VBScript. Usefull for spell checking or review.
# ID: 324
('.*$|Rem((\t| ).*$|$)|"(.|"")*?")

# This pattern matches whole numbers 1-100.
# ID: 716
^([1-9]|[1-9]\d|100)$

# Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.
# ID: 997
^(X(-|\.)?0?\d{7}(-|\.)?[A-Z]|[A-Z](-|\.)?\d{7}(-|\.)?[0-9A-Z]|\d{8}(-|\.)?[A-Z])$

# To extract the first path from both windows and unix complete path (need / or \ at the end if we have only one path, but can be easily change)
# ID: 2941
(^(?:\w\:)?(?:/|\\\\){1}[^/|\\]*(?:/|\\){1})

# This expression returns
# ID: 2727
(.*[\\\/]|^)(.*?)(?:[\.]|$)([^\.\s]*$)

# This limits an HTML textarea to only be 20 characters.  Built for an ASP:regularexpression tag to validate a textarea.
# ID: 1137
^(.){0,20}$

# Returns the three most important attributes from an HTML <input> tag: 'type', 'name' and 'value'. Supports attribute values that are double- or single-quoted or unquoted. Returns four references, the first being the name of the attribute, and the other three being the value, of which only one will be populated based on the way the value was quoted.
# ID: 1195
\s(type|name|value)=(?:(\w+)|(?:"(.*?)")|(?:\'(.*)\'))

# Validates a long filename using Windows' rules.  Requires one valid filename character other than "." for the first character and then any number of valid filename characters up to a total length of 255 characters.  Unresolved is how to prevent the last character from being a "." while still meeting all the features that this regex does now.
# ID: 965
^[^\\\./:\*\?\"<>\|]{1}[^\\/:\*\?\"<>\|]{0,254}$

# Check Dutch phonenumber including 0031 or +31 and optional - characters.
# ID: 2066
^((((0031)|(\+31))(\-)?6(\-)?[0-9]{8})|(06(\-)?[0-9]{8})|(((0031)|(\+31))(\-)?[1-9]{1}(([0-9](\-)?[0-9]{7})|([0-9]{2}(\-)?[0-9]{6})))|([0]{1}[1-9]{1}(([0-9](\-)?[0-9]{7})|([0-9]{2}(\-)?[0-9]{6}))))$

# Checks date in format dd-mm-yyyy. Seperation characters can be -/. and space.
# ID: 2059
^(((0[1-9]|[12]\d|3[01])[\s\.\-\/](0[13578]|1[02])[\s\.\-\/]((19|[2-9]\d)\d{2}))|((0[1-9]|[12]\d|30)[\s\.\-\/](0[13456789]|1[012])[\s\.\-\/]((19|[2-9]\d)\d{2}))|((0[1-9]|1\d|2[0-8])[\s\.\-\/]02[\s\.\-\/]((19|[2-9]\d)\d{2}))|(29[\s\.\-\/]02[\s\.\-\/]((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$

# Vat number for Austria.
# ID: 2141
^(AT){0,1}[U]{0,1}[0-9]{8}$

# Vat number for Bulgaria. Formats are
# ID: 2142
^(BG){0,1}([0-9]{9}|[0-9]{10})$

# Allow Currencies of European origin in the format of
# ID: 2363
^(-?)(,?)(\d{1,3}(\.\d{3})*|(\d+))(\,\d{2})?$

# it matches dutch zip codes (postcode)
# ID: 1087
^[1-9]{1}[0-9]{3}\s?[a-zA-Z]{2}$

# e. g. HH:MM:SS:ttt --> HH:MM:SS:ttt;
# ID: 2659
^([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1} --> ([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1}(.*)$

# e. g. {11510}{11810}Blah, blah, blah.;
# ID: 2660
^\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\}\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\}(.*)$

# Table:
# ID: 2595
^(A(D|E|F|G|I|L|M|N|O|R|S|T|Q|U|W|X|Z)|B(A|B|D|E|F|G|H|I|J|L|M|N|O|R|S|T|V|W|Y|Z)|C(A|C|D|F|G|H|I|K|L|M|N|O|R|U|V|X|Y|Z)|D(E|J|K|M|O|Z)|E(C|E|G|H|R|S|T)|F(I|J|K|M|O|R)|G(A|B|D|E|F|G|H|I|L|M|N|P|Q|R|S|T|U|W|Y)|H(K|M|N|R|T|U)|I(D|E|Q|L|M|N|O|R|S|T)|J(E|M|O|P)|K(E|G|H|I|M|N|P|R|W|Y|Z)|L(A|B|C|I|K|R|S|T|U|V|Y)|M(A|C|D|E|F|G|H|K|L|M|N|O|Q|P|R|S|T|U|V|W|X|Y|Z)|N(A|C|E|F|G|I|L|O|P|R|U|Z)|OM|P(A|E|F|G|H|K|L|M|N|R|S|T|W|Y)|QA|R(E|O|S|U|W)|S(A|B|C|D|E|G|H|I|J|K|L|M|N|O|R|T|V|Y|Z)|T(C|D|F|G|H|J|K|L|M|N|O|R|T|V|W|Z)|U(A|G|M|S|Y|Z)|V(A|C|E|G|I|N|U)|W(F|S)|Y(E|T)|Z(A|M|W))$

# Table:
# ID: 2596
^(A(BW|FG|GO|IA|L(A|B)|N(D|T)|R(E|G|M)|SM|T(A|F|G)|U(S|T)|ZE)|B(DI|E(L|N)|FA|G(D|R)|H(R|S)|IH|L(M|R|Z)|MU|OL|R(A|B|N)|TN|VT|WA)|C(A(F|N)|CK|H(E|L|N)|IV|MR|O(D|G|K|L|M)|PV|RI|UB|XR|Y(M|P)|ZE)|D(EU|JI|MA|NK|OM|ZA)|E(CU|GY|RI|S(H|P|T)|TH)|F(IN|JI|LK|R(A|O)|SM)|G(AB|BR|EO|GY|HA|I(B|N)|LP|MB|NQ|NB|R(C|D|L)|TM|U(F|M|Y))|H(KG|MD|ND|RV|TI|UN)|I(DN|MN|ND|OT|R(L|N|Q)|S(L|R)|TA)|J(AM|EY|OR|PN)|K(AZ|EN|GZ|HM|IR|NA|OR|WT)|L(AO|B(N|R|Y)|CA|IE|KA|SO|TU|UX|VA)|M(A(C|F|R)|CO|D(A|G|V)|EX|HL|KD|L(I|T)|MR|N(E|G|P)|OZ|RT|SR|TQ|US|WI|Y(S|T))|N(AM|CL|ER|FK|GA|I(C|U)|LD|OR|PL|RU|ZL)|OMN|P(A(K|N)|CN|ER|HL|LW|NG|OL|R(I|K|T|Y)|SE|YF)|QAT|R(EU|OU|US|WA)|S(AU|DN|EN|G(P|S)|HN|JM|L(B|E|V)|MR|OM|PM|RB|TP|UR|V(K|N)|W(E|Z)|Y(C|R))|T(C(A|D)|GO|HA|JK|K(L|M)|LS|ON|TO|U(N|R|V)|WN|ZA)|U(EN|GA|KR|MI|RY|SA|ZB)|V(AT|CT|GB|IR|NM|UT)|W(LF|SM)|YEM|Z(AF|MB|WE))$

# Table:
# ID: 2597
^(0(0(4|8)|1(0|2|6)|2(0|4|8)|3(1|2|6)|4(0|4|8)|5(0|1|2|6)|6(0|4|8)|7(0|2|4|6)|8(4|6)|9(0|2|6))|1(0(0|4|8)|1(2|6)|2(0|4)|3(2|6)|4(0|4|8)|5(2|6)|6(2|6)|7(0|4|5|8)|8(0|4|8)|9(1|2|6))|2(0(3|4|8)|1(2|4|8)|2(2|6)|3(1|2|3|4|8|9)|4(2|4|8)|5(0|4|8)|6(0|2|6|8)|7(0|5|6)|88|9(2|6))|3(0(0|4|8)|1(2|6)|2(0|4|8)|3(2|4|6)|4(0|4|8)|5(2|6)|6(0|4|8)|7(2|6)|8(0|4|8|9)|92)|4(0(0|4|8)|1(0|4|7|8)|2(2|6|8)|3(0|4|8)|4(0|2|6)|5(0|4|8)|6(2|6)|7(0|4|8)|8(0|4)|9(2|6|8|9))|5(0(0|4|8)|1(2|6)|2(0|4|8)|3(0|3)|4(0|8)|5(4|8)|6(2|6)|7(0|4|8)|8(0|1|3|4|5|6)|9(1|8))|6(0(0|4|8)|1(2|6)|2(0|4|6)|3(0|4|8)|4(2|3|6)|5(2|4|9)|6(0|2|3|6)|7(0|4|8)|8(2|6|8)|9(0|4))|7(0(2|3|4|5|6)|1(0|6)|24|3(2|6)|4(0|4|8)|5(2|6)|6(0|4|8)|7(2|6)|8(0|4|8)|9(2|5|6|8))|8(0(0|4|7)|26|3(1|2|3|4)|40|5(0|8)|6(0|2)|76|8(2|7)|94))$

# $i = comment; $2 = X or NO-X;
# ID: 2598
^<\!\-\-(.*)+(\/){0,1}\-\->$

# Communication ports in PC between 1 - 65536.
# ID: 2599
^([1-9]{1}|[1-9]{1}[0-9]{1,3}|[1-5]{1}[0-9]{4}|6[0-4]{1}[0-9]{3}|65[0-4]{1}[0-9]{2}|655[0-2]{1}[0-9]{1}|6553[0-6]{1})$

# This reg. exp. is ignore color names. Supported only hexadecimal with 3 or 6 chars (with or only prefix #); rgb syntax (0-255) and rgb syntax with % (0-100).
# ID: 2600
^([\#]{0,1}([a-fA-F0-9]{6}|[a-fA-F0-9]{3})|rgb\(([0-9]{1},|[1-9]{1}[0-9]{1},|[1]{1}[0-9]{2},|[2]{1}[0-4]{1}[0-9]{1},|25[0-5]{1},){2}([0-9]{1}|[1-9]{1}[0-9]{1}|[1]{1}[0-9]{2}|[2]{1}[0-4]{1}[0-9]{1}|25[0-5]{1}){1}\)|rgb\(([0-9]{1}%,|[1-9]{1}[0-9]{1}%,|100%,){2}([0-9]{1}%|[1-9]{1}[0-9]{1}%|100%){1}\))$

# Supported symbols are € or EUR or EURO (all case sensitive).
# ID: 2604
^(0|(([1-9]{1}|[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{2}){1}(\ [0-9]{3}){0,})),(([0-9]{2})|\-\-)([\ ]{1})(€|EUR|EURO){1}$

# supported all charsets in MySQL 5.1, case sensitive (lower)
# ID: 2605
^(big5|euc(kr|jpms)|binary|greek|tis620|hebrew|ascii|swe7|koi8(r|u)|(u|keyb)cs2|(dec|hp|utf|geostd|armscii)8|gb(k|2312)|cp(8(5(0|2)|66)|932|125(0|1|6|7))|latin(1|2|5|7)|(u|s)jis|mac(ce|roman))$

# supported all collates for all charsets in MySQL 5.1, case sensitive (lower)
# ID: 2606
^((ucs2|utf8)\_(bin|(general|unicode|roman|slovak|czech|icelandic|(latv|pers)ian|(dan|pol|span|swed|turk)ish|spanish2|(esto|lithua|roma|slove)nian\_ci)))|((mac(ce|roman)|cp(8(5(0|2)|66)|1256)|armscii8|geostd8|ascii|keybcs2|greek|hebrew|koi8(r|u))\_(bin|general\_ci))|((dec8|swe7)\_(bin|swedish\_ci))|((hp8|latin5)\_(bin|english\_ci))|((big5|gb(2312|k))\_(bin|chinese\_ci))|((cp932|eucjpms|(s|u)jis)\_(bin|japanese\_ci))|(euckr\_(bin|korean\_ci))|(tis620\_(bin|thai\_ci))|(latin1\_(bin|(((dan|span|swed)ish|german(1|2))\_ci)|general\_(ci|cs)))|(cp1250\_(bin|czech\_cs|general\_ci))|(latin2\_(bin|czech\_cs|(general|hungarian|croatian)\_ci))|(cp1257\_(bin|(general|lithuanian)\_ci))|(latin7\_(bin|general\_(c(i|s))|estonian\_cs))|(cp1251\_(bin|(general|bulgarian|ukrainian)\_ci|general\_cs))$

# [en] Every number of Identification Card in SR contains two letters (begin) and six numbers (continue). Number is without spaces.
# ID: 2574
^(([a-zA-Z]{2})([0-9]{6}))$

# [en] Postal Code in Slovak Republic contains five numbers. Between 3rd and 4th number can be space. [sk] Poštové smerové císlo v Slovenskej Republike má pät císel. Medzi 3. a 4. císlicou môže byt medzera.
# ID: 2575
^(([0-9]{5})|([0-9]{3}[ ]{0,1}[0-9]{2}))$

# Law 301/1995 z. Z. SR from 14. december 1995. PIN from 1900 to 1953 have sufix with three digits, PIN beyond 1954 have four digits in sufix. In first part of woman PIN is month of birth  (3rd & 4th digit) increase +50.
# ID: 2576
^([0-9]{2})(01|02|03|04|05|06|07|08|09|10|11|12|51|52|53|54|55|56|57|58|59|60|61|62)(([0]{1}[1-9]{1})|([1-2]{1}[0-9]{1})|([3]{1}[0-1]{1}))/([0-9]{3,4})$

# no comment :o)
# ID: 2577
^([0-7]{3})$

# no comment :o)
# ID: 2578
^([0]{0,1}[0-7]{3})$

# no comment :o)
# ID: 2579
^((\-|d|l|p|s){1}(\-|r|w|x){9})$

# SUPPORTED constructions:
# ID: 2580
^(((([\*]{1}){1})|((\*\/){0,1}(([0-9]{1}){1}|(([1-5]{1}){1}([0-9]{1}){1}){1}))) ((([\*]{1}){1})|((\*\/){0,1}(([0-9]{1}){1}|(([1]{1}){1}([0-9]{1}){1}){1}|([2]{1}){1}([0-3]{1}){1}))) ((([\*]{1}){1})|((\*\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))) ((([\*]{1}){1})|((\*\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))|(jan|feb|mar|apr|may|jun|jul|aug|sep|okt|nov|dec)) ((([\*]{1}){1})|((\*\/){0,1}(([0-7]{1}){1}))|(sun|mon|tue|wed|thu|fri|sat)))$

# Case sensitive (upper)!
# ID: 2581
^(B(A|B|C|J|L|N|R|S|Y)|CA|D(K|S|T)|G(A|L)|H(C|E)|IL|K(A|I|E|K|M|N|S)|L(E|C|M|V)|M(A|I|L|T|Y)|N(I|O|M|R|Z)|P(B|D|E|O|K|N|P|T|U|V)|R(A|K|S|V)|S(A|B|C|E|I|K|L|O|N|P|V)|T(A|C|N|O|R|S|T|V)|V(K|T)|Z(A|C|H|I|M|V))([ ]{0,1})([0-9]{3})([A-Z]{2})$

# Letter (a - h) + number (1 - 8). Case insensitive.
# ID: 2582
^([a-hA-H]{1}[1-8]{1})$

# no comment
# ID: 2583
^(([0]{0,1})([1-9]{1})([0-9]{2})){1}([\ ]{0,1})((([0-9]{3})([\ ]{0,1})([0-9]{3}))|(([0-9]{2})([\ ]{0,1})([0-9]{2})([\ ]{0,1})([0-9]{2})))$

# This pattern match all attributes,with or without double quote.
# ID: 877
# Multiline
(?<attributeName>\w+?)=(\"+(?<attributeValue>[\w\.\s\:\;\/\\@\-\=\&\?]*)\"+|(?<attributeValue>[\w\.\:\;\/\\@\-\=\&\?]*)?)

# This validates Length times Width times Height measurements, which consists of 3 whole or decimal numbers separated by an x.
# ID: 402
^\s*(((\d*\.?\d*[0-9]+\d*)|([0-9]+\d*\.\d*) )\s*[xX]\s*){2}((\d*\.?\d*[0-9]+\d*)|([0-9]+\d*\.\d*))\s*$

# Validate a string to see if it contains a number / integer
# ID: 47
^[0-9]+$

# Password matching expression. Password must be at least 8 characters,no more then 25 characters, must include at least 1 lower case letter and 1 numeric digit. Upper case, space and punctuation marks are not allowed.
# ID: 2382
^(?=.*\d)(?=.*[a-z])([a-z0-9]{8,25})$

# Designed to verify a MAC address with no spaces allowed, hex values separated by linux style separator ":" or by windows style separator "-". Also empty string entry is allowed.
# ID: 2384
^(((\d|([a-f]|[A-F])){2}:){5}(\d|([a-f]|[A-F])){2})$|^(((\d|([a-f]|[A-F])){2}-){5}(\d|([a-f]|[A-F])){2})$|^$

# This Regular Expression allows the user to enter a value to represent the imperial measurement of Inches.
# ID: 1329
^((0?[1-9])|((1)[0-1]))?((\.[0-9]{0,2})?|0(\.[0-9]{0,2}))$

# This is my attempt to find out valid german postal codes (PLZ or Postleitzahlen).
# ID: 1026
\b((?:0[1-46-9]\d{3})|(?:[1-357-9]\d{4})|(?:[4][0-24-9]\d{3})|(?:[6][013-9]\d{3}))\b

# US vehicle VIN numbers for vehicles with GVW < 10k lbs
# ID: 1133
^([A-Z\d]{3})[A-Z]{2}\d{2}([A-Z\d]{1})([X\d]{1})([A-Z\d]{3})\d{5}$

# Validates a strong password. It must be between 8 and 10 characters, contain at least one digit and one alphabetic character, and must not contain special characters
# ID: 2169
(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{8,10})$

# This regular expression is for admitting wild card searches on Emails the wild card character is * and in my case will only allow to do the search when the * is place after the first 3 alphanumeric characters. If you need to modify this behavior change the {3,40} to {n,m} where n is how many characters before the * and m is the total number if characters.
# ID: 582
\w+[\w-\.]*\@\w+((-\w+)|(\w*))\.[a-z]{2,3}$|^([0-9a-zA-Z'\.]{3,40})\*|([0-9a-zA-Z'\.]+)@([0-9a-zA-Z']+)\.([0-9a-zA-Z']+)$|([0-9a-zA-Z'\.]+)@([0-9a-zA-Z']+)\*+$|^$

# Check valid of input type 2:3,3:4....
# ID: 2655
([*,1-9]:[1-9]){1}(,([*,1-9]:[1-9]){0,}

# Any number.
# ID: 3304
^[+-]?[0-9]*\.?([0-9]?)*

# returns the background-image property with its value. It will not return the uppercase property value like Background-image.
# ID: 2936
background-image.[^<]*?;

# Alphanumeric, hyphen apostrophe, comma dash spaces
# ID: 145
^[a-zA-Z0-9\s.\-_']+$

# Separates a URL into components viz. schema, domain, port, path and query. Avoids unnecessary numbered groups caused by braces.
# ID: 2249
(?:(?<scheme>[a-zA-Z]+)://)?(?<domain>(?:[0-9a-zA-Z\-_]+(?:[.][0-9a-zA-Z\-_]+)*))(?::(?<port>[0-9]+))?(?<path>(?:/[0-9a-zA-Z\-_.]+)+)(?:[?](?<query>.+))?

# This regular expression allows you to match all image tags
# ID: 1027
<(\/{0,1})img(.*?)(\/{0,1})\>

# Matches the UK Drivers License format as laid down by the DVLA / dvla.    See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm    Matches:       1. Must be 16 characters  2. First 5 characters are alphanumeric.  3. Next 6 characters must be numeric  4. Next 3 characters are alphanumeric  5. Last 2 characters are alpha  6. Second character of numeric section can only be 0, 1, 5 or 6.  7. Fourth and fifth characters of numeric section must be in the range 01 to 31.
# ID: 1424
[A-Z0-9]{5}\d[0156]\d([0][1-9]|[12]\d|3[01])\d[A-Z0-9]{3}[A-Z]{2}

# Matches a Din 5008 formatted phone number, except of "special  numbers" like "0180 5 12345"
# ID: 3006
^(\+[1-9]\d+) ([1-9]\d+) ([1-9]\d+)(\-\d+){0,1}$|^(0\d+) ([1-9]\d+)(\-\d+){0,1}$|^([1-9]\d+)(\-\d+){0,1}$

# this spam kontrol Fw[number] blocked.
# ID: 1361
^[a-zA-Z]{1,3}\[([0-9]{1,3})\]

# içinde @ isareti ve en az 1 tane "." olmayanlar kabul edilmez.
# ID: 1362
([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)

# use pdf attachment block spam
# ID: 1864
.*-[0-9]{1,10}.*

# Matches standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).
# ID: 125
^\d{5}(-\d{3})?$

# This one checks if the value is a possible german License Plate. The trailing H stands for Historical cars.
# ID: 1936
^[A-ZÄÖÜ]{1,3}\-[ ]{0,1}[A-Z]{0,2}[0-9]{1,4}[H]{0,1}

# Useful for matching monetary values formatted without commas, leading zeros, currency symbols.
# ID: 3528
^[1-9]+\d*\.\d{2}$

# This expression only accept numbers, spaces, x, ( ) and -. It accepts the values with 10 digits for phone numbers. These may be seperated with any number of spaces or a single '-'. The expression also allows an optional extension number to be provided atleast a single digit and a maximum of 4 digits.
# ID: 1546
(\s+|)((\(\d{3}\) +)|(\d{3}-)|(\d{3} +))?\d{3}(-| +)\d{4}( +x\d{1,4})?(\s+|)

# Pattern matches all file extensions from two(2) to five(5) characters in length (e.g. Adobe Illustrator [*.ai] or Extensible Hypertext Markup Language [*.xhtml]). Input can be an absolute path, relative path, URI, directory path, etc. If there are get variables in a URI input, they are ignored.
# ID: 2674
\.([A-Za-z0-9]{2,5}($|\b\?))

# Matches an SQL Server 2008 Connection String
# ID: 2957
(?:(?:Data Source)|(?:Server))=([\w\.]+?);\s*?(?:(?:Initial Catalog)|(?:Database))=(\w+?);\s*?(?:(?:User Id)|(?:Uid))=(\w+?);\s*?(?:(?:Password)|(?:Pwd))=(\w*?);.*

# Matches a MySQL connection string if the arguments are in the specified order.
# ID: 2891
Server=([\w\.]+?);\s*?(?:Port=(\d+?);\s*?)?Database=(\w+?);\s*?(?:(?:User)|(?:Uid))=(\w+?);\s*?(?:(?:Password)|(?:Pwd))=(\w*?);.*

# validates Percents, where Positive numbers are allowed over 100% (in this case up to 9999), but where Negative percents must not go to or below -100%
# ID: 831
# Multiline
^(\d{0,4}(?:\.\d{0,2})?|[-]\d{0,2}(?:\.\d{0,2})?)[%]{0,1}$

# This is built on an Address expression by Ross Hammer (who in turn built on an expression from Michael Ash)... and the zipcode expression from Matthew Aznoe.  This one adds validation for Canadian provinces and postal codes (so it does both US and Canada)
# ID: 1607
^\s*((?:(?:\d+(?:\x20+\w+\.?)+(?:(?:\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\.?)?)|(?:(?:P\.\x20?O\.|P\x20?O)\x20*Box\x20+\d+)|(?:General\x20+Delivery)|(?:C[\\\/]O\x20+(?:\w+\x20*)+))\,?\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\x23)\.?\x20*(?:[a-zA-Z0-9\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)\,?\s+((?:(?:\d+(?:\x20+\w+\.?)+(?:(?:\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\.?)?)|(?:(?:P\.\x20?O\.|P\x20?O)\x20*Box\x20+\d+)|(?:General\x20+Delivery)|(?:C[\\\/]O\x20+(?:\w+\x20*)+))\,?\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\x23)\.?\x20*(?:[a-zA-Z0-9\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)?\,?\s+((?:[A-Za-z]+\x20*)+)\,\s+(A[BLKSZRAP]|BC|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ABDEHINOPST]|N[BCDEHJLMSTUVY]|O[HKRN]|P[AERW]|QC|RI|S[CDK]|T[NX]|UT|V[AIT]|W[AIVY]|YT)\s+((\d{5}-\d{4})|(\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\d[A-Za-z]\s?\d[A-Za-z]\d))\s*$

# This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number).
# ID: 1449
\b[1-9]{1}[0-9]{1,5}-\d{2}-\d\b

# This expression will parse the date with zero time span only (e.g. 26/07/2010 00:00:00)
# ID: 3096
^(([0-2]\d|[3][0-1])\/([0]\d|[1][0-2])\/[2][0]\d{2})$|^(([0-2]\d|[3][0-1])\/([0]\d|[1][0-2])\/[2][0]\d{2}\s00\:00\:00)$

# Anti-HTML pattern for english sentences. any < or > will make it not match.
# ID: 2849
^[-\w\s"'=/!@#%&,;:`~\.\$\^\{\[\(\|\)\]\}\*\+\?\\]*$

# UK VAT Validation
# ID: 3358
^(GB)?(\ )?[0-9]\d{2}(\ )?[0-9]\d{3}(\ )?(0[0-9]|[1-8][0-9]|9[0-6])(\ )?([0-9]\d{2})?|(GB)?(\ )?GD(\ )?([0-4][0-9][0-9])|(GB)?(\ )?HA(\ )?([5-9][0-9][0-9])$

# Matches any range of numbers according to the format x;x-xx where "x" is a number between 0 and 9, however 0 may not be a the starting digit of a multi-digit number (i.e. 001). The format specifies that a range is denoted by x-x (numbers are seperated by a hyphen) and multiple range specification or single numbers may be seperated by a semi-colon ";".
# ID: 1805
^((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*);|(0|[1-9]+[0-9]*);)*?((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*)|(0|[1-9]+[0-9]*)){1}$

# This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers.  It excludes the following area codes 800, 888,877,866, and 900.
# ID: 2063
^(((?!\(800\))(?!\(888\))(?!\(877\))(?!\(866\))(?!\(900\))\(\d{3}\) ?)|(?!800)(?!888)(?!877)(?!866)(?!900)(\d{3}-))?\d{3}-\d{4}

# Simple email subject line matching. This regex matches those really annoying emails that begin with 0-5 spaces, followed by a fake reply, contain a random string of letters (usually CAPITALIZED) from 1-10 characters long followed by a comma, and then followed by three lower-case words each from 1-10 characters long. In my experience, the 3 trailing words are always lower-case. the words make begin with, contain, or end in common punctuation marks.
# ID: 509
^\W{0,5}[Rr]e:\W[a-zA-Z0-9]{1,10},\W[a-z]{1,10}\W[a-z]{1,10}\W[a-z]{1,10}

# This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok !!
# ID: 82
^\d*\.?((25)|(50)|(5)|(75)|(0)|(00))?$

# One or two digits for day and month. Four digits for year.
# ID: 3500
(0?[1-9]|[12][0-9]|3[01])[.](0?[1-9]|1[012])[.]\d{4}

# This pattern validates a 3 field CSV file. I designed it to capture first name, last name and email address in that order.
# ID: 1593
^(([^,\n]+),([^,\n]+),([^@]+)@([^\.]+)\.([^,\n]+)\n)+([^,\n]+),([^,\n]+),([^@]+)@([^\.]+)\.([^,\n]+)\n?$

# Checks that the input is a positive integer in the range 0-32767
# ID: 1427
^(3276[0-7]|327[0-5]\d|32[0-6]\d{2}|3[01]\d{3}|[12]\d{4}|[1-9]\d{3}|[1-9]\d{2}|[1-9]\d|\d)$

# natural numbers 1, 2, 3...
# ID: 902
^[1-9]\d*\.?[0]*$

# I wrote up this regular expression to fetch the href attribute found in <a> tags as well as a few other HTML tags.
# ID: 646
href=[\"\'](http:\/\/|\.\/|\/)?\w+(\.\w+)*(\/\w+(\.\w+)?)*(\/|\?\w*=\w*(&\w*=\w*)*)?[\"\']

# This is the tightest uk postcode validator I can come up with, I have copy of Royal Mail's PAF (Postal Address File) and I've confirmed that it will correctly validate all 1.75 million distinct postcodes.
# ID: 2653
(?<O>(?<d>[BEGLMNS]|A[BL]|B[ABDHLNRST]|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]|F[KY]|G[LUY]|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]|M[EKL]|N[EGNPRW]|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKL-PRSTWY]|T[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)(?<a>\d\d?)|(?<d>E)(?<a>\dW)|(?<d>EC)(?<a>\d[AMNPRVY0])|(?<d>N)(?<a>\dP)|(?<d>NW)(?<a>\dW)|(?<d>SE)(?<a>\dP)|(?<d>SW)(?<a>\d[AEHPVWXY])|(?<d>W)(?<a>1[0-4A-DFGHJKSTUW])|(?<d>W)(?<a>[2-9])|(?<d>WC)(?<a>[12][ABEHNRVX]))\ (?<I>(?<s>\d)(?<u>[ABD-HJLNP-UW-Z]{2}))

# This regular expressions matches dates of the form XX/XXX/YYYY where XX can be 1 or 2 digits long, XXX can be JAN/Jan/jan(Month name in 3 char) and YYYY is always 4 digits long.
# ID: 2311
^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\/](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\/]\d{4}$

# Password must have at least 8 characters and maximum of 15 characters with at least one Capital letter, at least one lower case letter and at least one number.Special character is optional. Special characters ",;&|' not allowed.
# ID: 2616
(?=^.{8,15}$)((?!.*\s)(?=.*[A-Z])(?=.*[a-z])(?=(.*\d){1,}))((?!.*[",;&|'])|(?=(.*\W){1,}))(?!.*[",;&|'])^.*$

# Expression to detect the name of the stored procedure / function / view, useful to detect automatically the name of the sproc the produced text in SQL
# ID: 3291
(CREATE|ALTER) +(PROCEDURE|PROC|FUNCTION|VIEW) *(\[(.*)\]|(.*))

# Matches Macintosh file names syntax. (does not support paths, just the filename)
# ID: 3530
^([^:])+\\.([^:])+$

# Finds strings enclosed in double quotations
# ID: 1844
"[^"]+"

# This is the real regex for a non-railroad board HICN. All combinations are accounted for. This does not account for dashes as they are stripped out before I do the validation.
# ID: 3643
^(00[1-9]|0[1-9][0-9]|[1-7][0-9][0-9]|7[0-7][0-2]|77[0-2])(\d{6})(A|B([1-9]?|[ADGHJKLNPQRTWY])|C([1-9]|[A-Z])|D([1-9]?|[ACDGHJKLMNPQRSTVWXYZ])|E([1-9]?|[ABCDFGHJKM])|F([1-8])|J([1-4])|K([1-9]|[ABCDEFGHJLM])|T([ABCDEFGHJKLMNPQRSTUVWXYZ2]?)|M|W([1-9]?|[BCFGJRT]))$

# Min 8 Max 50 chars /r/n
# ID: 3685
^(?=.*[A-Z])(?=.*[a-z])(?=.*[\d])(?=.*[-\]\\`~!@#$%^&*()_=+}{[|'";:><,.?/ ]).{8,50}$

# This will validate most Australian telephone numbers including 13, 1300, 1800, 1900, std and international +61- format numbers. It allows optional spaces, dashes and brackets in most cases.
# ID: 2055
(?<local1300>^1300[ |\-]{0,1}\d{3}[ |\-]{0,1}\d{3}$)|(?<tollcall>^1900|1902[ |\-]{0,1}\d{3}[ |\-]{0,1}\d{3}$)|(?<freecall>^1800[ |\-]{0,1}\d{3}[ |\-]{0,1}\d{3}$)|(?<standard>^\({0,1}0[2|3|7|8]{1}\){0,1}[ \-]{0,1}\d{4}[ |\-]{0,1}\d{4}$)|(?<international>^\+61[ |\-]{0,1}[2|3|7|8]{1}[ |\-]{0,1}[0-9]{4}[ |\-]{0,1}[0-9]{4}$)|(?<local13>^13\d{4}$)|(?<mobile>^04\d{2,3}\d{6}$)

# This Expression Validates a string of Email Adresses which are sepereated with one of these[,.] and can have several white spaces between the delimeters. everything can be read out of groups
# ID: 3004
^ *(([\.\-\+\w]{2,}[a-z0-9])@([\.\-\w]+[a-z0-9])\.([a-z]{2,3})) *(; *(([\.\-\+\w]{2,}[a-z0-9])@([\.\-\w]+[a-z0-9])\.([a-z]{2,3})) *)* *$

# Date pattern for date format
# ID: 3462
^((((0[1-9]|[1-2][0-9]|3[0-1])[./-](0[13578]|10|12))|((0[1-9]|[1-2][0-9])[./-](02))|(((0[1-9])|([1-2][0-9])|(30))[./-](0[469]|11)))[./-]((19\d{2})|(2[012]\d{2})))$

# Validates swedish zipcodes (postnr) with or without space between groups. With leading s- or not. Can be disconnected by removing ''(s-|S-){0,1}''.
# ID: 83
^(s-|S-){0,1}[0-9]{3}\s?[0-9]{2}$

# This regular expression validate a range between -64 and 64.
# ID: 2726
^[0-9]{1}$|^[1-6]{1}[0-3]{1}$|^64$|\-[1-9]{1}$|^\-[1-6]{1}[0-3]{1}$|^\-64$

# Will find any bible reference even if it uses roman numerals or has multiple chapter/verse and/or multiple verse components. Does not confirm chapter/verse value ranges. It would find/validate Genesis 5340:9387
# ID: 2449
([0-9]* {0,2}[A-Z]{1}\w+[,.;:]? {0,4}[xvilcXVILC\d]+[.,;:]( {0,2}[\d-,]{1,7})+)([,.;:] {0,4}[xvilcXVILC]*[.,;:]( {0,2}[\d-,]{1,7})+)*

# Verifies South African mobile numbers with or without the country code.
# ID: 953
^((?:\+27|27)|0)(=72|82|73|83|74|84)(\d{7})$

# sdfsd
# ID: 2499
^[A-Z0-9a-z'&()/]{0,1}[A-Z0-9a-z'&()/]{0,1}(([A-Z0-9a-z'&()/_-])|(\\s)){0,47}[A-Z0-9a-z'&()/]{1}$

# Format when entering page ranges in Print dialogs.
# ID: 2028
(\d+(-\d+)*)+(,\d+(-\d+)*)*

# Used to dynamically find acronyms in a sentence. The first pair of brackets gets the acronym, the second gets the text after the acronym.
# ID: 636
([A-Zäöü0-9\/][^a-z\:\,\(\)]*[A-Zäöü0-9])($|[\.\:\,\;\)\-\ \+]|s\b)

# Australian mobile phone number
# ID: 1256
^04[0-9]{8}

# This regex match numeric data in the following format: thousands are separated by (') apostrophe, decimal places are separated by dot (.) Maximum three decimal places are not required. It's easy to change to other separators as well.
# ID: 107
^(\d{1,3}'(\d{3}')*\d{3}(\.\d{1,3})?|\d{1,3}(\.\d{3})?)$

# Fully functional date validator in format dd.MM.yyyy
# ID: 108
^((0?[1-9]|[12][1-9]|3[01])\.(0?[13578]|1[02])\.20[0-9]{2}|(0?[1-9]|[12][1-9]|30)\.(0?[13456789]|1[012])\.20[0-9]{2}|(0?[1-9]|1[1-9]|2[0-8])\.(0?[123456789]|1[012])\.20[0-9]{2}|(0?[1-9]|[12][1-9])\.(0?[123456789]|1[012])\.20(00|04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96))$

# It matches .jpg files. It allows for a dot in the path. A dot may occur in such directories as: C:\Documents and Settings\roman.lukyanenko\Desktop\stuff\b_card2.txt or C:\Windows\Microsoft.NET etc
# ID: 648
^(([a-zA-Z]:)|(\\{2}\w+)\$?)(\\(\w[\w ]*.*))+\.(txt|TXT)$

# I know its simple, yet there was no Russian postal code regular expression on the RegExLib. Just in case some needs to know the format.
# ID: 649
^[0-9]{6}

# Matches the copyright symbol (&copy;). Pretty simple, yet I dont think existed on RegExLib before.
# ID: 652
\xA9

# Matches the ™ symbol. Pretty simple, yet I dont think existed on RegExLib before.
# ID: 673
\u2122

# Matches the registered trademark (®). Pretty simple, yet I dont think existed on RegExLib before.
# ID: 674
\u00AE

# Matches the British Pound symbol. Pretty simple, yet I dont think existed on RegExLib before.
# ID: 675
\u00A3

# Matches the Euro sign. Pretty simple, yet I dont think existed on RegExLib before.
# ID: 676
\u20AC

# Matches the Yen sign. Pretty simple, yet I dont think existed on RegExLib before.
# ID: 677
\u00A5

# Matches infinity symbol. Pretty simple, yet I dont think existed on RegExLib before.
# ID: 678
\u221E

# It matches .jpg files. It allows for a dot in the path. A dot may occur in such directories as: C:\Documents and Settings\roman.lukyanenko\Desktop\stuff\b_card2.jpg
# ID: 512
^(([a-zA-Z]:)|(\\{2}\w+)\$?)(\\(\w[\w ]*.*))+\.(jpg|JPG)$

# The puzzle answer to save the day! This is the hint clue answer you need to solve the toughest developer puzzle ever TDPE.
# ID: 3040
(?<=<\w+ )(\w+-*\w*=[^>]+\s?)(?=>)

# Maches small and big cyrillic letters. Using Unicode codes.
# ID: 1243
[\u0410-\u042F\u0430-\u044F]+

# Step 1: Test that the input is a UK phone number. Later patterns extract the prefix, NSN and extension, and further tests check the NSN for length and validity.
# ID: 3606
^\(?(?:(?:0(?:0|11)\)?[\s-]?\(?|\+)44\)?[\s-]?\(?(?:0\)?[\s-]?\(?)?|0)(?:\d{2}\)?[\s-]?\d{4}[\s-]?\d{4}|\d{3}\)?[\s-]?\d{3}[\s-]?\d{3,4}|\d{4}\)?[\s-]?(?:\d{5}|\d{3}[\s-]?\d{3})|\d{5}\)?[\s-]?\d{4,5}|8(?:00[\s-]?11[\s-]?11|45[\s-]?46[\s-]?4\d))(?:(?:[\s-]?(?:x|ext\.?\s?|\#)\d+)?)$

# Step 2: After step 1 has verified the input is likely to be a UK telephone number, this pattern extracts the NSN part of the number so that it can be passed to another routine that will check it for length and validity. $1 is 44 (international format) or null (use 0 for trunk code - national format). $2 is the NSN. $3 is the extension number.
# ID: 3607
^\(?(?:(?:0(?:0|11)\)?[\s-]?\(?|\+)(44)\)?[\s-]?\(?(?:0\)?[\s-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d-]+)(?:((?:x|ext\.?\s?|\#)\d+)?)$

# Step 3: Validate the NSN produced from the pattern in step 2 and check it for length and validity. The pattern here is fairly basic. More detailed patterns for each number type are available elsewhere.
# ID: 3608
^((1[1-9]|2[03489]|3[0347]|5[56]|7[04-9]|8[047]|9[018])\d{8}|(1[2-9]\d|[58]00)\d{6}|8(001111|45464\d))$

# Step 3: Validate the NSN produced from the pattern in step 2 and check it for length and validity. The pattern here is very detailed matching every valid UK prefix, and rejecting large numbers of non-valid ranges.
# ID: 3609
^(2(?:0[01378]|3[0189]|4[017]|8[0-46-9]|9[012])\d{7}|1(?:(?:1(?:3[0-48]|[46][0-4]|5[012789]|7[0-49]|8[01349])|21[0-7]|31[0-8]|[459]1\d|61[0-46-9]))\d{6}|1(?:2(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-4789]|7[013-9]|9\d)|3(?:0\d|[25][02-9]|3[02-579]|[468][0-46-9]|7[1235679]|9[24578])|4(?:0[03-9]|2[02-5789]|[37]\d|4[02-69]|5[0-8]|[69][0-79]|8[0-5789])|5(?:0[1235-9]|2[024-9]|3[0145689]|4[02-9]|5[03-9]|6\d|7[0-35-9]|8[0-468]|9[0-5789])|6(?:0[034689]|2[0-689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0124578])|7(?:0[0246-9]|2\d|3[023678]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-5789]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\d|8[02-9]|9[02569])|9(?:0[02-589]|2[02-689]|3[1-5789]|4[2-9]|5[0-579]|6[234789]|7[0124578]|8\d|9[2-57]))\d{6}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-4789]|8[345])))|3(?:638[2-5]|647[23]|8(?:47[04-9]|64[015789]))|4(?:044[1-7]|20(?:2[23]|8\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[123]))|5(?:24(?:3[2-79]|6\d)|276\d|6(?:26[06-9]|686))|6(?:06(?:4\d|7[4-79])|295[567]|35[34]\d|47(?:24|61)|59(?:5[08]|6[67]|74)|955[0-4])|7(?:26(?:6[13-9]|7[0-7])|442\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\d|37(?:5[2-5]|8[239])|84(?:3[2-58]))|9(?:0(?:0(?:6[1-8]|85)|52\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\d{3}|176888[234678]\d{2}|16977[23]\d{3})|7(?:[1-4]\d\d|5(?:0[0-8]|[13-9]\d|2[0-35-9])|624|7(?:0[1-9]|[1-7]\d|8[02-9]|9[0-689])|8(?:[014-9]\d|[23][0-8])|9(?:[04-9]\d|1[02-9]|2[0-35-9]|3[0-689]))\d{6}|76(?:0[012]|2[356]|4[0134]|5[49]|6[0-369]|77|81|9[39])\d{6}|80(?:0(?:1111|\d{6,7})|8\d{7})|500\d{6}|87[123]|9(?:[01]\d|8[0-3]))\d{7}|8(?:4(?:5464\d|[2-5]\d{7})|70\d{7})|70\d{8}|56\d{8}|3[0347]|55)\d{8}$

# This is to check release names...
# ID: 899
^[a-zA-Z0-9._-]+$

# This will take all state abbreviations used by the Post Office using either lower or upper case
# ID: 3100
^([Aa][LKSZRAEPlkszraep]|[Cc][AOTaot]|[Dd][ECec]|[Ff][LMlm]|[Gg][AUau]|HI|hi|[Ii][ADLNadln]|[Kk][SYsy]|LA|la|[Mm][ADEHINOPSTadehinopst]|[Nn][CDEHJMVYcdehjmvy]|[Oo][HKRhkr]|[Pp][ARWarw]|RI|ri|[Ss][CDcd]|[Tt][NXnx]|UT|ut|[Vv][AITait]|[Ww][AIVYaivy])$

# Mathces in format DD-MON-YYYY (hyphen between results). Validates for leap years. Ensures month is in uppercase.
# ID: 712
^((31(?! (FEB|APR|JUN|SEP|NOV)))|((30|29)(?! FEB))|(29(?= FEB (((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8])-(JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC)-((1[6-9]|[2-9]\d)\d{2})$

# [Default]
# ID: 618
^((31(?! (FEB|APR|JUN|SEP|NOV)))|(30|29)|(0[1-9])|1\d|2[0-8]) (JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC)$

# Validates date format by DD MMM YYYY. Validates days for each month also.
# ID: 565
^((31(?! (FEB|APR|JUN|SEP|NOV)))|((30|29)(?! FEB))|(29(?= FEB (((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8]) (JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC) ((1[6-9]|[2-9]\d)\d{2})$

# This regex will match various ways of entering a Swiss phone number along with the country code.
# ID: 2421
^(\+?)(\d{2,4})(\s?)(\-?)((\(0\))?)(\s?)(\d{2})(\s?)(\-?)(\d{3})(\s?)(\-?)(\d{2})(\s?)(\-?)(\d{2})

# Matches UK phone numbers - London and regional. It started off with something fairly short posted by liljim at www.forums.devshed.com but I wanted a little more precision to weed out all the zeros. Now it also weeds out premium phone numbers (as of 19/12/03).
# ID: 495
^\s*\(?(020[7,8]{1}\)?[ ]?[1-9]{1}[0-9{2}[ ]?[0-9]{4})|(0[1-8]{1}[0-9]{3}\)?[ ]?[1-9]{1}[0-9]{2}[ ]?[0-9]{3})\s*$

# This captures (for filters out non digits) numbers with or without commas (eg currency as above) in the correct order - the other examples I see here don't capture in right order for all combinations. It doesn't check lengths or leading digits or number of digits between commas- that is left as an exercise for the student.
# ID: 2928
\$(\d*)??,??(\d*)??,??(\d*)\.(\d*)

# This regex matches US and CAN phone numbers with area code and optional 3 or 4 digit PBX extention.  It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.
# ID: 1972
^((([\(]?[2-9]{1}[0-9]{2}[\)]?)|([2-9]{1}[0-9]{2}\.?)){1}[ ]?[2-9]{1}[0-9]{2}[\-\.]{1}[0-9]{4})([ ]?[xX]{1}[ ]?[0-9]{3,4})?$

# US Phone Numbers
# ID: 3317
[( ]?\d{1,3}[ )]?[ -]?\d{3}[ -]?\d{4}

# Us format
# ID: 3318
[+ ]?\s?\d{1,3}[- ]?\d{1,3}[- ]?\d{4}[- ]?\d{4}

# ?
# ID: 3319
\([+]?[ ]?\d{1,3}[)][ ]?[(][+]?[ ]?\d{1,3}[)][- ]?\d{4}[- ]?\d{4}

# ?
# ID: 3320
[+]?[ ]?\d{1,3}[ ]?\d{1,3}[- ]?\d{4}[- ]?\d{4}

# 8-20 chars;
# ID: 2949
^(?!.*(.)\1{3})((?=.*[\d])(?=.*[A-Za-z])|(?=.*[^\w\d\s])(?=.*[A-Za-z])).{8,20}$

# Is used to evaluating domain names, none of the extras such as paths or protocols.
# ID: 306
^(([\w][\w\-\.]*)\.)?([\w][\w\-]+)(\.([\w][\w\.]*))?$

# Specifier Format of Guid Values that this RegEx supports:  32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx]  32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx]  32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}]  32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]
# ID: 672
^[{|\(]?[0-9a-fA-F]{8}[-]?([0-9a-fA-F]{4}[-]?){3}[0-9a-fA-F]{12}[\)|}]?$

# This allows the formatting of most phone numbers.
# ID: 688
^(?:(?:[\+]?(?<CountryCode>[\d]{1,3}(?:[ ]+|[\-.])))?[(]?(?<AreaCode>[\d]{3})[\-/)]?(?:[ ]+)?)?(?<Number>[a-zA-Z2-9][a-zA-Z0-9 \-.]{6,})(?:(?:[ ]+|[xX]|(i:ext[\.]?)){1,2}(?<Ext>[\d]{1,5}))?$

# This regex gets the value within an XML Tag. For example, given the following tag: <Result>result is here</Result> it returns the string "result is here". Replace TAGNAME with your tag name.
# ID: 2301
(?<=<TAGNAME.*>).*(?=</TAGNAME>)

# Matches all portuguese bank account numbers.
# ID: 3374
([\d]{4}[ |-]?){2}([\d]{11}[ |-]?)([\d]{2})

# dd/MM/yyyy with leap years 100% integrated Valid years : from 1000 to 9999
# ID: 3210
^(((0)[13578]|(10)|(12))(/)((0[1-9])|([12][0-9])|((3)[01]))(/)(\d{4}))|(((0)[469]|(11))(/)((0[1-9])|([12][0-9])|(30))(/)(\d{4}))|((02)(/)((0[1-9])|((1)[0-9])|((2)[0-8]))(/)(\d{4}))|((02)(/)((0[1-9])|((1)[0-9])|((2)[0-9]))(/)((\d{2})(([02468][048])|([13579][26]))))$

# Matches the Canadian postal code with no space between.
# ID: 2563
^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\d{1}[A-Za-z]{1}\d{1}[A-Za-z]{1}\d{1}$

# Matches if the string is in hh:mm am/pm format. Also the hour and minute values should have left padding 0's if they are single digit.
# ID: 2564
^([0][1-9]|[1][0-2]):[0-5][0-9] {1}(AM|PM|am|pm)$

# This will grep for a valid MAC address , with colons seperating octets. It will ignore strings too short or long, or with invalid characters.  It will accept mixed case hexadecimal. Use extended grep.
# ID: 154
^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$

# Validate a comma delimited string of integer between 1 and 99999999 (change {0,7} to whatever you need). No zero leading.
# ID: 597
^([1-9]{1}[0-9]{0,7})+((,[1-9]{1}[0-9]{0,7}){0,1})+$

# Positive Whole number matched from 0 to 9999999. Only 9 digits length is allowed in every comma separated value.Can be easily changed to modify the length of the comma separated values.
# ID: 3177
(^\d{1,9})+(,\d{1,9})*$

# Checks  0001-9999
# ID: 835
^(((((0[1-9])|(1\d)|(2[0-8]))[/.-]((0[1-9])|(1[0-2])))|((31[/.-]((0[13578])|(1[02])))|((29|30)[/.-]((0[1,3-9])|(1[0-2])))))[/.-]((000[^0])&([0-9][0-9][0-9][0-9]))|(29[/.-]02[/.-](([0-9][0-9](([02468][48])|([2468][048])|([13579][26])))|((([02468][48])|([2468][048])|([13579][26]))00))))$

# Checks for years 0001-9999.
# ID: 836
# Multiline
^(((((0[1-9])|(1\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((000[1-9])|(00[1-9][0-9])|(0[1-9][0-9][0-9])|([1-9][0-9][0-9][0-9]))|(29/02/(([0-9][0-9](([02468][48])|([2468][048])|([13579][26])))|((([02468][48])|([2468][048])|([13579][26]))00))))$

# China Drug Spam Blocked
# ID: 2688
[a-z0-9][a-z0-9_\.-]{0,}[a-z0-9]\.[a-z0-9][a-z0-9_\.-]{0,}[a-z0-9][\.][cn]{2,4}

# Matches all valid date/datetime strings according to the W3's implementation of ISO 8601, outlined here:
# ID: 2219
^(\d{4}((-)?(0[1-9]|1[0-2])((-)?(0[1-9]|[1-2][0-9]|3[0-1])(T(24:00(:00(\.[0]+)?)?|(([0-1][0-9]|2[0-3])(:)[0-5][0-9])((:)[0-5][0-9](\.[\d]+)?)?)((\+|-)(14:00|(0[0-9]|1[0-3])(:)[0-5][0-9])|Z))?)?)?)$

# Single & character is not valid in HTML or XHTML code. In this case you can replace this character with its entity (if & character is not member of other entity [&#353;]). example: preg_replace('/&(?!amp;)/', '&amp;', $str).
# ID: 1770
&(?![a-z]+;|#\d+;)

# Use this RegExp to grab SRC($1) and ALT($3) values from IMG tags in valid or invalid HTML (XHTML). SRC param must by before IMG. (thanks to mr. Mrva)
# ID: 1763
<img[^>]*src=\"?([^\"]*)\"?([^>]*alt=\"?([^\"]*)\"?)?[^>]*>

# This is the regex for the bank Swift Number
# ID: 2768
^[a-zA-Z]{4}[a-zA-Z]{2}[a-zA-Z0-9]{2}[XXX0-9]{0,3}

# This regex matchs nearly all forms off swiss phone numbers, not only the official form.
# ID: 3499
^(((((\+)?(\s)?(\d{2,4}))(\s)?((\(0\))?)(\s)?|0)(\s|\-)?)(\s|\d{2})(\s|\-)?)?(\d{3})(\s|\-)?(\d{2})(\s|\-)?(\d{2})

# My definitive Date and Time pattern (dd/mm/yyyy hh:mm:ss). It recognizes all correct dates (>1900) and time (even february). What can I say, I'm proud of it
# ID: 959
^((((([0-1]?\d)|(2[0-8]))\/((0?\d)|(1[0-2])))|(29\/((0?[1,3-9])|(1[0-2])))|(30\/((0?[1,3-9])|(1[0-2])))|(31\/((0?[13578])|(1[0-2]))))\/((19\d{2})|([2-9]\d{3}))|(29\/0?2\/(((([2468][048])|([3579][26]))00)|(((19)|([2-9]\d))(([2468]0)|([02468][48])|([13579][26]))))))\s(([01]?\d)|(2[0-3]))(:[0-5]?\d){2}$

# Whilst writing a plain-text to HTML function, I ran into the problem of links that users had written with &lt;a&gt; tags (as opposed to just writing the URL) were linking improperly.  This regular expression returns many types of URL, and preceding characters, if any.  This allows you to handle each type of match appropriately
# ID: 334
\b(((\S+)?)(@|mailto\:|(news|(ht|f)tp(s?))\://)\S+)\b

# Modified URL RegExp that requires (http, https, ftp)://, A nice domain, and a decent file/folder string. Allows : after domain name, and these characters in the file/folder sring (letter, numbers, - . _ ? , ' / \ + & % $ # = ~). Blocks all other special characters-good for protecting against user input!
# ID: 146
^(http|https|ftp)\://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\-\._\?\,\'/\\\+&%\$#\=~])*$

# Great for extracting out all the image src attributes.
# ID: 1760
<[iI][mM][gG][a-zA-Z0-9\s=".]*((src)=\s*(?:"([^"]*)"|'[^']*'))[a-zA-Z0-9\s=".]*/*>(?:</[iI][mM][gG]>)*

# Matches positive percentage strings with '+' as an optional prefix and '%' as an optional postfix.
# ID: 3419
^[+]?100(\.0{1,2})?%?$|^[+]?\d{1,2}(\.\d{1,2})?%?$

# This should require all of the following: An uppercase letter, a lowercase letter, a number and a special character from the provided list. Lastly, it needs to be between 8 and 20 characters long.
# ID: 2992
^(?=.*[!@#$%^&*()\-_=+`~\[\]{}?|])(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).{8,20}$

# Checks a number to see if it matches any international number formats. With or without decimal characters
# ID: 2867
(?:(?:^(?<sign>[+-]?)(?<predec>[0-9]{1,3}(?:\,?[0-9]{2,3})*)(?<dec>\.)(?<postdec>[0-9]*)?$)|(?:^(?<sign>[+-]?)(?<predec>[0-9]{1,3}(?:\.?[0-9]{2,3})*)(?<dec>\,)(?<postdec>[0-9]*)?$)|(?:^(?<sign>[+-]?)(?<predec>[0-9]{1,3}(?:\'?[0-9]{2,3})*)(?<dec>\.)(?<postdec>[0-9]*)?$)|(?:^(?<sign>[+-]?)(?<predec>[0-9]{1,3}(?:\,[0-9]{2,3})*)(?<dec>\.)(?<postdec>[0-9]*)?$)|(?:^(?<sign>[+-]?)(?<predec>[0-9]{1,3}(?:\ [0-9]{2,3})*)(?<dec>\,)(?<postdec>[0-9]*)?$)|(?:^(?<sign>[+-]?)(?<predec>[0-9]{1,3}(?:\'?[0-9]{2,3})*)(?<dec>\,)(?<postdec>[0-9]*)?$))

# This expression matches two different formats of zip codes: 5 digit US ZIP code and 5 digit US ZIP code + 4.The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits.
# ID: 3532
(^(?!0{5})(\d{5})(?!-?0{4})(|-\d{4})?$)

# All even numbers end with either 0, 2, 4, 6 or 8. They can begin with anything.
# ID: 3496
^[0-9]*[02468]$

# Matches database schema-like strings (xxx.xxx.xxx). To control the allowed characters in xxx, just change \S (non white-space characters) for the desired group. Demands one initial "xxx.", any number of intermediate "xxx." groups and a final "xxx" group.
# ID: 3345
^(\S+\.{1})(\S+\.{1})*([^\s\.]+\s*)$

# Pattern for testing a jdbc db2 url (Type 4). Format jdbc:db2://<ServerName><Port>/<DatabaseName>
# ID: 1508
^jdbc:db2://((?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))|(?:(?:(?:(?:[A-Z|a-z])(?:[\w|-]){0,61}(?:[\w]?[.]))*)(?:(?:[A-Z|a-z])(?:[\w|-]){0,61}(?:[\w]?)))):([0-9]{1,5})/([0-9|A-Z|a-z|_|#|$]{1,16})$

# Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.
# ID: 605
^(?!\d[1]{2}|[5]{3})([2-9]\d{2})([. -]*)\d{4}$

# IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression ("::") or mixed IPv4 addresses.
# ID: 829
^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$

# La tua classe minus abiti styilsh giubbini Moncler può essere utile a new persone che siamo. Grazie alla sua colori vivaci, style and design speciali, materiale accuratamente selezionato electronic di qualità, giubbotti Moncler ' attirato un gran numero to promptl attenzioni della gente. Riflettente tessuto vernice Moncler vestiti presa elettrica, dando sempre più da la sensazione di buona qualità. Così forte havin tutto, sia risultato materiale di straordinario, così avremo un armadio throughout un paio di.
# ID: 3357
Spaccio Moncler,Piumini Moncler,Moncler Piumino,Moncler Giubbotti,Moncler Negozio,Moncler 2011

# Jordan mobile numbers, Zain,Umniah and Orange provider .
# ID: 3536
((079)|(078)|(077)){1}[0-9]{7}

# Password of 6 symbols. Must containt at leats one non-captial letter and at least digit digit
# ID: 2430
^(?=.{6,})(?=.*[0-9].*)(?=.*[a-z].*).*$

# This regular expression can be used to extract titles from web page
# ID: 2584
<title>(.*?)</title>

# Any java script from web page can be extracted using the regular expression
# ID: 2585
<script[\\.|\\W|\\w]*?</script>

# this regular expression can be used to replace white space between words
# ID: 2586
([ ]?[\\*~`!@#\\%\\^\\*\\(\\)_\\-\"\"':;\\,\\.\\?\\-\\+\\{\\}\\/\\& ][ ]?|\\b)

# Using this regular expression feedback score can be extracted
# ID: 2587
\\(+\\d{3}|\\d{2}|\\d{1}\\)?

# this regular expression can be used to extract the date from webpage
# ID: 2588
\\s\\d{2}[-]\\w{3}-\\d{4}

# this regular expression can be used to extract country code from web page
# ID: 2589
\\[\\w{2}\\]

# All the prices available in web page can be extracted
# ID: 2590
\\$\\d+[.]?\\d*

# the comments on html page can be extracted or removed.
# ID: 2591
<!--[\\.|\\W|\\w]*?-->

# Matching pattern like
# ID: 2592
(\\d{1}-\\d{2}\\s*)(of +)(\\s?\\d{5})|(\\d{1}-\\d{2}\\s*)(of +)(\\s?\\d{4})|(\\d{1}-\\d{2}\\s*)(of +)(\\s?\\d{3})|(\\d{1}-\\d{2}\\s*)(of +)(\\s?\\d{2})|(\\d{1}-\\d{2}\\s*)(of +)(\\s?\\d{1})

# http://www.sell.com/23D2RQ
# ID: 2593
href\\s*=\\s*\\\"((\\/)([\\w\\-\\.,@?~\\+#]+)*)\\\

# 82d 10h
# ID: 2594
\d{1,2}d \d{1,2}h

# this regular expression can be used to validate the existance of double quotes
# ID: 2695
^[^\"]+$

# css definition split on space or comma but keep "" enclosed items for string like
# ID: 2696
\s*("[^"]+"|[^ ,]+)

# match http urls in format
# ID: 2344
(http):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+(\\.[\\w\\-_]+)(\\/)([\\w\\-\\.,@?^=%&:/~\\+#]*[\\w\\-\\@?^=%&/~\\+#]+)(\\/)((\\d{8}-)|(\\d{9}-)|(\\d{10}-)|(\\d{11}-))+([\\w\\-\\.,@?^=%&:/~\\+#]*[\\w\\-\\@?+html^])?

# While screen scraping to validate if Next page exists
# ID: 2345
(\d)+\<\/a\>

# pattern matching for "href=\ddd\ss080978"
# ID: 2349
href\s*=\s*\"((\/)([i])(\/)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#]+)*)\"

# Valiation of Email Address based on Wiki\Email_Address
# ID: 3623
/^[-a-z0-9~!$%^&*_=+}{\'?]+(\.[-a-z0-9~!$%^&*_=+}{\'?]+)*@([a-z0-9_][-a-z0-9_]*(\.[-a-z0-9_]+)*\.(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|mobi|[a-z][a-z])|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(:[0-9]{1,5})?$/i

# This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module).
# ID: 3624
^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$

# This regex matches 'http://' optionally followed by 'www.' then starts a group and matches one or more of any character that is not a full stop/period (.) closes the group then matches '.com'.
# ID: 2979
http://(www\.)?([^\.]+)\.com

# regex which matches UAE mobile phone numbers.
# ID: 658
^(\+97[\s]{0,1}[\-]{0,1}[\s]{0,1}1|0)50[\s]{0,1}[\-]{0,1}[\s]{0,1}[1-9]{1}[0-9]{6}$

# The regex matches the UAE land phone numbers. Checks the area codes[04,02,06...etc] strictly. Force user to input phone numbers in strict manner(it take input 04 3452488, but not 04______spaces_______3452488)
# ID: 659
^0[234679]{1}[\s]{0,1}[\-]{0,1}[\s]{0,1}[1-9]{1}[0-9]{6}$

# The regex that matches the telephone numbers in India.
# ID: 661
^0{0,1}[1-9]{1}[0-9]{2}[\s]{0,1}[\-]{0,1}[\s]{0,1}[1-9]{1}[0-9]{6}$

# The Regex validate the mobile numbers in India.
# ID: 662
^((\+){0,1}91(\s){0,1}(\-){0,1}(\s){0,1}){0,1}98(\s){0,1}(\-){0,1}(\s){0,1}[1-9]{1}[0-9]{7}$

# I wanted to get the original size of an image placed into a Wordpress post. This should find the resized image dimensions, from here you should be able to manipulate the size of the image of remove the dimesions to get the image untouched
# ID: 2738
-[0-9]*[x][0-9]*

# identity card(cn)
# ID: 3149
^((11|12|13|14|15|21|22|23|31|32|33|34|35|36|37|41|42|43|44|45|46|50|51|52|53|54|61|62|63|64|65|71|81|82|91)\d{4})((((((19|20)(([02468][048])|([13579][26]))0229))|((20[0-9][0-9])|(19[0-9][0-9]))((((0[1-9])|(1[0-2]))((0[1-9])|(1\d)|(2[0-8])))|((((0[1,3-9])|(1[0-2]))(29|30))|(((0[13578])|(1[02]))31))))((\d{3}(x|X))|(\d{4})))|((((([02468][048])|([13579][26]))0229)|(\d{2}((((0[1-9])|(1[0-2]))((0[1-9])|(1\d)|(2[0-8])))|(((0[1,3-9])|(1[0-2]))(29|30))|(((0[13578])|(1[02]))31))))\d{3}))$

# Limits the max number of digits before the decimal point to 10; if decimal point is entered, requires entry of 2 decimal places. Allows for an optional negative sign. This pattern was derived to meet the maximum number of digits that can be stored in a decimal data type in SQL Server 2005, and allows for the way SQL Server appends the decimal places.  The column in the table is defined as decimal(12,2).
# ID: 2453
^[-]?\d{1,10}\.?([0-9][0-9])?$

# Regular expression to match a canadian postal code where it matches a string with or without the hyphen and in upercase or lowercase
# ID: 307
^([A-Za-z]\d[A-Za-z][-]?\d[A-Za-z]\d)

# Attempt to validate email addresses. Does not support name <host@domain.com> format or ip addresses
# ID: 1094
^(([_\w-+!#$%&'*/=?^`{}|~]+(\.[_\w-+!#$%&'*/=?^`{}|~]+)*)|("([ _\w-+!#$%&'*/=?^`{}|~]+(\.[ _\w-+!#$%&'*/=?^`{}|~]+)*)"))@[\w-]{1,63}(\\.[\w-]{1,63})*(\.[_\w-]{2,6})$

# Validate the Wii Code format. If you like to have slashes and spaces you can change the "\s" for "[\s-]"
# ID: 2798
\d{4}\s\d{4}\s\d{4}\s\d{4}$

# US Phone number that accept a dot, a space, a dash, a forward slash, between the numbers. Will Accept a 1 or 0 in front.  Area Code not necessary
# ID: 61
((\(\d{3}\)?)|(\d{3}))([\s-./]?)(\d{3})([\s-./]?)(\d{4})

# Any Expression Upper/Lower Case, with commas and space between the text, with any amount of space before or after
# ID: 62
^\s*[a-zA-Z,\s]+\s*$

# ANY alphanumeric string with spaces, commas, dashes.
# ID: 63
^[a-zA-Z0-9\s.\-]+$

# This expression matches only valid html anchors. Those are anchors with an attribute name=. Such anchor can be closed either with </a> or with />.
# ID: 1124
<a[a-zA-Z0-9 ="'.:;?]*(name=){1}[a-zA-Z0-9 ="'.:;?]*\s*((/>)|(>[a-zA-Z0-9 ="'<>.:;?]*</a>))

# An expression that matches all XHTML valid hrefs (links). It even alows spaces like href = "href...", dough this is not quite XHTML valid. It finds only hrefs but not for instance anchors. If you need to find only anchors, replace "href" within expression with "name" and thats it.
# ID: 1128
<a[a-zA-Z0-9 ="'.?_/]*(href\s*=\s*){1}[a-zA-Z0-9 ="'.?_/]*\s*((/>)|(>[a-zA-Z0-9 ="'<>.?_/]*</a>))

# This is a fairly forgiving phone number match. It's original purpose was to extract phone numbers from the details field in our database and into their own phone number table. It worked brilliantly. Enjoy!
# ID: 1497
^(1?)(-| ?)(\()?([0-9]{3})(\)|-| |\)-|\) )?([0-9]{3})(-| )?([0-9]{4}|[0-9]{4})$

# Password validator
# ID: 1072
^(?=.*\d)(?=.*[a-zA-Z])(?!.*[\W_\x7B-\xFF]).{6,15}$

# Tokenize a Javascript document for parsing
# ID: 2179
(\/\*[\s\S.]+?\*\/|[/]{2,}.*|\/((\\\/)|.??)*\/[gim]{0,3}|'((\\\')|.??)*'|"((\\\")|.??)*"|-?\d+\.\d+e?-?e?\d*|-?\.\d+e-?\d+|\w+|[\[\]\(\)\{\}:=;"'\-&!|+,.\/*])

# match the common email format
# ID: 2969
(\w+[\.\_\-]*)*\w+@[\w]+(.)*\w+$

# Matches full textual date formats. Case insensitive, optional commas, short and long weekdays and months, optional weekdays, optional leading zeros in date.
# ID: 3479
(?i)((sun(day)?|mon(day)?|tue(sday)?|wed(nesday)?|thu(rsday)?|fri(day)?|sat(urday)?),?\s)?((jan(uary)?|feb(ruary)?|mar(ch)?|apr(il)?|may|jun(e)?|jul(y)?|aug(ust)?|sep(tember)?|oct(ober)?|nov(ember)?|dec(ember)?)\s)+((0?[1-9]|[1-2][0-9]|3[0-1]),?\s)+([1-2][0-9][0-9][0-9])

# Searches for number greater than 0 with thousand delimiter as space, comma or period.
# ID: 1282
(^(\d+)$)|(^(\d{1,3}[ ,\.](\d{3}[ ,\.])*\d{3}|\d{1,3})$)

# This RegEx can be used to varify (esp. when receiving data from forms) filenames. No Path is allowed. German Special Characters are allowed.
# ID: 805
^[\w0-9äÄöÖüÜß\-_]+\.[a-zA-Z0-9]{2,6}$

# Matches all currently known positive and negative blood groups, i.e. A+, A-, B+, B-, O+, O-, AB+, AB-
# ID: 2671
/(A|B|AB|O)[+-]/

# When removing any whitespace from something like an excel formula, you need to strip the whitespace from around cell references or other non-quoted strings, while leaving quoted (both single and double quotes) in tact.  It even works when another different quote, or double quote is embedded in the string.  You can execute this with a replacement group $1 to replace the spaces with another character (or empty string to remove the spaces).  Does not match if the quoted string spans multiple lines (if \r\n is inside the quoted string)
# ID: 1852
(?:\s+)|((?:"(?:.+?)")|(?:'(?:.+?)'))

# This regular expression will parse an ISO8601 date into it's individual parts.
# ID: 2675
(\d\d\d\d)-?(\d\d)-?(\d\d)T?(\d\d):?(\d\d)(?::?(\d\d)(\.\d+)*?)?(Z|[+-])(?:(\d\d):?(\d\d))?

# This regex will validate a GUID. If the GUID starts with an opening curly bracket, then it must also end in a closing curly bracket. If it does not start with one, then it must not end with one.
# ID: 2733
((^[{])|^)[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}(?(2)[}]$|$)

# This RegEx validates a GUID number with or without curly brackets. But requires both brackets if any is provided. This version is compatible with VBScript's RegEx engine
# ID: 2734
^[{][A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}[}]$|^[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}$

# This RegEx will validate a password that has at least 4 non-alphanumeric characters in it. The characters do not need to be adjacent.
# ID: 2565
^(?=.*(\W.*){4,}).*$

# This regular expression is used to replace all spaces between words that are not within quotes or already next to AND|OR|AND NOT
# ID: 2601
(?<!and\snot|and|not|or)\s+(?!(and\snot|or|-)|([^"]*"[^"]*")*[^"]*"[^"]*$)

# RegEx parses out all whole words, phrases within quotes or parentheses.
# ID: 2602
\"[^"]+\"|\([^)]+\)|[^\"\s\()]+

# This regex will match all words in a search term entered by a user. This ignores words within double quotes and also ignores the words "AND" "OR" or "NOT". I use this to add double quotes around each word for full text query building.
# ID: 2603
(?!\bnot\b|\band\b|\bor\b|\b\"[^"]+\"\b)((?<=\s|\-|\(|^)[^\"\s\()]+(?=\s|\*|\)|$))

# Use this regular expression to find any invalid characters within a DOS 8.3 Directory or Folder name.
# ID: 2273
[^ _0-9a-zA-Z\$\%\'\-\@\{\}\~\!\#\(\)\&\^]

# RegEx will match phrases in double-quotes or words separated by spaces. It excludes the double-quotes from matches
# ID: 2295
(?<=(?:^|\s|,)")[^"]*?(?=")|(?<=\s|^)(?!")[\w\W]+?(?=\s|$)

# This regular expression can be used to validate a strong password. It will evaluate to true if the following critera are met:
# ID: 2284
^(?=^.{8,}$)(?=.*\d)(?=.*\W+)(?=.*[a-z])(?=.*[A-Z])(?i-msnx:(?!.*pass|.*password|.*word|.*god|.*\s))(?!^.*\n).*$

# This regex will match all HTML tags except 'a' tags or 'img' tags. You can edit the list of exclusions as you see fit. I use this regex to strip all HTML tags from source data except anchor tags and image tags.
# ID: 2289
<\/*?(?![^>]*?\b(?:a|img)\b)[^>]*?>

# This regular expression will match only <script> and <style> tags and all content between them. Use this with regex.replace to strip script blocks and style blocks from HTML source.
# ID: 2290
<(script|style)[^>]*?>(?:.|\n)*?</\s*\1\s*>

# This regex is used to test if a word contains alpha-numeric characters, including accent characters
# ID: 3347
[a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u01FF]

# Validate alpha-numeric international names with no more than one space between them
# ID: 3286
^([\u00c0-\u01ffa-zA-Z'\-]+[ ]?[\u00c0-\u01ffa-zA-Z'\-]*)+$

# Belgian Carenet message Alphanumerical field - as described in the 'programmer's guide for carenet - Belgacom'.
# ID: 1093
^[ .a-zA-Z0-9:-]{1,150}$

# Needing a way to shrink HTML based email to the smallest amount of characters, we wanted to remove any extra unnecessary white space characters in attributes such as style.  This finds any space with a proceeding comma, semi-colon, or colon, and then checks with a lookahead for the closing > with a negative lookbehind to make sure that a < opening does not exist.  The secondary trailing look behind is done to make sure that it does not change any content contained in the element.
# ID: 3101
(?<=(,|;|:))\s(?=((?:(?!<).)*>))

# This accepts RFC 2822 email addresses in the form:<br>
# ID: 711
^((?>[a-zA-Z\d!#$%&'*+\-/=?^_`{|}~]+\x20*|"((?=[\x01-\x7f])[^"\\]|\\[\x01-\x7f])*"\x20*)*(?<angle><))?((?!\.)(?>\.?[a-zA-Z\d!#$%&'*+\-/=?^_`{|}~]+)+|"((?=[\x01-\x7f])[^"\\]|\\[\x01-\x7f])*")@(((?!-)[a-zA-Z\d\-]+(?<!-)\.)+[a-zA-Z]{2,}|\[(((?(?<!\[)\.)(25[0-5]|2[0-4]\d|[01]?\d?\d)){4}|[a-zA-Z\d\-]*[a-zA-Z\d]:((?=[\x01-\x7f])[^\\\[\]]|\\[\x01-\x7f])+)\])(?(angle)>)$

# This expression is a very simplex expression that allows null values or 3 digits, dash, 3 digits, dash, 4 digits. It validates a basic US phone number. Written by Jason N. Gaylord.
# ID: 701
^(\d{3}-\d{3}-\d{4})*$

# This expression is a simplex expression that checks to see if a value is a valid phone system terminal number. It allows a null value or 2 digits, dash, 2 digits. Written by Jason N. Gaylord.
# ID: 702
^(\d{2}-\d{2})*$

# This matches the specific value for a unique identifier (GUID) from SQL server. Written by Jason N. Gaylord.
# ID: 815
\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\}

# This regex is to validate the time of a ~60 minute CD where the most time on the CD is 59:59 (minutes:seconds). It is derived from Ken Madden's time regex for a project for Erik Porter (Windows/Web guru). Written by Jason Gaylord.
# ID: 271
^(([0]?[0-5][0-9]|[0-9]):([0-5][0-9]))$

# I modified the existing phone number regex for another user looking to only allow 082, 083, 084, or 072 exchanges. Written by Jason Gaylord
# ID: 315
^\(?082|083|084|072\)?[\s-]?[\d]{3}[\s-]?[\d]{4}$

# This validates the states and territories of the United States in a 2 character uppercase format. Very poor excuse for a regular expression!  ;)
# ID: 396
^((AL)|(AK)|(AS)|(AZ)|(AR)|(CA)|(CO)|(CT)|(DE)|(DC)|(FM)|(FL)|(GA)|(GU)|(HI)|(ID)|(IL)|(IN)|(IA)|(KS)|(KY)|(LA)|(ME)|(MH)|(MD)|(MA)|(MI)|(MN)|(MS)|(MO)|(MT)|(NE)|(NV)|(NH)|(NJ)|(NM)|(NY)|(NC)|(ND)|(MP)|(OH)|(OK)|(OR)|(PW)|(PA)|(PR)|(RI)|(SC)|(SD)|(TN)|(TX)|(UT)|(VT)|(VI)|(VA)|(WA)|(WV)|(WI)|(WY))$

# It is the exact phone number regular expression for '(###) ###-####'.
# ID: 397
^([\(]{1}[0-9]{3}[\)]{1}[ ]{1}[0-9]{3}[\-]{1}[0-9]{4})$

# Match any percentage entered between 0.00 and 100.00%, includes up to 2 decimal places. Percent sign is optional
# ID: 2324
^100(\.0{0,2})? *%?$|^\d{1,2}(\.\d{1,2})? *%?$

# Match any percent from -100.00% to +100.00% up to 2 decimla places. Percent sign is optional
# ID: 2325
^[+-]? *100(\.0{0,2})? *%?$|^[+-]? *\d{1,2}(\.\d{1,2})? *%?$

# Full currency testing, allows up to 2 decimal places.  Checks for corect formatting with commas etc, and allows negative amounts
# ID: 2326
^[+-]? *(\$)? *((\d+)|(\d{1,3})(\,\d{3})*)(\.\d{0,2})?$

# Validates against a U.S. postal code in either a 5 digit format or a 5 dash 4 format.
# ID: 946
^([0-9]{5})([\-]{1}[0-9]{4})?$

# Validate against a visa card number. All visa cards start with a 4 and are followed by 12 to 15 more numbers.
# ID: 947
^([4]{1})([0-9]{12,15})$

# Validate against any mastercard number. All MC's start with a number between 51 and 55 and are followed by 14 other numbers.
# ID: 948
^([51|52|53|54|55]{2})([0-9]{14})$

# Validate against any american express number. All american express numbers start with either a 34 or 37, followed by 13 other numbers.
# ID: 949
^([34|37]{2})([0-9]{13})$

# Validate against any discover card number. All DC's start with 6011 and are followed by 12 other numbers.
# ID: 950
^([6011]{4})([0-9]{12})$

# Validate against any diner's club card. All diner club cards start with 30,36, or 38, followed by 12 other numbers.
# ID: 951
^([30|36|38]{2})([0-9]{12})$

# Parses out the elements of a date in ISO 8601 format.
# ID: 1376
(?<Date>(?<Year>\d{4})-(?<Month>\d{2})-(?<Day>\d{2}))(?:T(?<Time>(?<SimpleTime>(?<Hour>\d{2}):(?<Minute>\d{2})(?::(?<Second>\d{2}))?)?(?:\.(?<FractionalSecond>\d{1,7}))?(?<Offset>-\d{2}\:\d{2})?))?

# Validates dutch (european) date and time combination (dd-mm-yyyy). Dates are accepted, date and time is accepted. The time notation (hh:mm:ss) may or may not contain a value for seconds
# ID: 2933
^([3]{1}[0-1]{1}|[1-1]?[0-9]{1})-([0-1]?[0-2]{1}|[0-9]{1})-[0-9]{4}([\s]+([2]{1}[0-3]{1}|[0-1]?[0-9]{1})[:]{1}([0-5]?[0-9]{1})([:]{1}([0-5]?[0-9]{1}))?)?$

# Matches BBCode, non-recursive. You must recursively run the pattern with each resulting subpattern to get all the tag.
# ID: 1644
(\[([^/].*?)(=(.+?))?\](.*?)\[/\2\]|\[([^/].*?)(=(.+?))?\])

# This will match the VB-style quoted string. That means to use " in the quoted string you must use "" instead.
# ID: 1645
"(""|[^"])*"

# This time is for C-Style Quoted String matching. So to use " in the quoted string you need to use \" and if you wanted to use \ in your string, use \\.
# ID: 1646
"(\\.|[^"])*"

# Based on Michael Ash's expression. This regex will validate only datetime, not only date or only time. Dates are in the DD/MM/YYYY HH:mm format and validated for months, number of days in a month and leap years (29/2) Date field can be separated by matched periods(.), dashes(-) or forward slashes(/). Year range 1900-9999 Time is in 24 hour military format (HH:mm:SS), from 00:00:00 to 23:59:59, where hours and minutes fields are required, including leading 0 for hours less than 10. Datetime is the above date and time formats separated by a space, with the date first (DD/MM/YYYY HH:mm) !IMPORTANT NOTE: your regex engine must support lookaheads and named groups to use this expression
# ID: 1418
(?n:^(?=\d)((?<day>31(?!(.0?[2469]|11))|30(?!.0?2)|29(?(.0?2)(?=.{3,4}(19|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00))|0?[1-9]|1\d|2[0-8])(?<sep>[/.-])(?<month>0?[1-9]|1[012])\2(?<year>(19|[2-9]\d)\d{2})(?:(?=\x20\d)\x20|$))?(?<time>([01]\d|2[0-3])(:[0-5]\d){1})$)

# Validate Filename,PageName,ImageName etc
# ID: 2464
([a-zA-Z1-9]*)\.(((a|A)(s|S)(p|P)(x|X))|((h|H)(T|t)(m|M)(l|L))|((h|H)(t|T)(M|m))|((a|A)(s|S)(p|P))|((t|T)(x|X)(T|x))|((m|M)(S|s)(P|p)(x|X))|((g|G)(i|I)(F|f))|((d|D)(o|O)(c|C)))

# This pattern will match all dates from the year 1900 to 2099, invalid dates like 0000-00-00 will not be accepted.
# ID: 890
(?<Year>(19|20)[0-9][0-9])-(?<Month>0[1-9]|1[0-2])-(?<Day>0[1-9]|[12][0-9]|3[01])

# Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric .This will be usefull in money related
# ID: 368
^([0-9]*|\d*\.\d{1}?\d*)$

# This expression is an improved version of Jörg Maag. It checks a date field in the Australian DD/MM/YYYY format. Besides, it also validates leap year between 1900 and 2099.
# ID: 708
^(((((0[1-9])|(1\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((20[0-9][0-9]))|((((0[1-9])|(1\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((19[0-9][0-9]))|(29/02/20(([02468][048])|([13579][26])))|(29/02/19(([02468][048])|([13579][26]))))$

# Regular expression for vehicle registration number according to these formats:
# ID: 3303
^([A-Z]{3,20}\s?[A-Z]{2}[0-9]{1,3}-([A-Z]{3}|[A-Z]{1}[0-9]{2}))|([A-Z]{1,20}\s[A-Z]{1,2}[0-9]{1,4}-[A-Z]{1,3})|([\d,\w,\s]{1,20}\s[A-Z]{3}-[0-9]{1,3})|([A-Z]{1,20}\s?[\d,\w,\s]{1,20})$

# Matches:
# ID: 3392
(\d{5}-\d{4}|\d{5})

# Phone numbers validation with extension number
# ID: 1751
(((\d{0,2})\(\d{3}\))|(\d{3}-))\d{3}-\d{4}\s{0,}((([Ee][xX][Tt])|([Pp][Oo][Ss][Tt][Ee])):\d{1,5}){0,1}

# This is very useful if you dont want your employees to send encrypted mail, or downloading public keys from HTTP. It also catches certficates, CSR and other useless stuff that is only used to hide data from antivirus programs and such things.
# ID: 1904
(.*)-----(BEGIN|END)([^-]*)-----(.*)

# Matches US currency input with or without commas.  This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the . (period) to ensure that no other characters may be used in it's place.
# ID: 130
^\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(\.[0-9][0-9])?$

# This is my combination of other UK postcode examples to date in this library. This is similar to Howard Richards’s solution in that it only permits valid combinations of letters, e.g. BN works, BM does not. The space(s) are optional, and the string to match does not have to be in an upper or lower case. On top of that this allows BFPO (http://www.bfpo.mod.uk/bfponumbers_ships.htm) and Overseas Territories Postcodes (http://en.wikipedia.org/wiki/UK_postcodes) Please let me know if you have any suggetion to improve this!
# ID: 2007
(^[Bb][Ff][Pp][Oo]\s*[0-9]{1,4})|(^[Gg][Ii][Rr]\s*0[Aa][Aa]$)|([Aa][Ss][Cc][Nn]|[Bb][Bb][Nn][Dd]|[Bb][Ii][Qq][Qq]|[Ff][Ii][Qq][Qq]|[Pp][Cc][Rr][Nn]|[Ss][Ii][Qq][Qq]|[Ss][Tt][Hh][Ll]|[Tt][Dd][Cc][Uu]\s*1[Zz][Zz])|(^([Aa][BLbl]|[Bb][ABDHLNRSTabdhlnrst]?|[Cc][ABFHMORTVWabfhmortvw]|[Dd][ADEGHLNTYadeghlnty]|[Ee][CHNXchnx]?|[Ff][KYky]|[Gg][LUYluy]?|[Hh][ADGPRSUXadgprsux]|[Ii][GMPVgmpv]|[JE]|[je]|[Kk][ATWYatwy]|[Ll][ADELNSUadelnsu]?|[Mm][EKLekl]?|[Nn][EGNPRWegnprw]?|[Oo][LXlx]|[Pp][AEHLORaehlor]|[Rr][GHMghm]|[Ss][AEGK-PRSTWYaegk-prstwy]?|[Tt][ADFNQRSWadfnqrsw]|[UB]|[ub]|[Ww][A-DFGHJKMNR-Wa-dfghjkmnr-w]?|[YO]|[yo]|[ZE]|[ze])[1-9][0-9]?[ABEHMNPRVWXYabehmnprvwxy]?\s*[0-9][ABD-HJLNP-UW-Zabd-hjlnp-uw-z]{2}$)

# This is my combination of other UK postcode examples to date in this library. This is similar to Howard Richards’s solution in that it only permits valid combinations of letters, e.g. BN works, BM does not. The space(s) are optional, the string to match should be in upper case. On top of that, this solution allows BFPO (http://www.bfpo.mod.uk/bfponumbers_ships.htm) and Overseas Territories Postcodes (http://en.wikipedia.org/wiki/UK_postcodes) Please let me know if you have any suggetion to improve this!
# ID: 2008
(^BFPO\s*[0-9]{1,4})|(^GIR\s*0AA$)|(ASCN|BBND|BIQQ|FIQQ|PCRN|SIQQ|STHL|TDCU\s*1ZZ)|(^(A[BL]|B[ABDHLNRST]?|C[ABFHMORTVW]|D[ADEGHLNTY]|E[CHNX]?|F[KY]|G[LUY]?|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]?|M[EKL]?|N[EGNPRW]?|O[LX]|P[AEHLOR]|R[GHM|S[AEGK-PRSTWY]?|Y[ADFNQRSW|UB|W[A-DFGHJKMNR-W]?|[YO]|[ZE])[1-9][0-9]?[ABEHMNPRVWXY]?\s*[0-9][ABD-HJLNP-UW-Z]{2}$)

# Matches spanish postcodes
# ID: 1164
^([0][1-9]|[1-4[0-9]){2}[0-9]{3}$

# Expression for matching andorran postcodes
# ID: 1170
^([A-Z]{2}[0-9]{3})|([A-Z]{2}[\ ][0-9]{3})$

# Expression to test for valid postcodes for azerbaijan
# ID: 1171
^[A][Z](.?)[0-9]{4}$

# Simple postcode validation for postcodes for bahrain
# ID: 1172
^([1][0-9]|[0-9])[1-9]{2}$

# Simple expression to validate bangladeshi postcodes
# ID: 1173
^[1-9][0-9]{3}$

# Simple validation expression for postcodes for Belarus
# ID: 1174
^[0-9]{6}$

# An expression to validate postcodes for bermuda
# ID: 1175
^([A-Z]{2}[\s]|[A-Z]{2})[\w]{2}$

# This is a simple expression to validate postcodes from Brunei
# ID: 1176
^[B|K|T|P][A-Z][0-9]{4}$

# Simple Postcode validation expression for Chile
# ID: 1177
^[0-9]{3}[-][0-9]{4}$

# Simple expression for internationally formatted croatian postcodes.
# ID: 1178
^[H][R][\-][0-9]{5}$

# Simple validation expression for cyprus postcodes
# ID: 1179
^[0-9]{4}$

# Simple expression to validate postcodes for the faroe islands
# ID: 1183
^[F][O][\s]?[0-9]{3}$

# Simple validation expression for postcodes in guadeloupe
# ID: 1185
^[9][7|8][1|0][0-9]{2}$

# This is a simple expression for testing postcodes in Guinea
# ID: 1186
^[0-4][0-9]{2}[\s][B][P][\s][0-9]{3}$

# this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1900-2999, and all 2 digits years except 00
# ID: 3180
^(((19|2\d)\d{2}\/(((0?[13578]|1[02])\/31)|((0?[1,3-9]|1[0-2])\/(29|30))))|((((19|2\d)(0[48]|[2468][048]|[13579][26])|(2[048]00)))\/0?2\/29)|((19|2\d)\d{2})\/((0?[1-9])|(1[0-2]))\/(0?[1-9]|1\d|2[0-8]))$

# this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00
# ID: 3181
^(((1[6-9]|[2-9]\d)\d{2}\/(((0?[13578]|1[02])\/31)|((0?[1,3-9]|1[0-2])\/(29|30))))|((((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))\/0?2\/29)|((1[6-9]|[2-9]\d)\d{2})\/((0?[1-9])|(1[0-2]))\/(0?[1-9]|1\d|2[0-8]))$

# this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00
# ID: 3182
^(((1[6-9]|[2-9]\d)\d{2}([-|\/])(((0?[13578]|1[02])([-|\/])31)|((0?[1,3-9]|1[0-2])([-|\/])(29|30))))|((((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\/])0?2([-|\/])29)|((1[6-9]|[2-9]\d)\d{2})([-|\/])((0?[1-9])|(1[0-2]))([-|\/])(0?[1-9]|1\d|2[0-8]))$

# this expression validates a date-time field in yyyy/m/d h:m:s or yyyy-m-d h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00.
# ID: 3183
^(((1[6-9]|[2-9]\d)\d{2}([-|\/])(((0?[13578]|1[02])([-|\/])31)|((0?[1,3-9]|1[0-2])([-|\/])(29|30))))|((((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\/])0?2([-|\/])29)|((1[6-9]|[2-9]\d)\d{2})([-|\/])((0?[1-9])|(1[0-2]))([-|\/])(0?[1-9]|1\d|2[0-8]))(\s)((([0]?[1-9]|1[0-2])(:|\.)[0-5][0-9]((:|\.)[0-5][0-9])?(\s)?([aApP][mM]))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\.)[0-5][0-9]((:|\.)[0-5][0-9])?))$

# Date Time with am/pm.
# ID: 2435
^([0]\d|[1][0-2]\/([0-2]\d|[3][0-1])\/([2][0]\d{2})\s([0-1]\d|[2][0-3])\:[0-5]\d\:[0-5]\d)?\s(AM|am|aM|Am|PM|pm|pM|Pm)

# Matches a currency value (without currency symbol) using , for decimal digits separator
# ID: 3548
^\d+(\,\d{1,2})?$

# Just a simple regExp to parse the stack trace.  Developed when using the exception block from MS, coz they only showed the stack all bunched together.  Could be used as follows:
# ID: 337
(at\s)(?<fullClassName>.+)(\.)(?<methodName>[^\.]*)(\()(?<parameters>[^\)]*)(\))((\sin\s)(?<fileName>.+)(:line )(?<lineNumber>[\d]*))?

# This could be most complete and readable URL-finder regex. I built it from several good examples. Works with PHP preg_match_all(). Finds whatever string that resembles a URL with scheme://, user:password, subdomains.domain (with up to 6 chars top-domain) or IP address xxx.xxx.xxx.xxx, :port, /file/path/, ?request, and #anchor
# ID: 3126
/((https?|ftp)\:\/\/)?([a-z0-9+!*(),;?&=\$_.-]+(\:[a-z0-9+!*(),;?&=\$_.-]+)?@)?(([a-z0-9-.]*)\.([a-z]{2,6}))|(([0-9]{1,3}\.){3}[0-9]{1,3})(\:[0-9]{2,5})?(\/([a-z0-9+\$_-]\.?)+)*\/?(\?[a-z+&\$_.-][a-z0-9;:@&%=+\/\$_.-]*)?(#[a-z_.-][a-z0-9+\$_.-]*)?/i

# IPV4 and IPV6 address
# ID: 2866
^(((([1]?\d)?\d|2[0-4]\d|25[0-5])\.){3}(([1]?\d)?\d|2[0-4]\d|25[0-5]))|([\da-fA-F]{1,4}(\:[\da-fA-F]{1,4}){7})|(([\da-fA-F]{1,4}:){0,5}::([\da-fA-F]{1,4}:){0,5}[\da-fA-F]{1,4})$

# I'm very new to reg exp
# ID: 2282
^(((\\\\([^\\/:\*\?"\|<>\. ]+))|([a-zA-Z]:\\))(([^\\/:\*\?"\|<>\. ]*)([\\]*))*)$

# This expression will match the corresponding XML/HTML elements opening and closing tags. Useful to handle documents fragments, without loading an XML DOM.
# ID: 182
<[^>\s]*\bauthor\b[^>]*>

# Matches .NET assembly names, and captures named groups for easy parsing and constructing of an AssemblyName object.
# ID: 885
^(?<assembly>[\w\.]+)(,\s?Version=(?<version>\d+\.\d+\.\d+\.\d+))?(,\s?Culture=(?<culture>\w+))?(,\s?PublicKeyToken=(?<token>\w+))?$

# Based on the pattern from Ricardo Gonzalez.  This one allows for arbitrary space between  parts of the phone number and separates the parts out into different capture groups.
# ID: 1811
[+]?[\x20]*(?<int>\d+)?[-\x20]*[\(]?(?<area>[2-9]\d{2})[\)\-\x20]*(?<pbx>[0-9]{3})[-\x20]*(?<num>[0-9]{4})

# This RegExp is degigned to mach SQL OLEDB Connection String to the Named Groups Properties useful for .Net              MATCH EXAMPLE(the submition field is too short):Provider="SQLOLEDB.1";Data Source=(local);Initial Catalog=master;User ID=sa;Password="SA_PASS";Connection TimeOut=90
# ID: 896
(?:Provider="??(?<Provider>[^;\n]+)"??[;\n"]??|Data\sSource=(?<DataSource>[^;\n]+)[;\n"]??|Initial\sCatalog=(?<InitialCatalog>[^;\n]+)[;\n"]??|User\sID=(?<UserID>[^;\n]+)[;\n"]??|Password="??(?<Password>[^;\n]+)"??[;\n"]??|Integrated\sSecurity=(?<IntegratedSecurity>[^;\n]+)[;\n]??|Connection\sTimeOut=(?<ConnectionTimeOut>[^;\n]+)[;\n"]??)+$

# valid date base on Month
# ID: 325
^\d{2}\s{1}(Jan|Feb|Mar|Apr|May|Jun|Jul|Apr|Sep|Oct|Nov|Dec)\s{1}\d{4}$

# Parse html tags to extract tag names and parameters with parameter name/value pairs.
# ID: 1266
(?<TAG>\s*<(?<TAG_NAME>\w*)\s+(?<PARAMETERS>(?<PARAMETER>(?<PARAMETER_NAME>\w*)(=["']?)(?<VALUE>[\w\W\d]*?)["']?)+)\s*/?>)

# Porcentagem positiva de 0 a 100 com até 2 casas decimais, usando . (ponto) ou , (virgula).
# ID: 2847
^(100([\.\,]0{1,2})?)|(\d{1,2}[\.\,]\d{1,2})|(\d{0,2})$

# Matches the XSD schema duration built in type as defined by http://www.w3.org/TR/xmlschema-2/#duration
# ID: 1219
^[-]?P(?!$)(?:\d+Y)?(?:\d+M)?(?:\d+D)?(?:T(?!$)(?:\d+H)?(?:\d+M)?(?:\d+(?:\.\d+)?S)?)?$

# This will validate 12 hours time format with AM/am PM/pm
# ID: 3245
^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][ ][aApP][mM]){1}$

# This regexp is used to match c++,java,etc style multi-line and single line comments.
# ID: 776
(\/\*(\s*|.*?)*\*\/)|(\/\/.*)

# Matches most format of valid U.S. phone number. Only numbers whose first digit of area code is between 2 and 9 and whose country code is 1 would be matched. Does not match phones contain characters. See examples for more information.
# ID: 2927
(\+?1[- .]?)?[.\(]?[\d^01]\d{2}\)?[- .]?\d{3}[- .]?\d{4}

# Valida nros de CUIT y CUIL de la AFIP - Argentina. No valida el digito verificador
# ID: 2975
^(20|23|27|30|33)-[0-9]{8}-[0-9]$

# For Date format MM-JJ-YYYY validation
# ID: 364
^[\w-\.]+@([\w-]+\.)+[\w-]{2,3}$

# This RegExp makes sure a line in a log file matches the Apache Common log format:
# ID: 1085
\d{1,3}[.]\d{1,3}[.]\d{1,3}[.]\d{1,3}\s.\s.\s\[\d{2}\/\D{3}\/\d{4}:\d{1,2}:\d{1,2}:\d{1,2}\s.\d{4}\]\s\"\S*\s\S*\s\S*\"\s\d{1,3}\s\S*\s\".*\"\s\".*\"

# Matches any properly entered US phone number (area code, first three, last four) plus support for extensions (optional)
# ID: 1420
\(?\s*(?<area>\d{3})\s*[\)\.\-]?\s*(?<first>\d{3})\s*[\-\.]?\s*(?<second>\d{4})\D*(?<ext>\d*)

# I built this expression to validate a time input field.
# ID: 3142
^([1-9]|1[0-2]):[0-5]\d ?(a|A|p|P)(m|M)$

# This will match true if the string contians at least one HTML tag.
# ID: 1538
[\w*|\W*]*<[[\w*|\W*]*|/[\w*|\W*]]>[\w*|\W*]*

# RUC (Registro Único de Contribuyentes - ECUADOR). Valida la estructura definida por el SRI, mas no comprueba el dígito verificador. Sirve para entidades privadas, públicas, personas naturales y extranjeros.
# ID: 3155
^((0[1-9]|1[0-9]|2[0-4])[0-59]\\d{7}(00[1-9]|[0-9][1-9][0-9]|[1-9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-4])6\\d{6}(000[1-9]|[0-9][0-9][1-9][0-9]|[0-9][1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]))$

# Finds those pesky ascii characters that can be entered with the alt-numeric pad
# ID: 1912
[\x80-\xFF]

# For the terminally hard of thinking, a version of my UK postcode validator without WHITESPACE. Unlike most validators on regexlib, this knows valid postcode combinations, e.g. W1A is permitted, W1 is not, but W2 is. It should catch between 95-98% of invalid postcodes.
# ID: 1064
(((^[BEGLMNS][1-9]\d?)|(^W[2-9])|(^(A[BL]|B[ABDHLNRST]|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]|F[KY]|G[LUY]|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]|M[EKL]|N[EGNPRW]|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKL-PRSTWY]|T[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)\d\d?)|(^W1[A-HJKSTUW0-9])|(((^WC[1-2])|(^EC[1-4])|(^SW1))[ABEHMNPRVWXY]))(\s*)?([0-9][ABD-HJLNP-UW-Z]{2}))$|(^GIR\s?0AA$)

# Here it is, the monster UK Postcode regular expression that should prevent the majority of miskeying. Unlike an most other regexes it only permits valid combinations of letters, e.g. BN works, BM does not. Spaces between the first and second parts are optional. I have tested this against a file of 7,500 valid postcodes, and also against a real-world list of about 12,000 which had some bad data. Manually checking a sample of the rejected ones showed it was working correctly (and how poor the data was!!).
# ID: 1047
(((^[BEGLMNS][1-9]\d?) | (^W[2-9] ) | ( ^( A[BL] | B[ABDHLNRST] | C[ABFHMORTVW] | D[ADEGHLNTY] | E[HNX] | F[KY] | G[LUY] | H[ADGPRSUX] | I[GMPV] | JE | K[ATWY] | L[ADELNSU] | M[EKL] | N[EGNPRW] | O[LX] | P[AEHLOR] | R[GHM] | S[AEGKL-PRSTWY] | T[ADFNQRSW] | UB | W[ADFNRSV] | YO | ZE ) \d\d?) | (^W1[A-HJKSTUW0-9]) | ((  (^WC[1-2])  |  (^EC[1-4]) | (^SW1)  ) [ABEHMNPRVWXY] ) ) (\s*)?  ([0-9][ABD-HJLNP-UW-Z]{2})) | (^GIR\s?0AA)

# Matches all those Obfuscations which come in those pesky Emails. You will have to strip out all those HTML Remarks first in order to for this to work with the HTML Part of the Email
# ID: 853
((v|[\\/])\W*[i1]\W*[a@]\W*g\W*r\W*[a@]|v\W*[i1]\W*[c]\W*[o0]\W*d\W*[i1]\W*n)

# Validate if server and port is valid.
# ID: 2036
^(([A-Z])([a-zA-Z0-9]+)?)(\:)(\d+)$

# one or more numbers, asterisk, one or more numbers, asterisk, one or more numbers, no letters or punctuation other than asterisks.
# ID: 1730
^\d+\*\d+\*\d+$

# Captures an html anchors URL and Link Text.  Could be used to clean up formatting of links in an html document.
# ID: 1701
<a.+?href\=(?<link>.+?)(?=[>\s]).*?>(?<lnkText>.+?)</a>

# A blogger needed a regex to capture the text between style tags.
# ID: 1702
<style.*?>(?<StyledText>.*)<\s*?/\s*?style.*?>

# A co-worker needed a regex to validate time.  He could only find patterns that match a 24hour clock.  I whipped this expression up to validate a 12hour clock. Hope somebody finds it useful.
# ID: 685
(?<Time>^(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d(?:[ap]m)?)

# I needed a regular expression to break urls into labled parts.  This is what I came up with.  Got a few ideas from regexlib.com and from this msdn article. http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/reconbackreferences.asp
# ID: 628
# Multiline
(?:(?<protocol>http(?:s?)|ftp)(?:\:\/\/))(?:(?<usrpwd>\w+\:\w+)(?:\@))?(?<domain>[^/\r\n\:]+)?(?<port>\:\d+)?(?<path>(?:\/.*)*\/)?(?<filename>.*?\.(?<ext>\w{2,4}))?(?<qrystr>\??(?:\w+\=[^\#]+)(?:\&?\w+\=\w+)*)*(?<bkmrk>\#.*)?

# Australian phone number validator. Accepts all forms of Australian phone numbers in different formats (area code in brackets, no area code, spaces between 2-3 and 6-7th digits, +61 international dialing code). Checks that area codes are valid (when entered).
# ID: 1787
^\({0,1}((0|\+61)(2|4|3|7|8)){0,1}\){0,1}(\ |-){0,1}[0-9]{2}(\ |-){0,1}[0-9]{2}(\ |-){0,1}[0-9]{1}(\ |-){0,1}[0-9]{3}$

# Tests expression for DTMF combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order.
# ID: 2895
^[0-9#\*abcdABCD]+$

# Parses comma-separated numbers. Doesn't allow spaces inbetween numbers and/or between numbers and commas. Allows single number to be added. Doesn't allow sequence to end with a comma.
# ID: 2900
^[0-9]+(,[0-9]+)*$

# Displays duration in
# ID: 2779
([0-9]+)\s(d)\s(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])

# Standard freight container number in upper or lower case.
# ID: 771
^[a-zA-Z]{3}[uU]{1}[0-9]{7}$

# This expression is used to validate CNIC numbers. The number must start with either 1,2,3 or 4 which represent the province. The hyphen is optional. But if given must be at the correct index (i.e. first one after 5 numbers and second one before the last number). The total length of numbers is 13.
# ID: 3256
^[1-4]{1}[0-9]{4}(-)?[0-9]{7}(-)?[0-9]{1}$

# This expression will return the src (source) property of an image tag <IMG>. The source returned is limited to the file extensions supplied. It doesn't matter if the image is prefixed with '../' or 'http://..blah' or 'drive\path' or nothing. This expression could be modifed to return other sources or for the tags (ie <BGSOUND>, <SCRIPT>, etc.) depending on the file extensions given.
# ID: 544
src[^>]*[^/].(?:jpg|bmp|gif)(?:\"|\')

# I used this to find bbcode [bible][/bible] tags.  It also allows for multiple versions with a default and other than english languages.
# ID: 2496
\[bible[=]?([a-zäëïöüæø]*)\]((([0-9][[:space:]]?)?[a-zäëïöüæø]*[[:space:]]{1}([a-zäëïöüæø]*[[:space:]]?[a-zäëïöüæø]*[[:space:]]{1})?)([0-9]{1,3})(:{1}([0-9]{1,3})(-{1}([0-9]{1,3}))?)?)\[\\/bible\]

# Input for Numeric values.  Handles negatives, and comma formatted values.  Also handles a single decimal point
# ID: 329
^(\d|-)?(\d|,)*\.?\d*$

# Matches Numeric with Commas and a single decimal point.  Also matches empty string.
# ID: 254
^(\d|,)*\.?\d*$

# will match muliple numeric ranges, from range (1 to 59391) , (64512 to 65534) and (131072 to 4294967294)
# ID: 3552
^(([1-9][0-9]{0,3}|[1-4][0-9]{4}|5([0-8][0-9]{3}|9([0-2][0-9]{2}|3([0-8][0-9]|9[01]))))|(6(4(5(1[2-9]|[2-9][0-9])|[6-9][0-9]{2})|5([0-4][0-9]{2}|5([0-2][0-9]|3[0-4]))))|(1(3(1(0(7[2-9]|[89][0-9])|[1-9][0-9]{2})|[2-9][0-9]{3})|[4-9][0-9]{4})|[2-9][0-9]{5}|[1-9][0-9]{6,8}|[1-3][0-9]{9}|4([01][0-9]{8}|2([0-8][0-9]{7}|9([0-3][0-9]{6}|4([0-8][0-9]{5}|9([0-5][0-9]{4}|6([0-6][0-9]{3}|7([01][0-9]{2}|2([0-8][0-9]|9[0-4]))))))))))$

# Matches valids TCP/IP-Adresses
# ID: 3604
^((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))$

# This regular expression will validate most (current & future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year. :)  I designed this expression to validate dates from the year 2000 to 2099. I do not plan on this same code being in place in 2099, so I hope this is sufficient enough...
# ID: 1729
^([0-1]?[0-9]{1}/[0-3]?[0-9]{1}/20[0-9]{2})$

# More complete than other patterns I could find here. Matches U.S. Phone numbers with various formats.  Invalid area codes (that start with a 0 or 1) are excluded, as well as invalid exchanges (that start with 0).  Allows, alphabetical exchange+local parts, and many extension notations. Dash and dot delimiters allowed except adjacent to a parenthetical area code. Letters may be used in place of any numbers except the country code and area code.
# ID: 2370
1?(?:[.\s-]?[2-9]\d{2}[.\s-]?|\s?\([2-9]\d{2}\)\s?)(?:[1-9]\d{2}[.\s-]?\d{4}\s?(?:\s?([xX]|[eE][xX]|[eE][xX]\.|[eE][xX][tT]|[eE][xX][tT]\.)\s?\d{3,4})?|[a-zA-Z]{7})

# this parttern only use for decimal number.
# ID: 3095
^\d(\.\d{1,2})?$

# This RegEx checks whether the input is a number or not. Number may contain commas a seperators, can contain one or two decimal places and can be positive or negative.
# ID: 1762
^(-?)(((\d{1,3})(,\d{3})*)|(\d+))(\.\d{1,2})?$

# This regex checks if a date is in ISO-format (yyyy-mm-dd). Leap year should be checked too. Date has to be between 1900-01-01 and 2999-12-31.
# ID: 1850
^((((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[13578]|10|12)([-])(0[1-9]|[12][0-9]|3[01]))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[469]|11)([-])([0][1-9]|[12][0-9]|30))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(02)([-])(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)([-])(02)([-])(29))|(([13579][26]00)([-])(02)([-])(29))|(([0-9][0-9][0][48])([-])(02)([-])(29))|(([0-9][0-9][2468][048])([-])(02)([-])(29))|(([0-9][0-9][13579][26])([-])(02)([-])(29)))$

# This regex checks if a date is in german date format (dd.mm.yyyy). Leap year should be checked too. Date has to be between 01.01.1900 and 31.12.2999.
# ID: 1851
^(((0[1-9]|[12][0-9]|3[01])([\.])(0[13578]|10|12)([\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|(([0][1-9]|[12][0-9]|30)([\.])(0[469]|11)([\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((0[1-9]|1[0-9]|2[0-8])([\.])(02)([\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((29)([\.])(02)([\.])([02468][048]00))|((29)([\.])(02)([\.])([13579][26]00))|((29)([\.])(02)([\.])([0-9][0-9][0][48]))|((29)([\.])(02)([\.])([0-9][0-9][2468][048]))|((29)([\.])(02)([\.])([0-9][0-9][13579][26])))$

# Moblie Number which starts from 7/8/9 (Indian Mobile No.) & 11 digit Landline number
# ID: 3346
([0-9]{11}$)|(^[7-9][0-9]{9}$)

# Matches any word except these from alternation (xx|yy|...). Works in JavaScript
# ID: 2280
(?!\b(xx|yy)\b)\b[\w]+\b

# Address
# ID: 521
^[a-zA-Z\d]+(([\'\,\.\- #][a-zA-Z\d ])?[a-zA-Z\d]*[\.]*)*$

# This regular expression matches titles. The length of the title has not been restricted. It allows only alphabets in the title and takes zero or one . after the title. Also it allows trailing spaces.
# ID: 553
^([a-zA-Z]+(.)?[\s]*)$

# Regular Expresion for should not start and end with special charectors
# ID: 3509
^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z]))$

# Simple (non-validating) match with numbered group captures that extracts parts of a filename into $1 = folder path, $2 = filename w/o extension, $3 = extension. Should work on Windows, OS X, and Unix/Linux, but not on OS 9 and OSs with folder separators other than slashes (either direction). Tested only on .NET RE engine.
# ID: 2617
^(.*?)([^/\\]*?)(\.[^/\\.]*)?$

# Regex used in .NET to validate a date.  Matches the following formats mm/dd/yy, mm/dd/yyyy, mm-dd-yy, mm-dd-yyyy
# ID: 84
((0?[13578]|10|12)(-|\/)((0[0-9])|([12])([0-9]?)|(3[01]?))(-|\/)((\d{4})|(\d{2}))|(0?[2469]|11)(-|\/)((0[0-9])|([12])([0-9]?)|(3[0]?))(-|\/)((\d{4}|\d{2})))

# Percentage with 3 number after comma.
# ID: 155
^100$|^[0-9]{1,2}$|^[0-9]{1,2}\,[0-9]{1,3}$

# Correct French DateTime(DD/MM/YYYY OR DD/MM/YYYY HH:MM:SS)
# ID: 156
^(([0-2]\d|[3][0-1])\/([0]\d|[1][0-2])\/[2][0]\d{2})$|^(([0-2]\d|[3][0-1])\/([0]\d|[1][0-2])\/[2][0]\d{2}\s([0-1]\d|[2][0-3])\:[0-5]\d\:[0-5]\d)$

# Validates an Australian mobile telephone number that can include an international prefix and four plus (two or three-digit) grouping.
# ID: 3247
^((61|\+61)?\s?)04[0-9]{2}\s?([0-9]{3}\s?[0-9]{3}|[0-9]{2}\s?[0-9]{2}\s?[0-9]{2})$

# || Only alphanum characters accepted at the beginning of the user name and domain name
# ID: 2393
^([0-9a-zA-Z]+(?:[_\.\-]?[0-9a-zA-Z]+)*[@](?:[0-9a-zA-Z]+(?:[_\.\-]?[0-9a-zA-Z]+)*\.[a-zA-Z]{2,}|(?:\d{1,}\.){3}\d{1,}))$

# Quick and dirty extraction of quoted HTML attributes if you begin with just the tag string.  Not intended for use in a full HTML document.
# ID: 2050
(?<tagname>[^\s]*)="(?<tagvalue>[^"]*)"

# A basic regex that matches a file path, windows or linux slash directions both match, apart from ..\
# ID: 2239
^((\.\./|[a-zA-Z0-9_/\-\\])*\.[a-zA-Z0-9]+)$

# Regex to match date and or time either in 12 or 24 hour format.
# ID: 3184
^(0?[1-9]|[12][0-9]|3[01])[- /.](0?[1-9]|1[012])[- /.](19|20)?[0-9]{2}? ?((([0-1]?\d)|(2[0-3])):[0-5]\d)?(:[0-5]\d)? ?([a,p,A,P][m,M])?$

# match extension
# ID: 1877
\.?[a-zA-Z0-9]{1,}$

# The alphanumeric patterns I have seen here are unnecessarily long. This is all you need.
# ID: 1483
^[\w ]{0,}$

# Person's name (first, last, or both) in any letter case.  Although not perfect, this expression will filter out many incorrect name formats (especially numerics and invalid special characters).
# ID: 143
^[a-zA-Z]+(([\'\,\.\- ][a-zA-Z ])?[a-zA-Z]*)*$

# Essa expressão é uma validação de data simplicada onde não aceita datas com ano inferior a 1900. Interessante pra validação de data de idade, data atual, etc
# ID: 713
(0?[1-9]|[12][0-9]|3[01])[/ -](0?[1-9]|1[12])[/ -](19[0-9]{2}|[2][0-9][0-9]{2})

# This was made for use in javascript to detect MMDDYYYY formatted text.  It tests all valid dates, including 31 vs 30 days in a month and the 28 vs 29 leap year rules which exclude centennial years not divisible by 400 and years not divisible by 4.
# ID: 1401
^((((((0[13578])|(1[02]))[\s\.\-\/\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\s\.\-\/\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\s\.\-\/\\]?((0[1-9])|(1[0-9])|(2[0-8]))))[\s\.\-\/\\]?(((([2468][^048])|([13579][^26]))00)|(\d\d\d[13579])|(\d\d[02468][^048])|(\d\d[13579][^26])))|(((((0[13578])|(1[02]))[\s\.\-\/\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\s\.\-\/\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\s\.\-\/\\]?((0[1-9])|([12][0-9]))))[\s\.\-\/\\]?(((([2468][048])|([13579][26]))00)|(\d\d[2468][048])|(\d\d[13579][26])|(\d\d0[48]))))$

# Validates any format of North American phone number, while parsing the Country Code, Area (City) Code, Prefix and Postfix numbers and the letters ext or x followed by the extension number which cannot begin with 0. Will not accept invalid Area Codes
# ID: 2883
^(?<CountryCode>[1]?)\s?\(?(?<AreaCode>[2-9]{1}\d{2})\)?\s?(?<Prefix>[0-9]{3})(?:[-]|\s)?(?<Postfix>\d{4})\s?(?:ext|x\s?)(?<Extension>[1-9]{1}\d*)?$

# This should help in finding european style phone numbers (without hyphens), particularly danish numbers with consist of 8 digits, and can be separated by a whitespace.
# ID: 1790
^((\(?\+45\)?)?)(\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2})$

# A regex that filters the text property attributes or CSS in a span or font tag, i.e. only the color and font-size style properties and the color and size attributes.
# ID: 884
# Multiline
# one tag name matcher and three times the style or attribute matcher with each 6 match possibilities (three times to reckon with the attributes placing)
# capturing (only one) front space of each attribute
# quotes aren't needed to match, but are captures when available
<(span|font).*?(?:(?:(\s?style="?).*?((?:\s?font-size:.+?\s*(?:;|,|(?="))+)|(?:\s?color:.+?\s*(?:;|,|(?="))+))[^"]*((?:\s?font-size:.+?\s*(?:;|,|(?="))+)|(?:\s?color:.+?\s*(?:;|,|(?="))+))[^"]*("?)|(\s?size="?.*?(?:(?=\s)|"|(?=>)))|(\s?color="?.*?(?:(?=\s)|"|(?=>)))|(?=>)).*?){3}>

# I wrote this regular expression because a project I was working on required a stricter validator on social security numbers. There are actually gov't standards on what is a valid social: The first 3 digits can't be > 779, The first 3 digits can't be 000, The second 2 digits can't be 00, and the last 4 digits can't be 0000. This regex handles all these cases and checks formatting for numbering and dashes (###-##-####)
# ID: 418
^(?=((0[1-9]0)|([1-7][1-7]\d)|(00[1-9])|(0[1-9][1-9]))-(?=(([1-9]0)|(0[1-9])|([1-9][1-9]))-(?=((\d{3}[1-9])$|([1-9]\d{3})$|(\d[1-9]\d{2})$|(\d{2}[1-9]\d)$))))

# This pattern match the Italian Istat Ateco Code (Codice Istat) updated to Istat Declaration Ateco 2004
# ID: 1620
\d{2}[.]{1}\d{2}[.]{1}[0-9A-Za-z]{1}

# International Bank Account Number (IBAN) Italian. Identify Bank account in Italy.
# ID: 1621
IT\d{2}[ ][a-zA-Z]\d{3}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{3}|IT\d{2}[a-zA-Z]\d{22}

# Validates dates formatted like "dd.mm.yyyy" or "dd.mm.yy". Also the separators "/" and "-" are validated "ok". This expression does not check leap years!
# ID: 653
^(0{0,1}[1-9]|[12][0-9]|3[01])[- /.](0{0,1}[1-9]|1[012])[- /.](\d{2}|\d{4})$

# Matches the app relative path of a file. This will work for relative paths of URLs. Not very complicated but will work to do basic validation.
# ID: 1438
^~/[0-9a-zA-Z_][0-9a-zA-Z/_-]*\.[0-9a-zA-Z_-]+$

# This matches a standard set of plus minus letter grades.
# ID: 2027
^A-?|[BCD][+-]?|[SN]?F|W$

# 4 part version numbers
# ID: 2023
^\d+\.\d\.\d[01]\d[0-3]\d\.[1-9]\d*$

# A Simple Currency Expression. It will validate the number portion only.
# ID: 2024
^\d+(\.\d{2})?$

# Matches one Upper-case US ASCII Letter.
# ID: 2021
^[A-Z]$

# Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 99
# ID: 1990
^[1-9]\d?-\d{7}$

# Requires a person's name including at least 2 parts. (first and last) Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial. Works well for filtering names on validation.
# ID: 2222
^([a-zA-Z]+[\'\,\.\-]?[a-zA-Z ]*)+[ ]([a-zA-Z]+[\'\,\.\-]?[a-zA-Z ]+)+$

# Gets the file name from a URL including the "/". If the URL ends in "/" the "/" is matched.
# ID: 2791
(?<!/)/(\w+\.\w+)?$

# With this expression we can validate alpha numeric, ie allow only numbers and alphabets.
# ID: 3192
/^[a-zA-Z0-9]+$/

# Correct German DateTime. Does not check leap year rules!
# ID: 319
^(([1-9]|[0-2]\d|[3][0-1])\.([1-9]|[0]\d|[1][0-2])\.[2][0]\d{2})$|^(([1-9]|[0-2]\d|[3][0-1])\.([1-9]|[0]\d|[1][0-2])\.[2][0]\d{2}\s([1-9]|[0-1]\d|[2][0-3])\:[0-5]\d)$

# This pattern will match any positive number(Real or Integer).  It will not match ZERO or any variation of zero (ie 0.00)
# ID: 1833
(^[0][.]{1}[0-9]{0,}[1-9]+[0-9]{0,}$)|(^[1-9]+[0-9]{0,}[.]?[0-9]{0,}$)

# matches fixed and mobile phones in ACD format
# ID: 2236
^0[1-9]\d{7,8}$

# Validation of a Folder Name. Excludes all forbidden characters
# ID: 1031
^[^\\\/\?\*\"\'\>\<\:\|]*$

# Matches common Degree, Minute, Second coordinate values. The last part can be easily modified to be latitude or longitude specific by changing
# ID: 2702
[0-9]{1,2}[:|°][0-9]{1,2}[:|'](?:\b[0-9]+(?:\.[0-9]*)?|\.[0-9]+\b)"?[N|S|E|W]

# Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account.
# ID: 578
((([0][1-9]|[12][\d])|[3][01])[-/]([0][13578]|[1][02])[-/][1-9]\d\d\d)|((([0][1-9]|[12][\d])|[3][0])[-/]([0][13456789]|[1][012])[-/][1-9]\d\d\d)|(([0][1-9]|[12][\d])[-/][0][2][-/][1-9]\d([02468][048]|[13579][26]))|(([0][1-9]|[12][0-8])[-/][0][2][-/][1-9]\d\d\d)

# Needed to be able to validate positive and numeric values that equate to SQL Server data type decimal(18, 2) but the value could not be 0.  This regex does that.  If you need to change the precision or scale have at it.
# ID: 1933
[-]?[1-9]\d{0,16}\.?\d{0,2}|[-]?[0]?\.[1-9]{1,2}|[-]?[0]?\.[0-9][1-9]

# Matches any text inside greater than less than characters. Can be used to remove HTML Markup including attributes and comments.
# ID: 2986
(<(!--|script)(.|\n[^<])*(--|script)>)|(<|<)(/?[\w!?]+)\s?[^<]*(>|>)|(\&[\w]+\;)

# This match fileds contain only letters, a single hyphen, a single space, not empty
# ID: 312
[^a-zA-Z \-]|(  )|(\-\-)|(^\s*$)

# Validates Mastercard credit card
# ID: 1239
# Multiline
^5[1-5][0-9]{14}$

# First character is 5
# Second character is 1-5
# Last 14 characters 0-9

# UK National Insurance Number (NINo) validation. The following modifications have been made: The first letter may not be D, F, I, Q, U or Z; the second letter may not be D, F, I, O, Q, U or Z; the final letter is optional.
# ID: 527
^[A-CEGHJ-PR-TW-Z]{1}[A-CEGHJ-NPR-TW-Z]{1}[0-9]{6}[A-DFM]{0,1}$

# Accurate IP address verification... Th fist and the fourth numeric part of an IP address must be between 1 and 255. The second and the third numeric part of an IP address must be between 0 and 255.
# ID: 2560
(25[0-5]|2[0-4][0-9]|[1][0-9]?[0-9]?|[1-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[1][0-9]?[0-9]?|[1-9][0-9]?|[0])\.(25[0-5]|2[0-4][0-9]|[1][0-9]?[0-9]?|[1-9][0-9]?|[0])\.(25[0-5]|2[0-4][0-9]|[1][0-9]?[0-9]?|[1-9][0-9]?)

# This pattern matches strings where no more than two equal characters may come in succession.
# ID: 2715
^((.)(?!\2{2,}))+$

# ac80016-29181-12246003492|1224600413|ac8001629181-12246003492|M4.0-300-398598-1224600381630-721324|none|190.40.27.239|31,46,51,63,77,82,94,100
# ID: 2419
\|(http.*)\|(.*)$/ig

# It should be universal regular expression for US currency.
# ID: 1982
^\$(\d{1,3}(\,\d{3})*|(\d+))(\.\d{2})?$

# Requires 10 digit number. Rest is same as email
# ID: 1983
[\d+]{10}\@[\w]+\.?[\w]+?\.?[\w]+?\.?[\w+]{2,4}/i

# Date Format notations. Mostly used in DB applications where rigorous pattern matching for DATE is required.
# ID: 1984
^\$YYYY\$\$MM\$\$DD\$$

# http://www.url.com || http://url.com || http://first.url.com || https://www.url.com || https://url.com
# ID: 1985
^(\w+)s?\:\/\/(\w+)?(\.)?(\w+)?\.(\w+)$

# http://www.url.com || http://url.com || http://first.url.com || https://www.url.com || https://url.com
# ID: 1986
^(\w+)s?[:]\/\/(\w+)?[.]?(\w+)[.](\w+)$

# Good way to quickly search for highly educated people in a list or file
# ID: 1987
/Dr[.]?|Phd[.]?|MBA/i

# any email form like any_name@mail.confidential.yahoo.com, any_name@mail.yahoo.com, any_name@yahoo.com, any.name@yahoo.com, anyname@domain.com. You can replace .com with .net | .edu | .uk | .in or anything. I will work.
# ID: 1874
[\w]+\@[\w]+\.?[\w]+?\.?[\w]+?\.?[\w+]{2,4}

# Normaly US 10 digit numbers are writen as xxx.xxx.xxxx or xxx-xxx-xxxx or simply 7 digit numbers for local websites where area code is filled by default xxx.xxxx or xxx-xxxx
# ID: 1875
(\d+)?-?(\d+)-(\d+)

# dd/mm/yyyy
# ID: 3243
((0[1-9]|1[0-9]|2[0-9]|3[01])\/(?:0[13578]|1[02])\/(?:1[2-9]\d+|2[0-9]\d+))|((0[1-9]|1[0-9]|2[0-8])\/(?:02)\/(?:1[2-9]\d+|2[0-9]\d+))|(29\/(?:02)\/((1200|1600|2000|2400)|(1[6-9]|2[0-9])((0[48]|1[26]|2[048]|3[26]|4[048]|5[26]|6[048]|7[26]|8[048]|9[26]))))|((0[1-9]|1[0-9]|2[0-9]|30)\/(?:0[469]|11)\/(?:1[2-9]\d+|2[0-9]\d+))

# Social Insurance Number validator.
# ID: 503
^\d{3}\s?\d{3}\s?\d{3}$

# Read content in tag xml including child tag
# ID: 1560
<(?<tag>\w*|\w*\.+\w*)>+((.|[\n\t\f\r\s])*?)<\/\k<tag>>

# I did not found a Regex for german date, so I created my own. This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999. As usual, many tests have been made. I think this one should be fine.
# ID: 855
^(((0?[1-9]|[12]\d|3[01])\.(0[13578]|[13578]|1[02])\.((1[6-9]|[2-9]\d)\d{2}))|((0?[1-9]|[12]\d|30)\.(0[13456789]|[13456789]|1[012])\.((1[6-9]|[2-9]\d)\d{2}))|((0?[1-9]|1\d|2[0-8])\.0?2\.((1[6-9]|[2-9]\d)\d{2}))|(29\.0?2\.((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$

# This expression validates dates in the ITALIAN d/m/y format from 1/1/1600 - 31/12/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00 since it could be any century (1900, 2000, 2100). Days and months must be 1 or 2 digits and may have leading zeros. Years must be 2 or 4 digit years. 4 digit years must be between 1600 and 9999. Date separator may be a slash (/), dash (-), or period (.)
# ID: 151
^(?:(?:31(\/|-|\.)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/|-|\.)(?:0?[1,3-9]|1[0-2])\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:29(\/|-|\.)0?2\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\d|2[0-8])(\/|-|\.)(?:(?:0?[1-9])|(?:1[0-2]))\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$

# A regex that hits on a multi-line sequence that starts with a START phrase on a line, and ends with an END phrase on a different line, which contains a MIDDLE phrase on a line between the START and END lines.
# ID: 3206
^START(?=(?:.(?!END|START))*MIDDLE).*?END[^\n]+

# Litle regexp for my portal engie. Only cut the {CHBLOCK:'modulename'} item
# ID: 1018
\{CHBLOCK\:(.*?\})

# you can enter number between 1 to 12
# ID: 3043
\b(?:1[0-2]?|[2-9])\b

# \d{2,4} matches at least 2 but no more than 4 digits
# ID: 1561
\d{2,4}

# REGULAR EXPRESSION TO CHECK ONLY POSITIVE INTEGERS
# ID: 2618
^([1-9]+[0-9]* | [1-9])$

# Valid XML Node or Attribute Names start with a letter <document>, an underscore <_record> or a colon (generally avoid using a colon)
# ID: 2161
^[a-zA-Z_:]+[a-zA-Z_:\-\.\d]*$

# This regexp tests Argentinian CUIT / CUIT numbers.
# ID: 640
^[0-9]{2}-[0-9]{8}-[0-9]$

# This will match Medicare Rail Road Board numbers.
# ID: 3478
^[A-Z]{1,3}\d{6}$

# Matches all valid US standard, US +4, and Canadian postal codes. Returns results for only either one of them, in groups, regardless of case or whitespace (even dashes).
# ID: 2405
^ *([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\d[a-zA-Z]) *-* *(\d[a-zA-Z]\d) *$|^ *(\d{5}) *$|^ *(\d{5}) *-* *(\d{4}) *$

# Validação de CEP Brasileiro. Aceita número com traço ou sem traço.
# ID: 1485
^\d{5}-\d{3}$|^\d{8}$

# The regular expression above will validate a UK Vehicle Reg number according to the following criteria:
# ID: 3064
^([A-HJ-PR-Y]{2,2}[056][0-9]\s?[A-HJ-PR-Y]{3,3})$|^([A-HJ-NP-Y]{1,3}[0-9]{2,3}?\s[A-Z]{3,3})$|^([A-Z]{1,3}\s?[0-9]{1,4}([A-Z]{1,1})?)$|^([0-9]{4,4}[A-Z]{1,3})$|^([A-Z]{1,2}\s?[0-9]{1,4})$|^([A-Z]{2,3}\s?[0-9]{1,4})$|^([0-9]{1,4}\s?[A-Z]{2,3})$

# A regular expression to match phone numbers, allowing for an international dialing code at the start and hyphenation and spaces that are sometimes entered.
# ID: 73
^(\(?\+?[0-9]*\)?)?[0-9_\- \(\)]*$

# It is for Comma separated integer values only.it won't allow comma before and end string.
# ID: 2945
^[0-9][0-9,]*[0-9]$

# Matches yyyy/MM/dd
# ID: 3244
^(19|20)\d\d[-/.]([1-9]|0[1-9]|1[012])[- /.]([1-9]|0[1-9]|[12][0-9]|3[01])$

# Regular Expression matches any internet URLs. Used with the replace method it comes in very handy.
# ID: 2415
(http://([\w-]+\.)|([\w-]+\.))+[\w-]*(/[\w- ./?%=]*)?

# This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC's) in MS SQL Server.
# ID: 1130
(\/\*(\s*|.*?)*\*\/)|(--.*)

# This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional).  Based pretty heavily on an expression by Steven Smith on this site.
# ID: 341
^((\d?)|(([-+]?\d+\.?\d*)|([-+]?\d*\.?\d+))|(([-+]?\d+\.?\d*\,\ ?)*([-+]?\d+\.?\d*))|(([-+]?\d*\.?\d+\,\ ?)*([-+]?\d*\.?\d+))|(([-+]?\d+\.?\d*\,\ ?)*([-+]?\d*\.?\d+))|(([-+]?\d*\.?\d+\,\ ?)*([-+]?\d+\.?\d*)))$

# Validates email addresses according to the RFC 822 specification. The only exception is the exclusion of control characters, which should be sufficient for human input from a keyboard.
# ID: 1067
(?<user>(?:(?:[^ \t\(\)\<\>@,;\:\\\"\.\[\]\r\n]+)|(?:\"(?:(?:[^\"\\\r\n])|(?:\\.))*\"))(?:\.(?:(?:[^ \t\(\)\<\>@,;\:\\\"\.\[\]\r\n]+)|(?:\"(?:(?:[^\"\\\r\n])|(?:\\.))*\")))*)@(?<domain>(?:(?:[^ \t\(\)\<\>@,;\:\\\"\.\[\]\r\n]+)|(?:\[(?:(?:[^\[\]\\\r\n])|(?:\\.))*\]))(?:\.(?:(?:[^ \t\(\)\<\>@,;\:\\\"\.\[\]\r\n]+)|(?:\[(?:(?:[^\[\]\\\r\n])|(?:\\.))*\])))*)

# Does a very basic validation on Danish street addresses.
# ID: 3030
^((.){1,}(\d){1,}(.){0,})$

# Swedish phone numbers according to SIS standard
# ID: 338
^(([+]\d{2}[ ][1-9]\d{0,2}[ ])|([0]\d{1,3}[-]))((\d{2}([ ]\d{2}){2})|(\d{3}([ ]\d{3})*([ ]\d{2})+))$

# This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also  will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _ . or - in the path, this will be updated at some point.
# ID: 2573
^/{1}(((/{1}\.{1})?[a-zA-Z0-9 ]+/?)+(\.{1}[a-zA-Z0-9]{2,4})?)$

# match web pictrue's address,must be full path,include http head.
# ID: 1713
https?://[\w./]+\/[\w./]+\.(bmp|png|jpg|gif)

# Expressão para datas no formato ddMMM obrigando dois dígitos para o dia e três letras para o mês (em inglês). Regex for dates at ddMMM format mandatory two digits for days and three letters for the months.
# ID: 1547
[0-3]{1}[0-9]{1}(jan|JAN|feb|FEB|mar|MAR|apr|APR|may|MAY|jun|JUN|jul|JUL|aug|AUG|sep|SEP|oct|OCT|nov|NOV|dec|DEC){1}

# This is a derivation of a few other image tag regex patterns I found on the site that didn't seem to work. This is my first regex, so if I did this wrong - apologies in advance! It works for me...
# ID: 1091
<[iI][mM][gG]([^>]*[^/>]*[/>]*[>])

# My second ever regex - a derivation of an image tag pattern, use in conjunction with <[iI][mM][gG]([^>]*[^/>]*[/>]*[>]) to remove advertisements from RSS feeds. Whee!
# ID: 1092
<[iI][fF][rR][aA][mM][eE]([^>]*[^/>]*[/>]*[>])

# Matches standard rgb syntax for web colors
# ID: 1317
^rgb\(([01]?\d\d?|2[0-4]\d|25[0-5])\,([01]?\d\d?|2[0-4]\d|25[0-5])\,([01]?\d\d?|2[0-4]\d|25[0-5])\)$ #Matches standard web rgb pattern

# This piece of regex catches the if the open braces are not placed the line under a get command
# ID: 1148
\b(get)\b.*{

# This regex catches the hard-coded for blocks
# ID: 1149
\bfor\b.*[A-Za-z][<> ][\d]

# This regex catches if the variable isn't initialized when it is declared
# ID: 1150
\b(byte|char|short|long|float|int|double|decimal|bool|string)\b.*\s[a-zA-Z](?=;)

# This regex catches illegal precedence order of declerations of a class
# ID: 1151
(\bprotected\b.*(public))|(\bprivate\b.*(protected))|(\bprivate\b.*(public))

# This regex catches the redundacy of including class names in the name of class properties.
# ID: 1152
\b(\w+).\1

# This regex forces the programmer to make only one decleration per line.
# ID: 1153
\b(public|private|protected|internal)\b.*(byte|char|short|long|float|int|double|decimal|bool|string)\b.*(?=,)

# This regex limits the use of any special prefix characters to indicate that the variable is scoped to the class.
# ID: 1154
((\bm_[a-zA-Z\d]*\b)|(\bin_[a-zA-Z\d]*\b)|(\bin _[a-zA-Z\d]*\b))

# This regex forbids the use of underscore in the interface decleration.
# ID: 1155
\binterface\b.*(\bI[_]\w*\b)

# Allow quotes in email address. Its Allow to enter quotes after first char and before @.
# ID: 1405
^\w+(([-+']|[-+.]|\w+))*@\w+([-.]\w+)*\.\w+([-.]\w+)*$

# its validating the string as shown in example(matches).
# ID: 2383
^\s*[a-zA-Z\s]+\,[0-9\s]+\s*$

# Brazilian CEP. A variable of others validations, but only numbers are allowed.
# ID: 439
^\d{5}(\d{3})?$

# Brazilian CPF - Personal document in Brazil.
# ID: 407
(\d{3}.?\d{3}.?\d{3}-?\d{2})

# Should you need to validate that an email address is correctly formmatted and need to block hotmail and gmail, this expression will do it for you.  Thanks to Sergei Z from regexadvice.com
# ID: 2398
\w+([-+.]\w+)*@(?!(hotmail|gmail|yahoo|msn|excite|lycos|aol|live)\.com$)\w+([-.]\w+)*\.\w+([-.]\w+)*

# If you have one or more words that you are searching for, random text and then a number at the end from 0 to 10, this regex should work.
# ID: 3335
(Word1|Word2).*?(10|[1-9])

# Positive Whole number matched from 0 to 9999999. Only 7 digits length is allowed.
# ID: 502
^\d{1,7}$

# IP Address validation by Vassilis Petroulias + my subnet validation using numbers between 0 and 32
# ID: 2481
^((0|1[0-9]{0,2}|2[0-9]{0,1}|2[0-4][0-9]|25[0-5]|[3-9][0-9]{0,1})\.){3}(0|1[0-9]{0,2}|2[0-9]{0,1}|2[0-4][0-9]|25[0-5]|[3-9][0-9]{0,1})(?(\/)\/([0-9]|[1-2][0-9]|3[0-2])|)$

# Date YYYY-MM-DD (optional time HH:MM(optional seconds :SS)).  Was borrowed from this [http://regexlib.com/REDetails.aspx?regexp_id=390] but changed to use 24 hour time and optional seconds.  You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.
# ID: 1530
^((\d{2}(([02468][048])|([13579][26]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|([1-2][0-9])))))|(\d{2}(([02468][1235679])|([13579][01345789]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\s(((0?[1-9])|(1[0-9])|(2[0-3]))\:([0-5][0-9])((\s)|(\:([0-5][0-9])))?))?$

# Czech domestic bank acount number.
# ID: 3458
^(?:(\\d{1,6})-)?(\\d{2,10})/(\\d{4})$

# This expression validate website urls
# ID: 3641
(((ht|f)tp(s)?://)|www.){1}([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?

# reg
# ID: 1280
(?=^.{6,10}$)(?=.*\$)(?=.*[a-z])(?=.*[A-Z])(?=.*[!~@#$%^&*()_+}{":;'?/>.<,])(?!.*\s).*$

# This is a pattern for cell phone of main israel cell phone companies
# ID: 1444
^0?(5[024])(\-)?\d{7}$

# This will give u detail of port
# ID: 1736
((?:[\\?&](?:[a-z\d\\.\\[\\]%-]+)(?:=[a-z\\d\\.\\[\\]%-]*)?)*)

# This is my basic phone number verification. it allows a + - , signs digits, spaces and blank entry
# ID: 350
(^(\+?\-? *[0-9]+)([,0-9 ]*)([0-9 ])*$)|(^ *$)

# Matches the Content-Type for a MIME Mail Message and a Non-Mime Mail Message
# ID: 2504
^Content-Type:\s*(\w+)\s*/?\s*(\w*)?\s*;\s*((\w+)?\s*=\s*((".+")|(\S+)))?

# will match as long as the only chars exist in the string : A-Z,a-z,0-9,'Space' chr(32),%&'+-@_.
# ID: 841
^([A-Z]|[a-z]|[0-9])(([A-Z])*(([a-z])*([0-9])*(%)*(&)*(')*(\+)*(-)*(@)*(_)*(\.)*)|(\ )[^  ])+$

# Valid Pan card
# ID: 3387
/^[A-Z]{3}[G|A|F|C|T|H|P]{1}[A-Z]{1}\d{4}[A-Z]{1}$/;

# This validates an email address and only an email address. None of the <email> stuff, just user@email.whatever. Comments are more then welcome.
# ID: 1259
^(?:[\w]+[\&\-_\.]*)+@(?:(?:[\w]+[\-_\.]*)\.(?:[a-zA-Z]{2,}?))$

# Simple match for U.S. Amateur Radio Call signs
# ID: 380
^[AaWaKkNn][a-zA-Z]?[0-9][a-zA-Z]{1,3}$

# matches IP address in hex form in dotted or not dotted notation
# ID: 377
[0-9A-Fa-f]{2}(\.?)[0-9A-Fa-f]{2}(\.?)[0-9A-Fa-f]{2}(\.?)[0-9A-Fa-f]{2}

# Very Simple Match for dotted Decimal IP address.  Doesn’t Validate addresses
# ID: 378
[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}

# Matches standard 0- to 10-figure (non-tetrad) Ordnance Survey of Great Britain (OSGB) Grid References
# ID: 2409
^((([sS]|[nN])[a-hA-Hj-zJ-Z])|(([tT]|[oO])[abfglmqrvwABFGLMQRVW])|([hH][l-zL-Z])|([jJ][lmqrvwLMQRVW]))([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?$

# Matches standard 0- to 10-figure (including 2km tetrad references) Ordnance Survey of Great Britain (OSGB) Grid References
# ID: 2862
((([sS]|[nN])[a-hA-Hj-zJ-Z])|(([tT]|[oO])[abfglmqrvwABFGLMQRVW])|([hH][l-zL-Z])|([jJ][lmqrvwLMQRVW]))([0-9]{2})?(([a-np-zA-NP-Z]{1}?|([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?))

# Will match any web path that's supposed to start in the root (e.g. with "/" in front of it.
# ID: 3046
^\.{0,2}[\/\\]

# Matches any valid URLs which can activate links in a text.
# ID: 1771
^((http|https|ftp)\://|www\.)[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,4}(/[a-zA-Z0-9\-\._\?=\,\'\+%\$#~]*[^\.\,\)\(\s])*$

# Parses any file path and extracts directory, file name and extension separately.
# ID: 2173
^(?<1>.*[\\/])(?<2>.+)\.(?<3>.+)?$|^(?<1>.*[\\/])(?<2>.+)$|^(?<2>.+)\.(?<3>.+)?$|^(?<2>.+)$

# Slovak street names with numbers
# ID: 3380
^([\w\s\W]+[\w\W]?)\s([\d\-\\\/\w]*)?

# Split phone nuber for prefix and number
# ID: 3488
(?<prefix>[\d]{3})[\s+\/\\\-]+(?<number>[\d\-\s]+)

# Written to tell absolute and relative paths apart (by matching only absolute paths) on *nix or Windows systems, for a cross-platform PHP project. Admittedly there are a few weird edges cases that will outwit the pattern, like the %FOO% anchor things that can be used in windows paths.
# ID: 3612
^(~?/|[a-zA-Z]:[\\/]).+

# Matches most valid ArcCatalog FeatureClass catalog paths.  Rejects most invalid paths.  Accepts mapped drive letters and UNC network paths.  UNC Server names must begin with a letter and may only include letters and numbers.  Will not accept directories that include ".gdb", ".mdb", ".sde", or ".mdf" in their name.  Otherwise accepts mid-string spaces and "."s (dots) in directory names.  Will not accept special characters in FeatureDataset or BaseName.  Will not accept FeatureDatasets or BaseNames that begin with a number.  Limits total path length to 160 characters.  Accepts file, personal, sde, and SQL GDBs, as well as shapefiles.  Shapefiles have the ".shp" extension and cannot appear in geodatabases.  Accepts GDB Feature Datasets.  Identifies <Workspace>, <Root>, <Drive>, <Server>, <DirectoryTree>, <Directory>, <Geodatabase>, <GDBName>, <Extension>, <FeatureDataset>, and <BaseName> as sub-strings.
# ID: 3432
(?=^.{1,160}$)^(?:(?<Workspace>(?<Root>(?:(?<Drive>[a-zA-Z]\:)|(?<Server>\\{2}[a-zA-Z]\w*)))(?<DirectoryTree>(?:\\(?<Directory>(?:(?![\w\.]*\.(?:gdb|mdb|sde|mdf))[^\\/:*?<>"| .]+[^\\/:*?<>"|]*[^\\/:*?<>"| .]+)))*)(?:\\(?<Geodatabase>(?<GDBName>[a-zA-Z]\w*)(?<Extension>\.(?:gdb|mdb|sde|mdf))))?)\\?(?<FeatureDataset>[a-zA-Z]\w*)?(?:\\(?<BaseName>[a-zA-Z]\w*(?:\.shp)?)(?<!.+\k<Extension>.+\.shp|(?<!.+\k<Extension>.+)(?<!.+\.shp))))$

# Expression for validation of one or more emails separated by semicolon(;)
# ID: 3013
^([a-z0-9,!#\$%&'\*\+/=\?\^_`\{\|}~-]+(\.[a-z0-9,!#\$%&'\*\+/=\?\^_`\{\|}~-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*\.([a-z]{2,})){1}(;[a-z0-9,!#\$%&'\*\+/=\?\^_`\{\|}~-]+(\.[a-z0-9,!#\$%&'\*\+/=\?\^_`\{\|}~-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*\.([a-z]{2,}))*$

# Accepts only positive decimal values. Zero and negatvie numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.
# ID: 251
(^\d*\.?\d*[1-9]+\d*$)|(^[1-9]+\d*\.\d*$)

# Accepts only negative decimal values. Zero and positive numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.
# ID: 252
(^-\d*\.?\d*[1-9]+\d*$)|(^-[1-9]+\d*\.\d*$)

# Allows up to seven digits to the left and up to nine digits to the right of an optional decimal place.
# ID: 1049
^(?=.*[1-9].*$)\d{0,7}(?:\.\d{0,9})?$

# match time for : H:nn:ss or HH:nn:ss
# ID: 3093
^([0-1]?[0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$

# Checks whether the price is the correct format
# ID: 3308
^[0-9]+([\,|\.]{0,1}[0-9]{2}){0,1}$

# UK National Insurance (NI) Number, updated 14 Dec 2005 and current for 2006.
# ID: 1080
^((A[ABEHKLMPRSTWXYZ])|(B[ABEHKLMT])|(C[ABEHKLR])|(E[ABEHKLMPRSTWXYZ])|(GY)|(H[ABEHKLMPRSTWXYZ])|(J[ABCEGHJKLMNPRSTWXYZ])|(K[ABEHKLMPRSTWXYZ])|(L[ABEHKLMPRSTWXYZ])|(M[AWX])|(N[ABEHLMPRSWXYZ])|(O[ABEHKLMPRSX])|(P[ABCEGHJLMNPRSTWXY])|(R[ABEHKMPRSTWXYZ])|(S[ABCGHJKLMNPRSTWXYZ])|(T[ABEHKLMPRSTWXYZ])|(W[ABEKLMP])|(Y[ABEHKLMPRSTWXYZ])|(Z[ABEHKLMPRSTWXY]))\d{6}([A-D]|\s)$

# Simple Microsoft product key check.
# ID: 1081
^[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}$

# Basic UK child benefit reference number.
# ID: 772
^[A-Z]{3}\d{8}$

# UK http/https/ftp URI. Based on my previous expression, this one takes an optional port number and optional trailing slash.
# ID: 741
^(ht|f)tp((?<=http)s)?://((?<=http://)www|(?<=https://)www|(?<=ftp://)ftp)\.(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\-](([a-z0-9\-][a-z0-9])|([a-z0-9][a-z0-9\-]))[a-z0-9\-]*[a-z0-9]))\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\.uk(:\d+)?\/?$

# UK domain names. Includes the following restrictions from Nominet as at time of posting:
# ID: 686
^(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\-](([a-z0-9\-][a-z0-9])|([a-z0-9][a-z0-9\-]))[a-z0-9\-]*[a-z0-9]))\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\.uk$

# UK domains with protocol for http/https/ftp. Based on my previous expression, this allows the subdomain "www" for the http/https protocols, or "ftp" for the ftp protocol only.
# ID: 687
^(ht|f)tp((?<=http)s)?://((?<=http://)www|(?<=https://)www|(?<=ftp://)ftp)\.(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\-](([a-z0-9\-][a-z0-9])|([a-z0-9][a-z0-9\-]))[a-z0-9\-]*[a-z0-9]))\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\.uk$

# Matches valid reference codes for AMD Athlon and Duron processors (not Athlon 64).
# ID: 936
^((A(((H[MX])|(M(P|SN))|(X((D[ACH])|(M[DS]))?)))?)|(K7(A)?)|(D(H[DLM])?))(\d{3,4})[ABD-G][CHJK-NPQT-Y][Q-TV][1-4][B-E]$

# UK vehicle registration system. This is the obvious combination of two previous expressions posted here, to merge the older system with the current system.
# ID: 617
^([A-Z]{3}\s?(\d{3}|\d{2}|d{1})\s?[A-Z])|([A-Z]\s?(\d{3}|\d{2}|\d{1})\s?[A-Z]{3})|(([A-HK-PRSVWY][A-HJ-PR-Y])\s?([0][2-9]|[1-9][0-9])\s?[A-HJ-PR-Z]{3})$

# UK vehicle registration system currently in use (as defined by the DVLA and put into effect from September 2001, and therefore does not allow registrations prior to this date).
# ID: 595
^([A-HK-PRSVWY][A-HJ-PR-Y])\s?([0][2-9]|[1-9][0-9])\s?[A-HJ-PR-Z]{3}$

# UK vehicle registration system prior to September 2001. Allows both older suffix and the later prefix formats in simple form, with optional spaces.
# ID: 596
^([A-Z]{3}\s?(\d{3}|\d{2}|d{1})\s?[A-Z])|([A-Z]\s?(\d{3}|\d{2}|\d{1})\s?[A-Z]{3})$

# UK mobile phone number, with optional +44 national code. Allows optional brackets and spaces at appropriate positions.
# ID: 592
^(\+44\s?7\d{3}|\(?07\d{3}\)?)\s?\d{3}\s?\d{3}$

# Modified version of UK phone number regular expression. Now allows +44 national code in addition to extension numbers of 3 or 4 digits. Previous expression was: ^((\(?0\d{4}\)?\s?\d{3}\s?\d{3})|(\(?0\d{3}\)?\s?\d{3}\s?\d{4})|(\(?0\d{2}\)?\s?\d{4}\s?\d{4}))(\s?#(\d{4}|\d{3}))?$
# ID: 593
^(((\+44\s?\d{4}|\(?0\d{4}\)?)\s?\d{3}\s?\d{3})|((\+44\s?\d{3}|\(?0\d{3}\)?)\s?\d{3}\s?\d{4})|((\+44\s?\d{2}|\(?0\d{2}\)?)\s?\d{4}\s?\d{4}))(\s?\#(\d{4}|\d{3}))?$

# UK phone number. Allows 3, 4 or 5 digit regional prefix, with 8, 7 or 6 digit phone number respectively, plus optional 3 or 4 digit extension number prefixed with a # symbol. Also allows optional brackets surrounding the regional prefix and optional spaces between appropriate groups of numbers.
# ID: 589
^((\(?0\d{4}\)?\s?\d{3}\s?\d{3})|(\(?0\d{3}\)?\s?\d{3}\s?\d{4})|(\(?0\d{2}\)?\s?\d{4}\s?\d{4}))(\s?\#(\d{4}|\d{3}))?$

# Regex for Dutch zip/postal codes. A Dutch zip code exists of 4 numbers and 2 letters. The first number must be a 0 or higher. Letter combinations of "SS", "SD" and "SA" are excluded for historical reasons.
# ID: 3616
[1-9][0-9]{3}(?!SS|SA|SD)[A-Z]{2}

# Password must have at least 8 characters with at least one Capital letter, at least one lower case letter and at least one number or special character.
# ID: 2204
(?-i)(?=^.{8,}$)((?!.*\s)(?=.*[A-Z])(?=.*[a-z]))((?=(.*\d){1,})|(?=(.*\W){1,}))^.*$

# I got a regex for date time from here, which had some bugs. so i referred a few regex from this site and created a regex which i tested and didnt find any errors. I will check again and update if required.
# ID: 2411
^(0[1-9]|1[012])[/](0[1-9]|[12][0-9]|3[01])[/][0-9]{4}(\s((0[1-9]|1[012])\:([0-5][0-9])((\s)|(\:([0-5][0-9])\s))([AM|PM|]{2,2})))?$

# This is the US date expression. It's very flexible on omitting numbers.
# ID: 3053
^(0?\d|1[012])\/([012]?\d|3[01])\/(\d{2}|\d{4})$

# Works with virtual or file include type and double or single quotes.  Breaks out include type, include file path, and include file name.
# ID: 1603
<!--\s*\#\s*include\s+(file|virtual)\s*=\s*(["'])([^"'<>\|\b]+/)*([^"'<>/\|\b]+)\2\s*-->

# Validates MM/YY for rough checking credit card expiration dates.
# ID: 262
^((0[1-9])|(1[0-2]))\/(\d{2})$

# 24 hour clock as prefered by MS-SQL, allows for shorter more human methods of writing time (no preceding zero or seconds required).
# ID: 717
^(20|21|22|23|[01]\d|\d)(([:.][0-5]\d){1,2})$

# Brazilia ZIP Code validation!
# ID: 767
((^\d{5}$)|(^\d{8}$))|(^\d{5}-\d{3}$)

# Telefone for Brazilian telefone standard. The Area code is optional.
# ID: 768
^(\d{2,3}|\(\d{2,3}\))?[ ]?\d{3,4}[-]?\d{3,4}$

# Validation for Brazilian telephone with required area code.
# ID: 769
^(\d{2,3}|\(\d{2,3}\))[ ]?\d{3,4}[-]?\d{3,4}$

# This will match date values with the format mm-dd-yyyy or mm/dd/yyyy
# ID: 2807
/^\d{2}[\-\/]\d{2}[\-\/]\d{4}$/

# We have be receiving a lot of Spam with this Return-Path address. It uses diferent ref. numbers all the time So I created this pattern.
# ID: 883
(antifraud\.ref\.num)[0-9]*(@citibank\.com)

# Anti-Spam/Spam stopper: Detects all words with the character "|" instead of an "l" or "1"
# ID: 1061
(^.+\|+[A-Za-z])

# AntiSpam: matches variations on the word "pharmacy"
# ID: 1020
(?i)(pharmacy)|((p(.{1,3})?h(.{1,3})?a(.{1,3})?r(.{1,3)?m(.{1,3})?a(.{1,3})?c(.{1,3})?y))

# test for valid day, 01 to 31 and 1 to 31
# ID: 2662
^[0-2]?[1-9]{1}$|^3{1}[01]{1}$

# This will match just about everything after href=
# ID: 972
href=[\"\']?((?:[^>]|[^\s]|[^"]|[^'])+)[\"\']?

# Matches a Swedish social security number in format xxYYMMDD-NNNN, xxYYMMDD+NNNN, YYMMDD-NNNN, YYMMDD-NNNN and YYMMDDNNN. Does not allow birth years before 1900 and after 2011.
# ID: 3351
\b(((20)((0[0-9])|(1[0-1])))|(([1][^0-8])?\d{2}))((0[1-9])|1[0-2])((0[1-9])|(2[0-9])|(3[01]))[-+]?\d{4}[,.]?\b

# Matches a Swedish social security number in format CCYYMMDD-NNNN, CCYYMMDDNNNN, YYMMDD-NNNN and YYMMDDNNNN on a single line. More useful version of my earlier expression. Will only match 1900 - 2011 years.
# ID: 3354
^(((20)((0[0-9])|(1[0-1])))|(([1][^0-8])?\d{2}))((0[1-9])|1[0-2])((0[1-9])|(2[0-9])|(3[01]))[-]?\d{4}$

# Matches most theoretical e-mail patterns including Swedish letters and custom top domains.
# ID: 3463
^(?=.*\S)[-!#$%&\'*+\/=?^_`{|}~,.a-z0-9]{1,64}[@]{1}[-.a-zåäö0-9]{4,253}$

# Check if a string contains at least 6 characters. Can not end or start with whitespace but can contain any other. PCRE optimized with none-capturing parentheses.
# ID: 3464
^\S{1}(?:.){4,}\S$

# Matched Australian Postcodes, as defined by AusPost.
# ID: 797
^(((2|8|9)\d{2})|((02|08|09)\d{2})|([1-9]\d{3}))$

# Matches positive whole numbers from 0-999
# ID: 399
^\d(\d)?(\d)?$

# Matching any file extension.
# ID: 1649
(^\*\.[a-zA-Z][a-zA-Z][a-zA-Z]$)|(^\*\.\*$)

# Phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444)? then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits
# ID: 2559
^[+]\d{1,2}\(\d{2,3}\)\d{6,8}(\#\d{1,10})?$

# This expression will test against most URLs and return whether they are valid URL's or not. It will allow some false positives in that it is only checking for the correct character count, but this could be enhanced by adjusting it to check for specific TLDs or file extensions.
# ID: 2905
/^(https?|ftp)(:\/\/)(([\w]{3,}\.[\w]+\.[\w]{2,6})|([\d]{3}\.[\d]{1,3}\.[\d]{3}\.[\d]{1,3}))(\:[0,9]+)*(\/?$|((\/[\w\W]+)+\.[\w]{3,4})?$)/

# A simple expression to brazilian phone number code, with international code.
# ID: 135
^([0-9]{2})?(\([0-9]{2})\)([0-9]{3}|[0-9]{4})-[0-9]{4}$

# Other expression to standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).
# ID: 136
^\d{2}(\x2e)(\d{3})(-\d{3})?$

# Finally, an expression that can reliably match any valid URL/URN! Future proof against vanity TLDs, doesn't require a schema, can parse IPv4s with or without port, can parse regular URLs with/without port, can accept extra baggage at the end, and, with a slight modification (a la ^$ and changing the final rule around a bit) this can be used to find and activate URLs in bodies of text safely and reliably. Have fun (tell me if it could be improved)!
# ID: 3197
^((nntp|sftp|ftp(s)?|http(s)?|gopher|news|file|telnet):\/\/)?(([a-zA-Z0-9\._-]*([a-zA-Z0-9]\.[a-zA-Z0-9])[a-zA-Z]{1,6})|(([0-9]{1,3}\.){3}[0-9]{1,3}))(:\d+)?(\/[^:][^\s]*)?$

# Match to just about any valid human name you could think of.
# ID: 3198
^\s*([A-Za-z]{2,4}\.?\s*)?(['\-A-Za-z]+\s*){1,2}([A-Za-z]+\.?\s*)?(['\-A-Za-z]+\s*){1,2}(([jJsSrR]{2}\.)|([XIV]{1,6}))?\s*$

# After searching for one, I just said "screw it" and wrote my own, and here she is. A regular expression to match against phone numbers, both international and USA!
# ID: 3199
^((\+)?[1-9]{1,4})?([-\s\.\/])?((\(\d{1,4}\))|\d{1,4})(([-\s\.\/])?[0-9]{1,6}){2,6}(\s?(ext|x)\s?[0-9]{1,6})?$

# It allows only alphanumeric characters and some special symbols like "&",".","-"and"_"before'@'.After'@' symbolagain only alphanumeric character set are allowed.Then there should be a "."and after that it may have either three letter's word or two letter's word with a "."and one more two letter word attached with it. for example: noni@yahoo.com OR noni@yahoo.co.in.
# ID: 1980
/^([a-zA-Z0-9\.\_\-\&]+)@[a-zA-Z0-9]+\.[a-zA-Z]{3}|(.[a-zA-Z]{2}(\.[a-zA-Z]{2}))$/

# Email Validator. Enmail address has to start with alphabets
# ID: 818
^[a-zA-Z]+[a-zA-Z0-9_-]*@([a-zA-Z0-9]+){1}(\.[a-zA-Z0-9]+){1,2}

# This Expression exclude any word/code from a sentence.
# ID: 1244
\s?\b((?!\b50\b|\b00\b)\w*)\b\s?

# [Default]
# ID: 239
\({1}[0-9]{3}\){1}\-{1}[0-9]{3}\-{1}[0-9]{4}

# Current SSN randomization rules, also caled Social Security Number Randomization, effective since June 25, 2011. Validates 9 digit numbers, not separated or separated by - or space, not starting with 000, 666, or 900-999, not containing 00 or 0000 in the middle or at the end of SSN.
# ID: 3580
^(?!000)(?!666)([0-8]\d{2}) ([ -])? (?!00)\d\d ([ -])? (?!0000)\d{4}$

# valida email
# ID: 3026
(([\w-]+(?:\.[\w-]+)*)@(timbrasil.com.br))*

# validate usernames with dot or underscoures doesn't allow spaces and accept characters between 5 and 15 no other characters
# ID: 2719
^[\w_.]{5,12}$

# validate text against spaces and accept from 5 to 12 character
# ID: 2720
^([^\s]){5,12}$

# Regular Expression for Egypt Mobile Network
# ID: 2711
^(01)[0-9]{8}

# A general string validation to insure that NO malicious code or specified characters are passed through user input.  This will allow you to input any characters except those specified.  The expression above does not allow user input of <>`~!/@\#}$%:;)(_^{&*=|'+. Input as many invalid characters you wish to deny.  This really works!
# ID: 412
^[^<>`~!/@\#}$%:;)(_^{&*=|'+]+$

# Matches single line or multi-line comments.
# ID: 2507
//.*|/\*[\s\S]*?\*/

# I was looking for a regex that allows pretty much any combo of a US phone number. I found some that covered most of the bases, but not all of them.
# ID: 2612
/^(1)?(-|.)?(\()?([0-9]{3})(\))?(-|.)?([0-9]{3})(-|.)?([0-9]{4})/

# This regex matches all (14.095.120.151.883.281.746.489.830.170.974.347.714.655.937) valid IPv6 address _representations_ as described by RFC 4291.
# ID: 3065
/^(((?=.*(::))(?!.*\3.+\3))\3?|([\dA-F]{1,4}(\3|:\b|$)|\2))(?4){5}((?4){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})\z/i

# Checks to make sure that entry starts with http:// or https://  and that contents are limited to alphas . - /
# ID: 2247
http[s]?://[a-zA-Z0-9.-/]+

# [Default]
# ID: 346
^[a-zA-Z0-9]{1,20}$

# select .cn from domain where nic.deleted
# ID: 2851
^[a-zA-Z0-9\-]+\.cn$

# Matches mysql single-quoted string literals. double quotes and backslashed quotes are recognised.
# ID: 3251
(\'([^\'\\]*\\.)*[^\'\\]*\')+

# Sql date format tester.
# ID: 93
20\d{2}(-|\/)((0[1-9])|(1[0-2]))(-|\/)((0[1-9])|([1-2][0-9])|(3[0-1]))(T|\s)(([0-1][0-9])|(2[0-3])):([0-5][0-9]):([0-5][0-9])

# Matches persian(farsi) charctes from latin
# ID: 2320
/([^\x00-\xFF]\s*)/u

# Returns string with all alphabetic characters converted to uppercase.
# ID: 2321
/(<\/?)(\w+)([^>]*>)/e

# This expression validates for valid C# or C++ identifier
# ID: 419
^[a-zA-Z_]{1}[a-zA-Z0-9_]+$

# The goal of this regular expression is to replace all & (ampersand) characters by &amp; if they are not the start of HTML entities. I used
# ID: 532
&(?![a-zA-Z]{2,6};|#[0-9]{3};)

# Aceita duas casas decimas após a vírgula. Pode ser usado para Real Brasil.
# ID: 2547
^([1-9]{1}[\d]{0,2}(\.[\d]{3})*(\,[\d]{0,2})?|[1-9]{1}[\d]{0,}(\,[\d]{0,2})?|0(\,[\d]{0,2})?|(\,[\d]{1,2})?)$

# String formater matching.
# ID: 571
.\{\d\}

# Simple regex for the Swedish personal number. It's in the form: YYMMDD-xxxx where xxxx is an arbitrary number from 0000-9999.
# ID: 1880
^\d{2}([0][1-9]|[1][0-2])([0][1-9]|[1-2][0-9]|[3][0-1])-\d{4}$

# International Phone Number separated into its component parts by dashes (International Country Code, International Area Code, International Phone Number, and optional 1-4 digit Extension). (The separator before extension is one or more characters that are not a dash or a number.) This allows explicit parsing/extraction of the extension.
# ID: 2187
^011-(?<IntlCountryCode>[1-9][0-9]{1,5})-(?<IntlAreaCode>[0-9]+)-(?<IntlPhoneNumber>[0]?\d[0-9]+)(?:[^\d\-]+(?<IntlExtension>\d{1,4}))?$

# This pattern is set to case in-sensitive (i.e '/i').
# ID: 2934
/^[a-z][\w\.]+@([\w\-]+\.)+[a-z]{2,7}$/i

# Used to check US phone pattern
# ID: 2935
^[\d]{3}[\s\-]*[\d]{3}[\s\-]*[\d]{4}\s*$

# hi i want to evaluate the following expression with regular expression.
# ID: 2136
<link href="../Common/Styles/iLienStyle.css" type="text/css" rel="stylesheet" />

# This is regular expression for date.
# ID: 3045
\d{1,2}(/|-)\d{1,2}(/|-)\d{2,4}

# This is Regular Expression for COBOL's Move Verb.
# ID: 3017
(?i)\s*MOVE\s+\w+(\-\w+)*\s+TO\s+\w+(\-\w+)*

# Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato será necesario validar su dígito verificador.
# ID: 1597
^\d{1,2}\.\d{3}\.\d{3}[-][0-9kK]{1}$

# This .NET Framework expression tests a submitted password for length, a capital and lower case letter, a number or punctuation character and no spaces.<br />
# ID: 2991
^((?=.{8,32}$)(?=.*\p{Lu})(?=.*\p{Ll})((?=.*\p{N})|(?=.*\p{P}))(?!.*\s))

# Match any number , no characters, no empty sets, and accept zero.
# ID: 2267
^([0-9]{1}[\d]{0,2}(\,[\d]{3})*(\,[\d]{0,2})?|[0-9]{1}[\d]{0,}(\,[\d]{0,2})?|0(\,[\d]{0,2})?|(\,[\d]{1,2})?)$

# Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\"), escaped escaped chars (\\), or be empty (""). Splits (only) on whitespace. (Does not split on opening or closing quotes.) An unclosed quote matches all until end of input. The Matching Examples are ready for enclosure in single quotes. Output of Matching Example 1:
# ID: 3015
/("(\\["\\]|[^"])*("|$)|\S)+/g

# Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (""), escaped escaped chars ("""), or be empty (""). Splits (only) on whitespace. (Does not split on opening or closing quotes.) An unclosed quote matches all until end of input. The Matching Examples are ready for enclosure in single quotes. Output of Matching Example 1:
# ID: 3016
("(?!")(""|[^"])*("|$)|\S)+/g

# JavaScript match() method (or equivalent) creates an array of lines from a text file. This pattern handles lines ending with \r\n as well as \n at the expense of including the line-ending chars in the output. The Matching Examples are ready for enclosure in single quotes. Output from Matching Example 1: [0]=a " b [\n] " c [\n]
# ID: 3018
/^("(\\["\\]|[^"])*"|[^\n])*(\n|$)/gm

# Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\"), escaped escaped chars (\\), or be empty (""). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Examples are ready for enclosure in single quotes. Output of Matching Example 1:
# ID: 3019
/"(\\["\\]|[^"])*("|$)|(\\["\\]|[^\s"])+/g

# Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (""), escaped escaped chars ("""), or be empty (""). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Examples are ready for enclosure in single quotes. Output of Matching Example 1:
# ID: 3020
/"(?!")(""|[^"])*("|$)|(("")+|[^\s"])+/g

# JavaScript match() method (or equivalent) creates an array of lines from a text file. This pattern only handles lines ending with \n, not \r\n. The Matching Examples are ready for enclosure in single quotes. Output from Matching Example 1:
# ID: 3023
/^("(\\["\\]|[^"])*"|[^\n])*$/gm

# Does not validate. For parsing a file name known to be valid. Handles periods in the file name. Does not include terminating characters in the output, as preferred. Javascript exec() method produces the following array elements: [1]=drive; [2]=path; IF extension exists THEN [3]=filename; [4]=extension; ELSE [3]=undefined; [4]=filename. (To avoid the awkwardness, see "Parse Windows Filename (complex version)."
# ID: 3032
/(?:(.):)?(?:(.*)\\)?(?:(.*)\.)?(.*)/

# Does not validate. For parsing a file name known to be valid. Handles periods in the file name. Does not include  terminating characters in the output, as preferred. Javascript exec() method produces the following array elements: [1]=drive; [2]=path; [3]=filename; [4]=extension; Matching Example 1 output: [1]=d
# ID: 3035
/(?:(.):)?(?:(.*)\\)?((?:[^.]|.(?=[^.]*\.))*)(?:\.(.*))?/

# Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\' or \"), escaped escaped chars (\\), or be empty ('' or ""). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Example is ready for enclosure in single quotes. Output of Matching Example: [0]=a
# ID: 3036
/"(\\["\\]|[^"])*("|$)|'(\\['\\]|[^'])*('|$)|(\\["'\\]|[^\s"'])+/g

# JavaScript match() method (or equivalent) creates an array of lines from a text file. This pattern handles lines ending with \r\n as well as \n at the expense of including the line-ending chars in the output. The Matching Example is ready for enclosure in single quotes. Output from Matching Example: [0]=a " b [\n] " 'c[\n]' [\n]
# ID: 3037
/^("(\\"|[^"])*"|'(\\'|[^'])*'|[^\n])*(\n|$)/gm

# It Allows Only One decimal point in a given number
# ID: 2984
^\d*(\.\d*)$

# It Will check for unique Pattern Which we have used in our project
# ID: 2985
^\d{1}(\.\d{3})-\d{3}(\.\d{1})$

# Field Should accept only - and . in special characters and it should allow only numeric data
# ID: 2989
^[-]?\d*(\.\d*)$

# This will validate atleast minimum of one digit in either side of Decimal point
# ID: 3067
^(\d+\.\d+)$

# Isolates MySQL Query strings and comments. Lines that look like comments inside strings are not falsely recognised as comments. To strip comments from a MySQL Query, simply replace all matches with group 1
# ID: 2987
("(?:(?:(?:\\.)|[^"\\\r\n])*)"|'(?:(?:(?:\\.)|[^'\\\r\n])*)'|`(?:(?:(?:\\.)|[^`\\\r\n])*)`)|((?:-- .*)|(?:#.*)|(?:/\*(?:(?:[^*]|\*(?!/))*)\*/))

# Splits a mysql query file by matching everything but the semicolon at the end. Handles all three comments ("-- ", "#", "/*...*/"), all three quotes (", ', `), and all three line break styles (\r, \n, \r\n).
# ID: 2946
# Multiline
(?:""(?:(?:(?:\\.)|[^""\\\r\n])*)""|'(?:(?:(?:\\.)|[^'\\\r\n])*)'|`(?:(?:(?:\\.)|[^`\\\r\n])*)`|(?:\s?(?:\#|--\ ).*(?=[\r\n]))|(?:/\*(?:(?:[^*]|\*(?!/))*)\*/)|(?:[^;`'""](?!(?:--\ |\#|/\*)))*(?:[^;`'""](?=(?:--\ |\#|/\*)))?)*

# Most Concise RegExp for matching Decimal IPs.  If nothing else, it'll make your code easier to read.  (And I know that \d?\d is \d{1,2} but that's 2 extra characters.)
# ID: 42
\b(([01]?\d?\d|2[0-4]\d|25[0-5])\.){3}([01]?\d?\d|2[0-4]\d|25[0-5])\b

# The date field takes all values with slashes. Leap year is taken care of Year has to be specified in 4digit. Time is a 12hrclock taking am n pm(case insensitive). AM or Pm has to be specified. Not suited for 24hr clock. In the format of SQL Server datetime field
# ID: 1703
^((((0?[1-9]|1[012])/(0?[1-9]|1\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\d)\d{2}|0?2/29/((19|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))))[\s]((([0]?[1-9]|1[0-2])(:|\.)[0-5][0-9]((:|\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\.)[0-5][0-9]((:|\.)[0-5][0-9])?))$

# To find ISBN-10 or ISBN-13 text
# ID: 3497
ISBN(-1(?:(0)|3))?:?\x20(\s)*[0-9]+[- ][0-9]+[- ][0-9]+[- ][0-9]*[- ]*[xX0-9]

# My first submission. Probably pretty obvious. Just wanted something that would  check text boxes that non-programmers might fill out. Some of this came from http://www.reducedcomplexity.com/
# ID: 777
^\s*[a-zA-Z0-9,\s\-\'\.]+\s*$

# Brazilian format for date validating in MySql UDF.
# ID: 2287
^([1-9]|0[1-9]|[12][0-9]|3[01])(-|/)(([1-9]|0[1-9])|(1[0-2]))(-|/)(([0-9][0-9])|([0-9][0-9][0-9][0-9]))$

# Matches all IPV6 and IPV4 addresses.  Doesn't limit IPV4 to just values of 255. Doesn't allow IPV6 compression.
# ID: 1431
([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\d{1,3}\.){3}\d{1,3}

# This pattern validates a British Ordnance Survey Grid/Tile/Sheet Reference Number. Information on the range of possible values can be found here: http://www.ordnancesurvey.co.uk/oswebsite/gps/information/coordinatesystemsinfo/guidetonationalgrid/page17.html. Grid Ref, Tile Ref, Sheet Ref.
# ID: 1436
^(H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}\d{4}(NE|NW|SE|SW)?$|((H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}(\d{4}|\d{6}|\d{8}|\d{10}))$

# I wrote this after I couldn't find an expression that would search for valid URLs, whether they had HTTP in front or not.  This will find those that don't have hyphens anywhere in them (except for after the domain).
# ID: 939
^(?<link>((?<prot>http:\/\/)*(?<subdomain>(www|[^\-\n]*)*)(\.)*(?<domain>[^\-\n]+)\.(?<after>[a-zA-Z]{2,3}[^>\n]*)))$

# UK Street Address splits streetname and housenumber.
# ID: 2852
\A(\d+[a-zA-Z]{0,1}\s{0,1}[-]{1}\s{0,1}\d*[a-zA-Z]{0,1}|\d+[a-zA-Z-]{0,1}\d*[a-zA-Z]{0,1})\s*+(.*)

# This pattern splits the streetname and housenumber of Dutch Postal Addresses.
# ID: 2854
\A(.*?)\s+(\d+[a-zA-Z]{0,1}\s{0,1}[-]{1}\s{0,1}\d*[a-zA-Z]{0,1}|\d+[a-zA-Z-]{0,1}\d*[a-zA-Z]{0,1})

# A regexp for general username entry. Which doesn't allow special characters other than underscore. Username must be of length ranging(3-30). starting letter should be a number or a character.
# ID: 2748
^[a-zA-Z0-9][a-zA-Z0-9_]{2,29}$

# This expression validate the add of numbers with or without decimal
# ID: 2234
^(\d{1,4}?[.]{0,1}?\d{0,3}?)$

# Suitable for extraction of all hyperlinks in the format:
# ID: 845
# Multiline
<\s*a\s[^>]*\bhref\s*=\s*('(?<url>[^']*)'|""(?<url>[^""]*)""|(?<url>\S*))[^>]*>(?<body>(.|\s)*?)<\s*/a\s*>

# Matches valid VAT identification number for all current EU's member states, in format CC-xxx or CCxxx (where CC is country code and xxx actual VAT number).
# ID: 786
((DK|FI|HU|LU|MT|SI)(-)?\d{8})|((BE|EE|DE|EL|LT|PT)(-)?\d{9})|((PL|SK)(-)?\d{10})|((IT|LV)(-)?\d{11})|((LT|SE)(-)?\d{12})|(AT(-)?U\d{8})|(CY(-)?\d{8}[A-Z])|(CZ(-)?\d{8,10})|(FR(-)?[\dA-HJ-NP-Z]{2}\d{9})|(IE(-)?\d[A-Z\d]\d{5}[A-Z])|(NL(-)?\d{9}B\d{2})|(ES(-)?[A-Z\d]\d{7}[A-Z\d])

# GPA (Grade Point Average) expression.  Validates the standars 0.0 thru 4.0 and also accepts 5.5 -- which I use as unknown.
# ID: 1002
(^([1-3]{1}[0-9]{0,}(\.[0-9]{1})?|0(\.[0-9]{1})?|[4]{1}[0-9]{0,}(\.[0]{1})?|5(\.[5]{1}))$)

# Format od the French Socisl Security Number
# ID: 3071
([1,2].)(\d{2}.)(\d{2}.)(\d{2}.)(\d{3}.)(\d{3}.)(\d{2})

# US Addresses validation having atleast 3 characters ignoring any spaces. Can have hash "#" comma "," dash "-" dot "." but cannot start with these.
# ID: 2369
^[a-zA-Z0-9]+[\s]*[a-zA-Z0-9.\-\,\#]+[\s]*[a-zA-Z0-9.\-\,\#]+[a-zA-Z0-9\s.\-\,\#]*$

# Match a positive or negative decimal value with any precision and scale.  Allows for left-padded zeroes, commas as group separator, negative sign (-) or parenthesis to indicate negative number.
# ID: 943
^\-?\(?([0-9]{0,3}(\,?[0-9]{3})*(\.?[0-9]*))\)?$

# Versioning in XX.YY.ZZ format
# ID: 3162
^([0-9][0-9])[.]([0-9][0-9])[.]([0-9][0-9])$

# used to validate form fields values for positive integer values greater than 0 without explicitly checking if the input form value is greater than 0
# ID: 1606
^(0+[1-9]|[1-9])[0-9]*$

# Formato de placas de veículos padrão brasileiro.
# ID: 3572
^[A-Z]{3}-[0-9]{4}$

# Matches the LDAP path of Microsoft Active Directory entry.  Checks to ensure the ADsPath attribute is accurate.
# ID: 795
^((CN=['\w\d\s\-\&]+,)+(OU=['\w\d\s\-\&]+,)*(DC=['\w\d\s\-\&]+[,]*){2,})$

# Uses backreferences and word boundaries to match repeated words seperated by whitespace without matching a word with the same ending as the next words beginning.
# ID: 78
\b(\w+)\s+\1\b

# I think this is the ultimate url match expression to every possible url pattern including named or ip address domain
# ID: 2884
^(?:(?:http|https|ftp|telnet|gopher|ms\-help|file|notes)://)?(?:(?:[a-z][\w~%!&',;=\-\.$\(\)\*\+]*):.*@)?(?:(?:[a-z0-9][\w\-]*[a-z0-9]*\.)*(?:(?:(?:(?:[a-z0-9][\w\-]*[a-z0-9]*)(?:\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))(?::[0-9]+)?))?(?:(?:(?:/(?:[\w`~!$=;\-\+\.\^\(\)\|\{\}\[\]]|(?:%\d\d))+)*/(?:[\w`~!$=;\-\+\.\^\(\)\|\{\}\[\]]|(?:%\d\d))*)(?:\?[^#]+)?(?:#[a-z0-9]\w*)?)?$

# I think this is a very good e-mail validation match expression
# ID: 2885
^(?:mailto:)?(?:[a-z][\w~%!&',;=\-\.$\(\)\*\+]*)@(?:[a-z0-9][\w\-]*[a-z0-9]*\.)*(?:(?:(?:[a-z0-9][\w\-]*[a-z0-9]*)(?:\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))$

# accepts:
# ID: 2886
^(?<username>[a-z][\w.-]*)(?::(?<pwd>[\w.-]*))$

# accepts
# ID: 2887
^(?:[a-z0-9][\w\-]*[a-z0-9]*\.)*(?:(?:(?:[a-z0-9][\w\-]*[a-z0-9]*)(?:\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))$

# parse/match url path with:
# ID: 2888
^(?:(?:\.\./)|/)?(?:\w(?:[\w`~!$=;\-\+\.\^\(\)\|\{\}\[\]]|(?:%\d\d))*\w?)?(?:/\w(?:[\w`~!$=;\-\+\.\^\(\)\|\{\}\[\]]|(?:%\d\d))*\w?)*(?:\?[^#]+)?(?:#[a-z0-9]\w*)?$

# break apart all possible elements of a url to every possible url part
# ID: 2892
^(?<scheme>(?:http|https|ftp|telnet|gopher|ms\-help|file|notes)://)?(?:(?<user>[a-z][\w~%!&',;=\-\.$\(\)\*\+]*):(?<password>.*)?@)?(?:(?<domain>(?:[a-z0-9]\w*[a-z0-9]*\.)*(?:(?:(?:[a-z0-9]\w*[a-z0-9]*)(?:\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))))(?::(?<port>[0-9]+))?)?(?:(?<path>(?:/(?:[\w`~!$=;\-\+\.\^\(\)\|\{\}\[\]]|(?:%\d\d))+)*/(?:[\w`~!$=;\-\+\.\^\(\)\|\{\}\[\]]|(?:%\d\d))*)(?<params>\?[^#]+)?(?<fragment>#[a-z0-9]\w*)?)?$

# I think this is the ultimate url match expression to every possible url pattern including named or ip address domain PS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com
# ID: 2893
((http|https|ftp|telnet|gopher|ms\-help|file|notes)://)?(([a-z][\w~%!&',;=\-\.$\(\)\*\+]*)(:.*)?@)?(([a-z0-9][\w\-]*[a-z0-9]*\.)*(((([a-z0-9][\w\-]*[a-z0-9]*)(\.[a-z0-9]+)?)|(((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))(:[0-9]+)?))?(((/([\w`~!$=;\-\+\.\^\(\)\|\{\}\[\]]|(%\d\d))+)*/([\w`~!$=;\-\+\.\^\(\)\|\{\}\[\]]|(%\d\d))*)(\?[^#]+)?(#[a-z0-9]\w*)?)?

# matches # + 3 hex numbers + optional 3 more hex numbers and 2 more hex numbers for alpha
# ID: 2890
^#[\dA-Fa-f]{3}(?:[\dA-Fa-f]{3}[\dA-Fa-f]{0,2})?$

# This re was used for set numbers only!
# ID: 257
^[+]?\d*$

# Expression to parse Australian landline telephone numbers. Will only accept valid STD codes. Allows for brackets around the STD code and either spaces or dashes between number groups.
# ID: 1062
^\({0,1}0(2|3|7|8)\){0,1}(\ |-){0,1}[0-9]{4}(\ |-){0,1}[0-9]{4}$

# THE Complex Password Filter Matching 3 of 4 Character catagories:
# ID: 887
(?=^.{6,255}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9])(?=.*[a-z])|(?=.*[^A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9]))^.*

# In Singapore, the first digit must start with a "6", and the rest is made up of 7 digits, which means that there are 8 digits in a Singapore's telephone number.
# ID: 2777
^[6]\d{7}$

# The National Registry Identification Number (NRIC) of Singapore is made up of the first character being a S/F/T or G. The next 2 numbers is the year of birth for people born 1967 and later. The last character is a checksum done on the numbers, and the algorithm will not be released.
# ID: 2778
^[SFTG]\d{7}[A-Z]$

# This expression will match quoted string without quote inside string
# ID: 1565
^"[^"]+"$

# alphanumeric - no space allowed - requires at least one character
# ID: 1654
^[\w]{1,}$

# Since MS Excel will be giving you the cell range addresses, this simple regex provides nice match captures.  It may not validate the only possibles that Excel takes, but it is "good enough" for a majority of circumstances.
# ID: 2221
^\$?([A-Za-z]{0,2})\$?([0-9]{0,5}):?\$?([A-Za-z]{0,2})\$?([0-9]{0,5})$

# Easy expression that checks for valid email addresses.
# ID: 167
^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$

# Validates the toString from a java.util.Date object. It is NOT formatted for java-source.
# ID: 3349
^(?:\s*(Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s*)(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+?(0?[1-9]|[1-2][0-9]|3[01])\s+(2[0-3]|[0-1][0-9]):([0-5][0-9]):(60|[0-5][0-9])\s+((?:E|C|M|P)(?:ST|DT))\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2})

# By combining the contributions from Bri Gipson and Michael Ash in this site.  I have come up with this RE to exclude the zero dollar amounts such as $0.00, 0.00, 0, etc.
# ID: 1003
^(\$|)([1-9]+\d{0,2}(\,\d{3})*|([1-9]+\d*))(\.\d{2})?$

# Combine Michael Ash's US Dollar amount and Bri Gipson's eliminating zero input to create this RE to accept Optional leading dollar sign, optional well-formed comma separator dollar amount with no zero amount allowed.
# ID: 1005
^(\$|)([1-9]\d{0,2}(\,\d{3})*|([1-9]\d*))(\.\d{2})?$

# Allows a file with the format <drive><directory>yyyy-mm-dd-DailyUpload.csv
# ID: 1400
^(?<Drive>([a-zA-Z]:)|(\\{2}\w+)\$?)(\\(\w[\w].*))(?<Year>\d{4})-(?<Month>\d{1,2})-(?<Day>\d{1,2})(?<ExtraText>.*)(?<Extension>.csv|.CSV)$

# Match a string in CCYYMM/YYYYMM format.
# ID: 963
^[0-9]{4}((0[1-9])|(1[0-2]))$

# Nice for checking local filesystem relative pathing. I used it for testing in php scripts that work with images.
# ID: 1584
^(((\.\.){1}/)*|(/){1})?(([a-zA-Z0-9]*)/)*([a-zA-Z0-9]*)+([.jpg]|[.gif])+$

# allows numbers, umlauts, dots and bars
# ID: 1622
^\w[a-zA-Z0-9öäüÖÄÜ\.\-_]+@[a-zA-Z0-9öäüÖÄÜ\-_]+?\.[a-zA-Z]{2,3}$

# This will accept FL Drivers License numbers with dashes
# ID: 1769
^([a-z|A-Z]{1}[0-9]{3})[-]([0-9]{3})[-]([0-9]{2})[-]([0-9]{3})[-]([0-9]{1})

# I wrote this for a company that was importing a variety of rich text separated by tabs. By applying this regular expression, you can filter out even empty fields which return as a single tab qualified by a tab in front of them unless its the end of the string, which will return a single tab as well. You can filter out the returned tabs in your .NET code.
# ID: 1693
[^\t]+|\t(?=\t)|\t$

# This one matches all strings except "FirstString" and "SecondString"
# ID: 1088
^(?(FirstString|SecondString)yes|.*)$

# Matches the number at the end of the string.
# ID: 738
^((?:.*(?!\d))*(?:\D*)?)(\d+)$

# Simple expression for matching all commas and all whitespace characters:  ASCII (13,10,44)
# ID: 403
[\\s+,]

# Matches a valid "empty" tag (has trailing slash).  Note, if you run it against a string such as <img src="test.gif" alt="<hr />"> it will indeed return a match.  But, the match is not at character 1 like you'd suspect, but rather it's matching the internal <hr />.  If you look at the source of this tag (http://concepts.waetech.com/unclosed_tags/) you'll find a whoe suite of regex's for matching html tags.  Using them you could feasibly step though a document and avoid this mismatch as the outer tag would match *in totality* and you'd completely skip this inner match.
# ID: 387
<[a-zA-Z]+(\s+[a-zA-Z]+\s*=\s*("([^"]*)"|'([^']*)'))*\s*/>

# The following pattern checks whether the input string is a valid email address in the form "name@domain.com". Actually, it does not have to be a ".com" address. Any combination of letters following the last period are fine. Also, the email name can have a dash or be separated by one or more periods. The Domain name can also have multiple words separated by periods. Thus, it will validate bob@hotmail.com and bill.michaels@us.office.gov.
# ID: 897
^([\w-]+\.)*?[\w-]+@[\w-]+\.([\w-]+\.)*?[\w]+$

# This expression will find sigle or multilined HTML comments.
# ID: 859
<!--[\w\W]*?-->

# I built this from the ABNF grammars from necessary pieces from RFC2822, 1034, 5234, and based mainly on 5322 in order to build a complete grammar to make the regex.  I learned compiler technology in college.
# ID: 3057
((((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)|((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*)))?[+A-Za-z0-9!#$%&'*/=?\^_`{}|\~-]+(\.[+A-Za-z0-9!#$%&'*/=?\^_`{}|\~-]+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)|((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*)))?|(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)|((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*)))?\x22((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(([\x21\x23-\x5b\x5d-\x7e]|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f])|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))))*(((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\x22(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\

# RFC5322 is the new email spec that replaces 2822 which replaces 822.
# ID: 3058
((((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)|((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*)))?\<((((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)|((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*)))?[+A-Za-z0-9!#$%&'*/=?\^_`{}|\~-]+(\.[+A-Za-z0-9!#$%&'*/=?\^_`{}|\~-]+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)|((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*)))?|(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)*(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(\(((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21-\x27\x2a-\x5b\x5d-\x7e]|((\\([\x01-\x09\x0b\x0c\x0e-\x7f]|\x0a*\x0d*([\x00-\x09\x0b\x0c\x0e-\x7f]\x0a*\x0d*)*))|\\(\x00|[\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x0a|\x0d))|))*)+((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?\))+)|((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*)))?\x22((((([\x20\x09]*\x0d\x0a)?[\x20\x09]+)|[\x20\x09]+(\x0d\x0a[\x20\x09]+)*))?(([\x21\x23-\

# This is a simple expression to check a US street address entered on either one or two lines.  Being short it does not check that the road qualifer is "valid" (eg. drive, avenue, etc), but it does allow for the extended zip code.  A word of warning, the multiline mode can be picky about ending the first line with extra space.
# ID: 988
^[ \w]{3,}([A-Za-z]\.)?([ \w]*\#\d+)?(\r\n| )[ \w]{3,},\x20[A-Za-z]{2}\x20\d{5}(-\d{4})?$

# simple test for C# inputs and CZ locale. No all accepted inputs are corect.
# ID: 2920
(^\d{1,2}\.\d{1,2}\.\d{4})|(^\d{1,2}\.\d{1,2})|(^\d{1,2})$

# Regular expression to validate mobile numbers in Jordan provided by Zain, Orange, and Umnia.
# ID: 3168
^07[789]-\d{7}$

# This expression will match all of the commands(escape codes) used in ANSI files.  These are what were used to create the colors/blocks on BBS's for those of us that once dialed into them.
# ID: 354
(?s)(?:\e\[(?:(\d+);?)*([A-Za-z])(.*?))(?=\e\[|\z)

# Erklärt Straße-Hausnummer-Kombinationen nach folgenden Regeln für gültig:
# ID: 3160
^(([a-zA-ZäöüÄÖÜ]\D*)\s+\d+?\s*.*)$

# Prüft auf einen Namen (evtl. zusammengesetzt mit Bindestrich "-"). Lässt auch Akzentzeichen zu.
# ID: 3161
^([^ \x21-\x26\x28-\x2C\x2E-\x40\x5B-\x60\x7B-\xAC\xAE-\xBF\xF7\xFE]+)$

# Erklärt deutsche Postleitzahlen für gültig, die zwischen dem aktuell kleinsten und größten Wert liegen: von '01001' bis '99998'.
# ID: 3284
^((0(1\d\d[1-9])|([2-9]\d\d\d))|(?(?=^(^9{5}))|[1-9]\d{4}))$

# 'Deutsche Telefonnummern'
# ID: 2952
^(((((((00|\+)49[ \-/]?)|0)[1-9][0-9]{1,4})[ \-/]?)|((((00|\+)49\()|\(0)[1-9][0-9]{1,4}\)[ \-/]?))[0-9]{1,7}([ \-/]?[0-9]{1,5})?)$

# Expresion Regular para Teléfonos con clave lada en México
# ID: 979
^\(\d{3}\) ?\d{3}( |-)?\d{4}|^\d{3}( |-)?\d{3}( |-)?\d{4}

# Matches and groups US Address Types.
# ID: 1564
(?<Address1>(?:[a-zA-Z0-9\x20\x2E\x2D])*(?:CIRCLE|CIR|MOUNTAIN|MTN|PARKWAY|PKWY|PKY|PLAZA|PLZA|PLZ|RIDGE|RDG|ROUTE|RTE|TURNPIKE|TURNPK|TPKE|TPK|WAY|WY|SOUTHEAST|SOUTHWEST|SOUTH|EAST|NORTHEAST|NORTHWEST|NORTH|WEST|ARCADE|ARC\x2E|ARC|AVENUE|AVE\x2E|AVE|BOULEVARD|BVD\x2E|BVD|BLVD\x2E|BLVD|CLOSE|CL\x2E|CL|CRESENT|CRES\x2E|CRES|DRIVE|DR\x2E|DR|ESPLANADE|ESP\x2E|ESP|GROVE|GR\x2E|GR|HIGHWAY|HWY\x2E|HWY|LANE|LN\x2E|LN|PARADE|PDE\x2E|PDE|PLACE\x2E|PLACE|PL\x2E|PL|ROAD|RD\x2E|RD|SQUARE|SQ\x2E|SQ|STREET|ST\x2E|ST|TERRACE|TCE\x2E|TCE|S\x2E|W\x2E|N\x2E|E\x2E|N|E|W|S))[,]*\t*\s(?<AptBldg>UNIT[a-zA-Z0-9\x20\x2D\x3A]*|BASEMENT[a-zA-Z0-9\x20\x2D\x3A]*|BSMT[a-zA-Z0-9\x20\x2D\x3A]*|BUILDING[a-zA-Z0-9\x20\x2D\x3A]*|DEPARTMENT[a-zA-Z0-9\x20\x2D\x3A]*|DEPT[a-zA-Z0-9\x20\x2D\x3A]*|FLOOR[a-zA-Z0-9\x20\x2D\x3A]*|FL[a-zA-Z0-9\x20\x2D\x3A]*|PENTHOUSE[a-zA-Z0-9\x20\x2D\x3A]*|PH[a-zA-Z0-9\x20\x2D\x3A]*|ROOM[a-zA-Z0-9\x20\x2D\x3A]*|RM[a-zA-Z0-9\x20\x2D\x3A]*|SLIP[a-zA-Z0-9\x20\x2D\x3A]*|SPACE[a-zA-Z0-9\x20\x2D\x3A]*|SPC[a-zA-Z0-9\x20\x2D\x3A]*|SUITE[a-zA-Z0-9\x20\x2D\x3A]*|\x23[a-zA-Z0-9\x20\x2D\x3A]*|APT[a-zA-Z0-9\x20\x2D\x3A]*|BLDG[a-zA-Z0-9\x20\x2D\x3A]*|PO\sBOX\x3A[a-zA-Z0-9\x20\x2D]*|P\x2EO\x2E\sBOX[a-zA-Z0-9\x20\x2D]*|PO\sBOX[a-zA-Z0-9\x20\x2D]*|BOX[a-zA-Z0-9\x20\x2D]*|\x20*)\x2C*\x2E*\t*(?<City>[a-zA-Z\x20]*)[,]*\t*\x20*(?<State>AL|ALABAMA|AK|ALASKA|AZ|ARIZONA|AR|ARKANSAS|CA|CALIFORNIA|CO|COLORADO|CT|CONNECTICUT|DE|DELAWARE|FL|FLORIDA|GA|GEORGIA|HI|HAWAII|ID|IDAHO|IL|ILLNOIS|IN|INDIANA|IA|IOWA|KS|KANSAS|KY|KENTUCKY|LA|LOUISIANA|ME|MAINE|MD|MARYLAND|MA|MASSACHUSETTS|MI|MICHIGAN|MN|MINNESOTA|MS|MISSISSIPPI|MO|MISSOURI|MT|MONTANA|NE|NEBRASKA|NV|NEVADA|NH|NEW HAMPSHIRE|NJ|NEW JERSEY|NM|NEW MEXICO|NY|NEW YORK|NC|NORTH CAROLINA|ND|NORTH DAKOTA|OH|OHIO|OK|OKLAHOMA|OR|OREGON|PA|PENNSYLVANIA|RI|RHODE ISLAND|SC|SOUTH CAROLINA|SD|SOUTH DAKOTA|TN|TENNESSEE|TX|TEXAS|UT|UTAH|VT|VERMONT|VA|VIRGINIA|WA|WASHINGTON|DC|DISTRICT OF COLUMBIA|WASHINGTON DC|[a-zA-Z]{2})\x2C*\t*\s*(?<ZipCode>[0-9\x2D\x20]{5,10}|\x20*)

# U.S. social security numbers (SSN), within the range of numbers that have been currently allocated. Matches the pattern AAA-GG-SSSS, AAA GG SSSS, AAA-GG SSSS, AAA GG-SSSS, AAAGGSSSS, AAA-GGSSSS, AAAGG-SSSS, AAAGG SSSS or AAA GGSSSS. All zero in any one field is not allowed.
# ID: 817
^(?!000)([0-6]\d{2}|7([0-6]\d|7[012])) ([ -])? (?!00)\d\d([ -|])? (?!0000)\d{4}$

# This works for all accept 01/01/0000 mainly 0000. can anybody suggest a solution.
# ID: 416
^(((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\d{4}))|((0[469]|11)([-./])([0][1-9]|[12][0-9]|30)([-./])(\d{4}))|((02)([-./])(0[1-9]|1[0-9]|2[0-8])([-./])(\d{4}))|((02)(\.|-|\/)(29)([-./])([02468][048]00))|((02)([-./])(29)([-./])([13579][26]00))|((02)([-./])(29)([-./])([0-9][0-9][0][48]))|((02)([-./])(29)([-./])([0-9][0-9][2468][048]))|((02)([-./])(29)([-./])([0-9][0-9][13579][26])))$

# From Author: DON'T USE THIS ONE. FIND MY OTHER ONE THAT BLOCKS LEADING ZEROS.  My site also couldn't swallow the \d, so I switched to numeric ranges and it worked fine.
# ID: 195
^\$?(\d{1,3}(\,\d{3})*|(\d+))(\.\d{0,2})?$

# Many currency expresssions allow leading zeros, thus $01.40 passes thru them.  This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and .0 Keywords: money dollar currency
# ID: 196
^\$?([1-9]{1}[0-9]{0,2}(\,[0-9]{3})*(\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\.[0-9]{0,2})?|0(\.[0-9]{0,2})?|(\.[0-9]{1,2})?)$

# Matches xml namespace (xmlns) attribtutes. Works with single and double quotes, could be extended to support unquoted attributes.
# ID: 900
( xmlns:.*=[",'].*[",'])|( xmlns=[",'].*[",'])

# This expression evaluates simple currency values...  alteast 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period
# ID: 802
(^\d{1,5}$|^\d{1,5}\.\d{1,2}$)

# Simple regular expression for creating an IRC client. This will parse the raw octet stream into message segments and groups that make it easy to build a client.
# ID: 1379
(?<raw_message>\:(?<source>((?<nick>[^!]+)![~]{0,1}(?<user>[^@]+)@)?(?<host>[^\s]+)) (?<command>[^\s]+)( )?(?<parameters>[^:]+){0,1}(:)?(?<text>[^\r^\n]+)?)

# Matches most common patterns for UK telephone numbers including +44 prefix , and with or without brackets. Covers 10 and 11 digit number ranges. Should be easy to modify for other number ranges.
# ID: 2428
(\(?\+44\)?\s?(1|2|3|7|8)\d{3}|\(?(01|02|03|07|08)\d{3}\)?)\s?\d{3}\s?\d{3}|(\(?\+44\)?\s?(1|2|3|5|7|8)\d{2}|\(?(01|02|03|05|07|08)\d{2}\)?)\s?\d{3}\s?\d{4}|(\(?\+44\)?\s?(5|9)\d{2}|\(?(05|09)\d{2}\)?)\s?\d{3}\s?\d{3}

# Detect windows share path (unc path)
# ID: 1100
\\\\\w+?(?:\\[\w\s$]+)+

# telphone number check.
# ID: 671
((\(\d{3,4}\)|\d{3,4}-)\d{4,9}(-\d{1,5}|\d{0}))|(\d{4,12})

# Decimal with comma or dot
# ID: 3489
^\d+((\.|\,)\d+)?$

# This expression will capture font tags(or any other HTML tag if you change the word font in the expression) with parameters and stop at the closing font tag bracket.  The only keyboard characters it will not find between the starting and ending bracket are additional brackets.  So for example if you are looking for image tags it will not find <img src="..." alt=">My Picture<"> due to the nested brackets.  When I allowed nested brackets like this the expression did not always return only the tag I was looking for.  Sometimes it returned additional tags at the end so I suggest staying away from brackets in alt text and anywhere else you may be allowed to do it.
# ID: 2087
<font[a-zA-Z0-9_\^\$\.\|\{\[\}\]\(\)\*\+\?\\~`!@#%&-=;:'",/\n\s]*>

# Time in 24 hours format with optional seconds
# ID: 981
^(([0-1]?[0-9])|([2][0-3])):([0-5]?[0-9])(:([0-5]?[0-9]))?$

# Checks if has the first and the last name, and check the capital letters.
# ID: 302
(^[A-ZÀ-Ü]{1}[a-zà-ü']+\s[a-zA-Zà-üÀ-Ü]+((([\s\.'])|([a-zà-ü']+))|[a-zà-ü']+[a-zA-Zà-üÀ-Ü']+))

# dd/mm/yy
# ID: 303
(^((((0[1-9])|([1-2][0-9])|(3[0-1]))|([1-9]))\x2F(((0[1-9])|(1[0-2]))|([1-9]))\x2F(([0-9]{2})|(((19)|([2]([0]{1})))([0-9]{2}))))$)

# Brazilian cpf
# ID: 304
(^\d{3}\x2E\d{3}\x2E\d{3}\x2D\d{2}$)

# Brazilian cep
# ID: 375
(^\d{5}\x2D\d{3}$)

# Brazilian CNPJ
# ID: 634
(^[0-9]{2,3}\.[0-9]{3}\.[0-9]{3}\/[0-9]{4}-[0-9]{2}$)

# Matches files extension
# ID: 635
(?!\.)[a-z]{1,4}$

# Matches the "Official" and several other popular expressions of the "Windows NT" line of operating systems. Used to discern one OS version from another. Must include at least one digit of the version number (1 to 4 or  1.0 to 4.9 will match).
# ID: 3422
((?:Microsoft)?.?(?:(?:Windows.NT.(?:[1-4].[0-9]))|(?:Win(?:dows)?.?NT).?[1-4](?:.?[0-9])?|NT[1-4]))

# Feet and Inches. Only allows 1 to 11". Feet can be 0 to higher. No fractions.
# ID: 3429
^[0-9,]+['][-](\d|1[01])"$

# 1 or 2 words with 1 or no space. Words are in all capital letters. Nothing in front or end of word(s).
# ID: 3430
^([A-Z]+\s*[A-Z]+)$

# Matches all Positive Numbers not including zero (0). Does not allow decimals.
# ID: 3490
^[1-9]+[0-9]*$

# Decimal values from 1 to .001 with precision of three, leading zero optional.  Can be 1 or 1.0 or 1.000
# ID: 1752
^0?.[0]{1,2}[1-9]{1}$|^0?.[1-9]{1}?\d{0,2}$|^(1|1.{1}[0]{1,3})$|^0?.[0]{1}[1-9]{1}\d{1}$

# Medicare number validation:XXXYYYYYYYYYZBBXXX- can be up to 3 letters. Not requiredYYY- 9 digits – requiredZ- must be letter. No number. Not requiredBB- can be letter or numbers. Not required. Can only exist if Z is exists.
# ID: 3674
^([A-Z]{0,3}?[0-9]{9}($[0-9]{0}|[A-Z]{1}))

# This regex avoids matching typical mistakes where a sentence ends but there is no space after the full stop (period). Other regexes will think any two words with a dot in between is a URL! My regex does not require http:// and if there isn't http:// it will need to find AT LEAST two dots to guarantee its likely to be a URL and not a sentence that's missing a space like this.It will match www.test.com, http://test.com, test.com/index.htm but it will NOT match test.com. It will not match a dot or a comma at the very end which some people may type when including a URL in a sentence like this www.test.com, or this www.test.com.
# ID: 1788
(http(s?)://|[a-zA-Z0-9\-]+\.)[a-zA-Z0-9/~\-]+\.[a-zA-Z0-9/~\-_,&\?\.;]+[^\.,\s<]

# If you are searching a text document for 'full' URLs and something happened during the printing process to break the URL into a space, then this will fix your problem, it will also not latch onto another URL, or a single word containing a period or comma after it.
# ID: 3295
https?://[^<>() ]+([ ](((?!https?://)[^<>() ])+)(?=[^<>() ]*[?!=%&-+/])[^<>() ]*)*

# It matches canada postal code
# ID: 2754
^[ABCEGHJKLMNPRSTVXY]{1}\d{1}[A-Z]{1} *\d{1}[A-Z]{1}\d{1}$

# Password validator that validates the password contains 1 letter (regardless of case) and 1 number
# ID: 1326
^(([a-zA-Z]+\d+)|(\d+[a-zA-Z]+))[a-zA-Z0-9]*$

# only accept chara, & ,\ , not allowed- @@ ## $$
# ID: 3581
^\s*[a-zA-Z0-9,&\s]+\s*$

# This expression matches all HREF relative paths, but not full URLs or dead # links.  It can be used for selecting paths that need to be updated in HTML that has replaced from its original page onto a new one.  It matches the entire containing tag with the following groups: 1 - the start of the containing tag through the space before the attribute, 2 - the delimiter between the attribute's equal sign and its value (e.g. a double quote), 3 - the attribute value, 4 - the remainder of the tag after the closing attribute value delimiter.
# ID: 1615
(<(?:.*?)\s)href\s*=([\s"'])*/?([^\2:#]+?)\2((?:.*?)>)

# Validates if the GMAT score is in the correct range and format
# ID: 2776
^([0-9]|[1-9]\d|[1-7]\d{2}|800)$

# Modified URL RegExp that requires (http, https, ftp,gopher,telnet,file|notes,ms-help)://, A nice domain, and a decent file/folder string.
# ID: 2414
((https?|ftp|gopher|telnet|file|notes|ms-help):((//)|(\\\\))+[\w\d:#@%/;$()~_\+-=\\\.&]*)

# uri
# ID: 1328
((((http[s]?|ftp)[:]//)([a-zA-Z0-9.-]+([:][a-zA-Z0-9.&%$-]+)*@)?[a-zA-Z][a-zA-Z0-9.-]+|[a-zA-Z][a-zA-Z0-9]+[.][a-zA-Z][a-zA-Z0-9.-]+)[.](com|edu|gov|mil|net|org|biz|pro|info|name|museum|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ax|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw)([:][0-9]+)*(/[a-zA-Z0-9.,;?'\\+&%$#=~_-]+)*)

# This will validate a rural route address against the United States Postal Service (USPS) rural route standard.
# ID: 1307
(\bR(\.|)R(\.|)|RURAL\s{0,}(ROUTE|RT(\.|)))\s{0,}\d{1,}(,|)\s{1,}\bBOX\s{0,}\d

# This is the USA Date Format. MM/DD/YYYY with checking leaf year
# ID: 2217
(((0[13578]|10|12)([/])(0[1-9]|[12][0-9]|3[01])([/])([1-2][0,9][0-9][0-9]))|((0[469]|11)([/])([0][1-9]|[12][0-9]|30)([/])([1-2][0,9][0-9][0-9]))|((02)([/])(0[1-9]|1[0-9]|2[0-8])([/])([1-2][0,9][0-9][0-9]))|((02)([/])(29)(\.|-|\/)([02468][048]00))|((02)([/])(29)([/])([13579][26]00))|((02)([/])(29)([/])([0-9][0-9][0][48]))|((02)([/])(29)([/])([0-9][0-9][2468][048]))|((02)([/])(29)([/])([0-9][0-9][13579][26])))

# Will match a date accepted by MySQL datetime type.
# ID: 2641
(\d{2}|\d{4})(?:\-)?([0]{1}\d{1}|[1]{1}[0-2]{1})(?:\-)?([0-2]{1}\d{1}|[3]{1}[0-1]{1})(?:\s)?([0-1]{1}\d{1}|[2]{1}[0-3]{1})(?::)?([0-5]{1}\d{1})(?::)?([0-5]{1}\d{1})

# Not just a number, a byte type. Will match any number from range -128 to 127.
# ID: 2642
^(0|[-]{1}([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-8]{1}))|(\+)?([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-7]{1})))$

# Will match an unsigned byte, from range 0 to 255
# ID: 2643
(0|(\+)?([1-9]{1}[0-9]{0,1}|[1]{1}[0-9]{0,2}|[2]{1}([0-4]{1}[0-9]{1}|[5]{1}[0-5]{1})))

# Short type, will match a short number from range -32768 to 32767.
# ID: 2644
^(0|[-]{1}([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-8]{1})))))|(\+)?([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-7]{1}))))))$

# Will match an unsigned short number from range 0 to 65535
# ID: 2645
^(0|(\+)?([1-9]{1}[0-9]{0,3})|([1-5]{1}[0-9]{1,4}|[6]{1}([0-4]{1}[0-9]{3}|[5]{1}([0-4]{1}[0-9]{2}|[5]{1}([0-2]{1}[0-9]{1}|[3]{1}[0-5]{1})))))$

# Will match any integer from range -2147483648 to 2147483647.
# ID: 2646
(0|[1-9]{1}[0-9]{0,8}|[1]{1}[0-9]{1,9}|[-]{1}[2]{1}([0]{1}[0-9]{8}|[1]{1}([0-3]{1}[0-9]{7}|[4]{1}([0-6]{1}[0-9]{6}|[7]{1}([0-3]{1}[0-9]{5}|[4]{1}([0-7]{1}[0-9]{4}|[8]{1}([0-2]{1}[0-9]{3}|[3]{1}([0-5]{1}[0-9]{2}|[6]{1}([0-3]{1}[0-9]{1}|[4]{1}[0-8]{1}))))))))|(\+)?[2]{1}([0]{1}[0-9]{8}|[1]{1}([0-3]{1}[0-9]{7}|[4]{1}([0-6]{1}[0-9]{6}|[7]{1}([0-3]{1}[0-9]{5}|[4]{1}([0-7]{1}[0-9]{4}|[8]{1}([0-2]{1}[0-9]{3}|[3]{1}([0-5]{1}[0-9]{2}|[6]{1}([0-3]{1}[0-9]{1}|[4]{1}[0-7]{1})))))))))

# Will match any unsigned integer from range 0 to 4294967295
# ID: 2647
^(0|(\+)?[1-9]{1}[0-9]{0,8}|(\+)?[1-3]{1}[0-9]{1,9}|(\+)?[4]{1}([0-1]{1}[0-9]{8}|[2]{1}([0-8]{1}[0-9]{7}|[9]{1}([0-3]{1}[0-9]{6}|[4]{1}([0-8]{1}[0-9]{5}|[9]{1}([0-5]{1}[0-9]{4}|[6]{1}([0-6]{1}[0-9]{3}|[7]{1}([0-1]{1}[0-9]{2}|[2]{1}([0-8]{1}[0-9]{1}|[9]{1}[0-5]{1})))))))))$

# Validation of a directory (not file) in UNC format
# ID: 1233
^\\\\[\w-]+\\(([\w()-][\w\s()-]*[\w()-]+)|([\w()-]+))\$?(\\(([\w()-][\w\s()-]*[\w()-]+)|([\w()-]+)))*\\?$

# Generic RFC3986 compliant hierarchical URI.  Does not support IPv6 literal strings as hosts.  Does not validate a host address against any registry types.  Does not validate a URI structure against scheme constraints.  Provides named groups for scheme(protocol), username, host, port, path, query, and fragment.
# ID: 1828
(?<scheme>[a-zA-Z][a-zA-Z0-9\+\-\.]*):(?://(?:(?<username>(?:[a-zA-Z0-9_~!&',;=\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))+):?(?:[a-zA-Z0-9_~!&',;=\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))*@)?(?<host>(?:[a-zA-Z0-9_~!&',;=\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))*)(?::(?<port>[0-9]*))?(?<path>(?:/(?:[a-zA-Z0-9_~!&',;=:@\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))*)*)|(?<path>/(?:(?:[a-zA-Z0-9_~!&',;=:@\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))+(?:/(?:[a-zA-Z0-9_~!&',;=:@\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))*)*)?)|(?<path>(?:[a-zA-Z0-9_~!&',;=:@\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))+(?:/(?:[a-zA-Z0-9_~!&',;=:@\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))*)*))?(?:\?(?<query>(?:[a-zA-Z0-9_~!&',;=:@/?\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))*))?(?:\#(?<fragment>(?:[a-zA-Z0-9_~!&',;=:@/?\.\-\$\(\)\*\+]|(?:%[0-9a-fA-F]{2}))*))?

# this pattern validates email address. it allows (1)numeric characters and underscore(_) in an address.(2)numeric characters in domain name. it doesn't match user names with a dot(.). doesn;t allow username starting or ending with @ underscore. they can be used in between
# ID: 1365
^[^_][a-zA-Z0-9_]+[^_]@{1}[a-z]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$

# Email-it is an extension to my previous expression for Validating email address.it has the following additional features: 1-username cant begin with a periods(.) and underscore(_) 2-maximum 2 periods(.) can be used in a username(previous xprsn didn't allowed any)(remember gmail which allows periods)
# ID: 1366
^[^_.]([a-zA-Z0-9_]*[.]?[a-zA-Z0-9_]+[^_]){2}@{1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$

# That is just an improved expression for handling capitalized names. Improvement #1 - Allowed using names consisting of 3 parts. Improvement #2 - Introduced restriction that the name must start from capital character.
# ID: 1956
^([A-Z]+[a-zA-Z]*)(\s|\-)?([A-Z]+[a-zA-Z]*)?(\s|\-)?([A-Z]+[a-zA-Z]*)?$

# Validates 1 or more email addresses.  Email addresses can be delimited with either comma or semicolon.  White space is allowed after delimiter, but not necessary.  I needed this to allow my users to specify multiple email addresses if they choose to do so.
# ID: 735
\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*([,;]\s*\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*)*

# Make sure string only contains characters that appear on keyboard.  Extended characters (such as those with ascii values above 127), will not pass the test.
# ID: 584
^[-\w`~!@#$%^&*\(\)+={}|\[\]\\:";'<>?,.\/ ]*$

# Test string to verify it begins with an upper-case letter.
# ID: 585
^[A-Z].*$

# Removes pesky comments and commented javascript from HTML
# ID: 210
<!--[\s\S]*?-->

# Finds any HTML tag and sub-matches properties weather it has an apposterphee, quote, or no quote/apposterphee
# ID: 211
</?(\w+)(\s+\w+=(\w+|"[^"]*"|'[^']*'))*>

# Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.
# ID: 212
^\{?[a-fA-F\d]{8}-([a-fA-F\d]{4}-){3}[a-fA-F\d]{12}\}?$

# Searches for tags and there atributes according to the HTML 2.0 specification to limit length of tags to 72 characters, and length of attribute values to 1024 characters.
# ID: 220
#&lt;/?([a-zA-Z][-A-Za-z\d\.]{0,71})(\s+(\S+)(\s*=\s*([-\w\.]{1,1024}|&quot;[^&quot;]{0,1024}&quot;|'[^']{0,1024}'))?)*\s*&gt;

# Find HTML tags that have javascript events attached to them.
# ID: 221
<[a-zA-Z][^>]*\son\w+=(\w+|'[^']*'|"[^"]*")[^>]*>

# domain as defined in RFC 2821
# ID: 2842
[a-z0-9][a-z0-9-]*[a-z0-9](?:\.[a-z0-9][a-z0-9-]*[a-z0-9])+

# A-d-l or at-domain-list as defined in RFC 2821
# ID: 2843
@[a-z0-9][a-z0-9-]*[a-z0-9](?:\.[a-z0-9][a-z0-9-]*[a-z0-9])+(?:,@[a-z0-9][a-z0-9-]*[a-z0-9](?:\.[a-z0-9][a-z0-9-]*[a-z0-9])+)*

# atext as defined in RFC 2822
# ID: 2844
[a-zA-Z0-9!#\$%&'\*\+\-\/=\?\^_`{\|}~]

# mailbox as defined in RFC 2821
# ID: 2845
[a-zA-Z0-9!#\$%&'\*\+\-\/=\?\^_`{\|}~]+(?:\.[a-zA-Z0-9!#\$%&'\*\+\-\/=\?\^_`{\|}~]+)*@[a-z0-9][a-z0-9-]*[a-z0-9](?:\.[a-z0-9][a-z0-9-]*[a-z0-9])+

# forward-path and reverse-path as defined in RFC 2821
# ID: 2846
^<(?:@[a-z0-9][a-z0-9-]*[a-z0-9](?:\.[a-z0-9][a-z0-9-]*[a-z0-9])+(?:,@[a-z0-9][a-z0-9-]*[a-z0-9](?:\.[a-z0-9][a-z0-9-]*[a-z0-9])+)*:)?([a-zA-Z0-9!#\$%&'\*\+\-\/=\?\^_`{\|}~]+(?:\.[a-zA-Z0-9!#\$%&'\*\+\-\/=\?\^_`{\|}~]+)*@[a-z0-9][a-z0-9-]*[a-z0-9](?:\.[a-z0-9][a-z0-9-]*[a-z0-9])+)>$

# This will test a last name field and allow hyphen is someone uses it.
# ID: 1962
[a-zA-Z]+\-?[a-zA-Z]+

# Searches for US SSNs that have either a white space, ".", ",", or "=" in front and either a white space, ".", or "," at the end. Ensures that sets are separated with the same format (either spaces, dashes, or nothing).
# ID: 2638
[/,,/.,/=,\s]([0-6]\d{2}|7[0-6]\d|77[0-2])(\s|\-)?(\d{2})\2(\d{4})[/,,/.,\s]

# Get the style attribute inner text contained inside " or ' caracters with the "style=" prefix.
# ID: 2170
style="[^"]*"|'[^']*'

# The Regular Expression to  validate time format in [24:00] hrs.
# ID: 2621
^(([01][0-9]|[012][0-3]):([0-5][0-9]))*$

# Regular Expression to validate date in MM/DD/YYYY format.
# ID: 2622
(([1-9]|[0][1-9])|1[012])[- /.](([1-9]|[0][1-9])|[12][0-9]|3[01])[- /.](19|20)\d\d

# This is permit all decimal number, exclude all alphanumeric caracter
# ID: 198
^\d*[0-9](|.\d*[0-9]|,\d*[0-9])?$

# Matches name/value pairs. In the example below, the 'name' of 'a' will have the 'value' of 'b'.  'c' will have the value 'd'.
# ID: 2277
\[(?<name>[^\]]*)\](?<value>[^\[]*)

# Regexp for czech cellphone numbers
# ID: 3468
^(\+?420)? ?[0-9]{3} ?[0-9]{3} ?[0-9]{3}$

# In java using this.getClass().getResource(""); will result in a jar:file:/ etc url ending with yourjarfile.jar!/internal/package/path/ this regular expression matches the directory before the internal jar path declaration returning the physical directory the file resides in. should work in both posix and windows machines (untested for posix*)
# ID: 1554
jar:file:/(([A-Z]:)?/([A-Z 0-9 * ( ) + \- & $ # @ _ . ! ~ /])+)(/[A-Z 0-9 _ ( ) \[ \] - = + _ ~]+\.jar!)

# More advanced regular expression to get the full path to the directory from which your program is running. You may use this to detect the program installation dir whether you are just debugging or having a deployed program. Using the second group combined with the 7th group you'll have a full path to your program. Very useful if you use resources outside of the java package.
# ID: 1555
(jar:)?file:/(([A-Z]:)?/([A-Z0-9\*\()\+\-\&$#@_.!~\[\]/])+)((/[A-Z0-9_()\[\]\-=\+_~]+\.jar!)|([^!])(/com/regexlib/example/))

# Validates all UK Postcodes based on format given at cabinetoffice.uk.gov. Must be in uppercase before validation.
# ID: 3356
^[A-PR-UWYZ]([0-9]([A-HJKSTUW]|[0-9])?|[A-HK-Y][0-9]([ABEHMNPRVWXY]|[0-9])) [0-9][ABD-HJLNP-UW-Z]{2}|GIR 0AA$

# Singapore phone number checks possible prefix +65
# ID: 3240
^(\+65)?\d{8}$

# This validator check for the Time from 00:00 to 23:59
# ID: 2082
^(([0]?[1-9]|[1-2][0-3])(:)([0-5][0-9]))$

# This format accepts only the values between 00:00 to 23:59
# ID: 2086
^(([0-1]?[1-9]|2[0-3])(:)([0-5][0-9]))$

# Accepts non-negative numbers with max two decimals. Commas can be added after every thousand.
# ID: 3103
^([1-9]+\d{0,2},(\d{3},)*\d{3}(\.\d{1,2})?|[1-9]+\d*(\.\d{1,2})?)$

# My meager attempt at a date validator with leap years using a strict mm/dd/yyyy format.
# ID: 114
(((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\d{4}))|((0[469]|11)([-./])([0][1-9]|[12][0-9]|30)([-./])(\d{4}))|((2)([-./])(0[1-9]|1[0-9]|2[0-8])([-./])(\d{4}))|((2)(\.|-|\/)(29)([-./])([02468][048]00))|((2)([-./])(29)([-./])([13579][26]00))|((2)([-./])(29)([-./])([0-9][0-9][0][48]))|((2)([-./])(29)([-./])([0-9][0-9][2468][048]))|((2)([-./])(29)([-./])([0-9][0-9][13579][26])))

# validates numbers, with or without decimal places, and comma 1000 separators.
# ID: 575
^(((\d{1,3})(,\d{3})*)|(\d+))(.\d+)?$

# Just a beginner....here's something I'm using to emulate the Microsoft "Print" functionality, where you can enter page numbers to print seperated by commas or specify a range using the "-" symbol. The expression checks across a whole string looking for anything that is NOT equal to a number, a minus symbol, a comma and a space character. You can use this expression to do a quick true-false check to see if the user has entered a valid string / page numbers. Later you could then write a routine to sort and / or process the input. Nothing fancy but might help someone. Comments welcome.
# ID: 1647
[^\d^\-^\,^\x20]+

# Its validates a time stamp
# ID: 2613
^[1-9]{1}[0-9]{3}-(0[1-9]{1}|1[0-2]{1})-([0-2]{1}[1-9]{1}|3[0-1]{1}) ([0-1]{1}[0-9]{1}|2[0-3]{1}):[0-5]{1}[0-9]{1}:[0-5]{1}[0-9]{1}$

# Matches a string if it is a valid time in the format of HH:MM
# ID: 59
^([0-1][0-9]|[2][0-3]):([0-5][0-9])$

# This is a simple post code regex for UK. It does a wonderfull job.
# ID: 2549
([a-zA-Z]{2}[0-9]{1,2}\s{0,1}[0-9]{1,2}[a-zA-Z]{2})

# Matches GUIDs defined in MSDN library (http://msdn2.microsoft.com/en-us/library/96ff78dc.aspx)
# ID: 1321
^[A-Fa-f0-9]{32}$|({|\()?[A-Fa-f0-9]{8}-([A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}(}|\))?$|^({)?[0xA-Fa-f0-9]{3,10}(, {0,1}[0xA-Fa-f0-9]{3,6}){2}, {0,1}({)([0xA-Fa-f0-9]{3,4}, {0,1}){7}[0xA-Fa-f0-9]{3,4}(}})$

# Matches any integer from 0 to 2147483647 (max Integer size for C#, Java, others)
# ID: 2413
^(\d|\d{1,9}|1\d{1,9}|20\d{8}|213\d{7}|2146\d{6}|21473\d{5}|214747\d{4}|2147482\d{3}|21474835\d{2}|214748364[0-7])$

# Filter basic emoticons
# ID: 3288
([oO0]*)([|:;=X^])([-']*)([)(oO0\]\[DPp*>X^@])

# Find any and all occurences of any of the three terms "Error" "Warning" "Exception" in a log or txt file.
# ID: 2834
(?:Error|Warning|Exception)

# Expression to check Dutch phone numbers. Number must start with zero and number of digits should be 10. Different area and country codes are allowed.
# ID: 1247
^(([+]31|0031)\s\(0\)([0-9]{9})|([+]31|0031)\s0([0-9]{9})|0([0-9]{9}))$

# Removes leading, trailing and extra spaces between words.
# ID: 1876
(^\x20*)|(\x20*$)|(\x20(?=\x20))

# This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY.
# ID: 1393
^(([1-4][0-9])|(0[1-9])|(5[0-2]))\/[1-2]\d{3}$

# this will accept multiple email ids separated only by semi-colons (anyway u can change it).
# ID: 1007
#^(([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5}){1,25})+([;.](([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5}){1,25})+)*$

# This expression will help match Quebec's postal codes.
# ID: 570
^[a-zA-Z]{1}[0-9]{1}[a-zA-Z]{1}(\-| |){1}[0-9]{1}[a-zA-Z]{1}[0-9]{1}$

# will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days.,It will only take years starting with 19 and 20
# ID: 3619
/^(?:(?:0?[13578]|1[02])|(?:0?[469]|11)(?!\/31)|(?:0?2)(?:(?!\/3[01]|\/29\/(?:(?:0[^48]|[13579][^26]|[2468][^048])00|(?:\d{2}(?:0[^48]|[13579][^26]|[2468][^048]))))))\/(?:0?[1-9]|[12][0-9]|3[01])\/(?:0?19|20)\d{2}$/

# I was inspired by this regexp - Matches a whole number between 1 and 20 inclusively - because it was doing something I could not find elsewhere so this is how I expanded it to validate lat values
# ID: 1535
^-?([1-8]?[1-9]|[1-9]0)\.{1}\d{1,6}

# Longitude validation (similiar to Latitude Validation) and inspired by the same code
# ID: 1536
^-?([1]?[1-7][1-9]|[1]?[1-8][0]|[1-9]?[0-9])\.{1}\d{1,6}

# Checks email format against RFC 3696 (http://tools.ietf.org/html/rfc3696). Allows all characters described in Sections 2 and 3 of the RFC EXCEPT those described in Section 4.3 as unsafe for mailto URLs without encoding. Allows any 2-letter TLD plus any of the current gTLDs as listed at http://www.icann.org/registries/top-level-domains.htm. Does not accept quoted strings in the local part or IP addresses in lieu of the domain name. Does not enforce length limits. Intended to be used as case-insensitive. Comments are appreciated!
# ID: 1512
^[a-z0-9!$'*+\-_]+(\.[a-z0-9!$'*+\-_]+)*@([a-z0-9]+(-+[a-z0-9]+)*\.)+([a-z]{2}|aero|arpa|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|travel)$

# I use this one to validate CURP structure. CURP is a mexican unique identifier for certain intitutions like INFONAVIT and it's very useful
# ID: 1868
^[a-zA-Z]{4}((\d{2}((0[13578]|1[02])(0[1-9]|[12]\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\d|30)|02(0[1-9]|1\d|2[0-8])))|([02468][048]|[13579][26])0229)(H|M)(AS|BC|BS|CC|CL|CM|CS|CH|DF|DG|GT|GR|HG|JC|MC|MN|MS|NT|NL|OC|PL|QT|QR|SP|SL|SR|TC|TS|TL|VZ|YN|ZS|SM|NE)([a-zA-Z]{3})([a-zA-Z0-9\s]{1})\d{1}$+

# Matches groups of single-line code comments.  Comment sections will be returned as a single match.
# ID: 2018
([\r\n ]*//[^\r\n]*)+

# Matches C# string literals; verbatin and or normal.
# ID: 2019
(@\s*".*?")|("([^"\\]|\\.)*?")

# matches a C# keyword.
# ID: 2020
\b(?<KEYWORD>abstract|event|new|struct|as|explicit|null|switch|base|extern|object|this|bool|false|operator|throw|break|finally|out|true|byte|fixed|override|try|case|float|params|typeof|catch|for|private|uint|char|foreach|protected|ulong|checked|goto|public|unchecked|class|if|readonly|unsafe|const|implicit|ref|ushort|continue|in|return|using|decimal|int|sbyte|virtual|default|interface|sealed|volatile|delegate|internal|short|void|do|is|sizeof|while|double|lock|stackalloc|else|long|static|enum|namespace|string)\b

# Small w is used in expression. if you'll use capital W then it is for "Not Alphanumeric"
# ID: 1831
\w*

# Maxlength test
# ID: 2486
(^\d{1,3}([,]\d{3})*$)|(^\d{1,16}$)

# Matches valid 3 or 6 character hex codes used for HTML or CSS.
# ID: 2429
^\#?[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$

# For the geeks out there, you can use this to break down die rolls of multisided dice for things like role playing games.  Includes support for a die multiplier and an end modifier value. Supports a multiplier up to 99, and sides and a modifier of up to 999.
# ID: 1754
([1-9]{1,2})?(d|D)([1-9]{1,3})((\+|-)([1-9]{1,3}))?

# The pattern matches what would at least appear to be a first and last name, with an optional hyphenated last name.  There is an obvious flaw that it can't distinguish between actual names and any two words that start with capital letters as noted in the matching text.  Also, two part first names like "Mary Jo" can cause problems.
# ID: 1740
^([A-Z][a-z]+)\s([A-Z][a-zA-Z-]+)$

# This type of filter can be used if you're trying to get rid of results from a report or something not originating from a given domain of the format domainname.tld.  Anything matching the pattern can then be excluded, deleted, etc. (Like with a Google Mini, GSA, or site auditing software)
# ID: 1709
https?://(?!\S*?domainname\.tld/)\S*?/

# Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979.
# ID: 1640
^(97(8|9))?\d{9}(\d|X)$

# This regex will validate the given string is numeric
# ID: 1371
^(?:(?:[+\-]?\$?)|(?:\$?[+\-]?))?(?:(?:\d{1,3}(?:(?:,\d{3})|(?:\d))*(?:\.(?:\d*|\d+[eE][+\-]\d+))?)|(?:\.\d+(?:[eE][+\-]\d+)?))$

# Will match a variety of different date formats; however, it is not a good example of "simple" regex and can really contribute to processing time.  This was made for a very specific purpose and should only be used when no other faster methods are available.
# ID: 2981
([A-Za-z]{0,}[\.\,\s]{0,}[A-Za-z]{1,}[\.\s]{1,}[0-9]{1,2}[\,\s]{0,}[0-9]{4})| ([0-9]{0,4}[-,\s]{0,}[A-Za-z]{3,9}[-,\s]{0,}[0-9]{1,2}[-,\s]{0,}[A-Za-z]{0,8})| ([0-9]{1,4}[\/\.\-][0-9]{1,4}[\/\.\-][0-9]{1,4})

# Made for a very specific purpose.  It's likely pretty slow.  Use at your own risk and don't complain.
# ID: 2982
([0-9]{1,2}[:][0-9]{1,2}[:]{0,2}[0-9]{0,2}[\s]{0,}[AMPamp]{0,2})

# This regular expression can be used to parse a comma delimited string. Leading whitespaces (at the beginning of the entire string) and ending commas are not acceptable. Any combination of letters and numbers with zero or one white space between them are acceptable. Note: To change the delimiter, simply replace the comma in the square brackets to the delimiter of choice.
# ID: 654
^([A-Za-z0-9]\s?)+([,]\s?([A-Za-z0-9]\s?)+)*$

# Matches parameters in an URL's query part. The parameters' name and value will be available as subsrting $1 and $2. $2 will be empty if the value is empty (e.g. "…&param=&…") or undefined if there's no equals to sign (e.g. "…&param&…").
# ID: 3603
[?&]([^&#=]+)(?:=([^&#]*))?

# I'am using it in PHP preg_match() to replace in string parts with non-entity ampersand. Made for my RSS.
# ID: 909
&(?!([a-zA-Z0-9#]{1,6};))

# Based on PJ Bijoy's regex for a US phone number, I've added validation that the area code is a valid US Area code (first digit is greater than 2) and that the area code is not a reserved Toll Free Code (800, 822, 833, 844, 855, 866, 877, 888) and not a premium number (900).  It will accept phone patterns of ###-###-#### (3 digits dash 3 digits dash 4 digits), ########## (10 digits), (###)###-#### (3 digits in parens 3 digits dash 4 digits), (###)### #### (3 digits in parens 3 digits space 4 digits), (###) ###-#### (3 digits in parens space 3 digits dash 4 digits), (###) ### #### (3 digits in parens space 3 digits space 4 digits)
# ID: 1872
^\((([2-7][0-9]{2})|(8(0[^0]|[^0]0|1\d|2[^2]|[^2]2|3[^3]|[^3]3|4[^4]|[^4]4|5[^5]|[^5]5|6[^6]|[^6]6|7[^7]|[^7]7|8[^8]|[^8]8|9\d){1})|(9(0[^0]|[^0]0|[1-9][1-9])))\)\s?[0-9]{3}(-|\s)?[0-9]{4}$|^(([2-7][0-9]{2})|(8(0[^0]|[^0]0|1\d|2[^2]|[^2]2|3[^3]|[^3]3|4[^4]|[^4]4|5[^5]|[^5]5|6[^6]|[^6]6|7[^7]|[^7]7|8[^8]|[^8]8|9\d){1})|(9(0[^0]|[^0]0|[1-9][1-9])))-?[0-9]{3}-?[0-9]{4}$

# Enter the date in MM/DD/YYYY format. This regular expression validates the day, month and year including the leap year validations.
# ID: 1915
/^(?=\d)(?:(?:(?:(?:(?:0?[13578]|1[02])(\/)31)\1|(?:(?:0?[1,3-9]|1[0-2])(\/)(?:29|30)\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})|(?:0?2(\/)29\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))|(?:(?:0?[1-9])|(?:1[0-2]))(\/)(?:0?[1-9]|1\d|2[0-8])\4(?:(?:1[6-9]|[2-9]\d)?\d{2}))($|\ (?=\d)))?(((0?[1-9]|1[012])(:[0-5]\d){0,2}(\ [AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$/

# Verify "well formed-ness" of DOS or UNC paths.
# ID: 1082
^((?<DRIVE>[a-z]:)|(\\\\(?<SERVER>[0-9]*[a-z\-][a-z0-9\-]*)\\(?<VOLUME>[^\.\x01-\x1F\\""\*\?<>:|\\/][^\x01-\x1F\\""\*\?|><:\\/]*)))?(?<FOLDERS>(?<FOLDER1>(\.|(\.\.)|([^\.\x01-\x1F\\""\*\?|><:\\/][^\x01-\x1F\\""\*\?<>:|\\/]*)))?(?<FOLDERm>[\\/](\.|(\.\.)|([^\.\x01-\x1F\\""\*\?|><:\\/][^\x01-\x1F\\""\*\?<>:|\\/]*)))*)?[\\/]?$

# This expression matches all following Telephone number patterns [US Telephone, Indian Telephone, Canadian Telephone & Fax Numbers]. I tested it and its working fine. and hope this will be helpful to u people. suggestion are welcome ! +91-80-1234567 | +91 80 1234567 | +91 80-1234567 | +91-80 1234567 | +91.80.1234567 | +91.80-1234567 | +91-80.1234567 | (91)80-1234567 | (91)80 1234567 | (91)80.1234567 | +91-80-12345678 | +91 80 12345678 | +91 80-12345678 | +91-80 12345678 | +91.80.12345678 | +91.80-12345678 | +91-80.12345678 | (91)80-12345678 | (91)80 12345678 | (91)80.12345678 | +91-484-1234567 | +91 484 1234567 |  +91 484-1234567 | +91-484 1234567 | +91.484.1234567 | +91.484-1234567 |  +91-484.1234567 | (91)484-1234567 | (91)484 1234567 | (91)484.1234567 | +91-484-12345678 | +91 484 12345678 | +91 484-12345678 | +91-484 12345678 | +91.484.12345678 | +91.484-12345678 | +91-484.12345678 | (91)484-12345678 | (91)484 12345678 | (91)484.12345678 | +123-123-1234 | +123 123 1234 | +123 123-1234 | +123-123 1234 | +123.123.1234 | +123.123-1234 | +123-123.1234 | (123)123-1234 | (123)123 1234 | (123)123.1234 | +123-123-1234 | +123 123 1234 | +123 123-1234 | +123-123 1234 | +123.123.1234 | +123.123-1234 | +123-123.1234 | (123)123-1234 | (123)123 1234 | (123)123.1234 | 123-123-1234 | 123 123 1234 | 123 123-1234 | 123-123 1234 | 123.123.1234 | 123.123-1234 | 123-123.1234 | 123-123-1234 | (001)456-789-1234 | 001-456-789-1234 | 4841801234 | +91.1234567890 | +91-1234567890 | +91 1234567890 | 1-561-555-1212 | 1234567890 | 1234-1234567 | 123-12345678 (05)12341234 | 09886657989  - Phone , Telephone
# ID: 1608
preg_match_all("/([\(\+])?([0-9]{1,3}([\s])?)?([\+|\(|\-|\)|\s])?([0-9]{2,4})([\-|\)|\.|\s]([\s])?)?([0-9]{2,4})?([\.|\-|\s])?([0-9]{4,8})/",$string, $phones);

# Regular Expression matches any internet URLs. Used with the replace method it comes in very handy.
# ID: 3001
(https:[/][/]|http:[/][/]|www.)[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\-\._\?\,\'/\\\+&%\$#\=~])*$

# Matches decimal numbers (english or german writing) followed by metric or time units (mm, cm, dm, m, km, s, min and h) in labels surrounded by any digit.
# ID: 2053
(?<Nbr>[\+-]?((\d*\,\d+)|(\d*\.\d+)|\d+))\s*(?<Unit>mm|cm|dm|min|km|s|m|h)

# Basic US phone number matching pattern.  I found this place and used a regex, so figured I'd share.
# ID: 478
^(\(?\d\d\d\)?)?( |-|\.)?\d\d\d( |-|\.)?\d{4,4}(( |-|\.)?[ext\.]+ ?\d+)?$

# Match a path location. This regular expression check the file location and validate a file from one to three character extension description.
# ID: 2220
/^([0-9a-zA-Z]+|[a-zA-Z]:(\\(\w[\w ]*.*))+|\\(\\(\w[\w ]*.*))+)\.[0-9a-zA-Z]{1,3}$/

# Matches a range "X-X" or "XXX-XXX" or a single number "X" but does not match X- or XXX-
# ID: 1382
(^\b\d+-\d+$\b)|(^\b\d+$\b)

# Allows you to check the length of a number (in this case either 3 or 4 digits).
# ID: 908
^([0-9]{3,4})$

# Capture the attributes "content", "name" and "scheme" used to parse META tags from any XHTML or HTML input. Useful for developers looking for expresions to parse & get Dublin Core single elements from HTML pages.
# ID: 611
(<meta\s+)*((name\s*=\s*("|')(?<name>[^'("|')]*)("|')){1}|content\s*=\s*("|')(?<content>[^'("|')]*)("|')|scheme\s*=\s*("|')(?<scheme>[^'("|')]*)("|'))

# validates an ICD9 medical code which MAY start with an E or V, 3 digits, and MAY be followed by a period and a 1-2 digit sub-code
# ID: 3082
^([EV])?\d{3,3}(\.\d{1,2})?$

# See my sigle ICD9 validator for ICD9 rules.  This does the same, and validates for comma delitter (with optiona space after comma)
# ID: 3083
^([EV])?\d{3,3}(\.\d{1,2})?(, *([EV])?\d{3,3}(\.\d{1,2})?)*$

# a CPT code is a 4 digits + a captial letter or number (forming 5 character code).  The CPT code describes a medical procedure
# ID: 3084
^\d{4,4}[A-Z0-9]$

# see my regex for explaining basic CPT.  This validates a comma delimited (with possible spaces after comma) string of CPT codes
# ID: 3085
^\d{4,4}[A-Z0-9](, *\d{4,4})[A-Z0-9]*$

# use this to see if your VALUE is in a given string that is comma delimited.  Replace VALUE with your own
# ID: 3314
(\A|(.*,))VALUE(\z|([,]?.))

# Allows "words" with alphanumeric characters, including the underscore _ character.  Disallows leading or trailing spaces, also doubled-up spaces within the text.  If you want to disallow the underscore character, you can replace the two occurrences of \w with a-zA-Z
# ID: 1971
^[\w0-9]+( [\w0-9]+)*$

# Usesful for importing vcards. Matches vcard elements and values.
# ID: 231
((?<strElement>(^[A-Z0-9-;=]*:))(?<strValue>(.*)))

# Simple expresion to accept names for people with accent
# ID: 3402
/^[a-zA-Záéíóú]+$/

# accept pages that start with www, http or https and ends with a word between 2 and 4 letters
# ID: 3404
/^(www\.|http:\/\/|https:\/\/|http:\/\/www\.|https:\/\/www\.)[a-z0-9]+\.[a-z]{2,4}$/

# A general string validation to insure no malicious code is being passed through user input.  General enough too allow email address, names, address, passwords, so on.  Disallows ‘,\*&$<> or other characters that could cause issues.
# ID: 186
^([1-zA-Z0-1@.\s]{1,255})$

# Very basic, but couldn't find it, so from one Regex noob to another...
# ID: 2302
(\(")([0-9]*)(\")

# This was made to change non-decimal prices at the end of a huge SQL Insert... To use to replace in DW (without quotes) use sub expression like: $2,$4)
# ID: 2303
(")([0-9]*)(",")([0-9]*)("\))

# Matches comma-separated list of IP address and IP ranges. E.g. 192.168.101.1-192.168.101.255,192.168.102.12
# ID: 267
^(((((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])-(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9]))|((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9]))),)*)(((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-

# Accepts 1-2 digits followed by a slash followed by 2-4 digits.  Useful for numeric month/year entry.
# ID: 104
^\d{1,2}\/\d{2,4}$

# This expression will match all positive numbers that contain decimals and commas.
# ID: 3008
(^(\d|,)*\.?\d*[1-9]+\d*$)|(^[1-9]+(\d|,)*\.\d*$)|(^[1-9]+(\d|,)*\d*$)

# For matching passwords (or any words) with the following requirements... 15 - 30 Characters; At least 2 Numeric 0-9, 2 Special !,^,&... & 2 Uppercase A-Z
# ID: 2747
^(?=.*\d{2})(?=.*[A-Z]{2})(?=.*[\D,\W,\S]{2})(?=.*[a-z]).{15,30}$

# Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)
# ID: 340
^((4\d{3})|(5[1-5]\d{2}))(-?|\040?)(\d{4}(-?|\040?)){3}|^(3[4,7]\d{2})(-?|\040?)\d{6}(-?|\040?)\d{5}

# this pattern can find all lines of script in HTML code from open to close tag range
# ID: 265
<script[^>]*>[\w|\t|\r|\W]*</script>

# Finds all <input attrib1="value1" attrib2="value2" ... > tags. You can make it end with "/>" for xhtml compatibility replacing with the expression "<input $2 />". You can repeat it with other tags like <img /> or <br / >
# ID: 1413
(<input )(.*?)(>)

# VAT Number BE. Assumes BE followed by 0 or 1 or ' ' the digits will grouped by xxxxxxxxxx or xxxx.xxx.xxx. If you only want VAT numbers starting with 0 then replace [0-1]{1} with [0]
# ID: 2806
^(BE)[0-1]{1}[0-9]{9}$|^((BE)|(BE ))[0-1]{1}(\d{3})([.]{1})(\d{3})([.]{1})(\d{3})

# Created by me.It works in almost all the normal cases.
# ID: 3033
^\s*(([\w-]+\.)+[\w-]+|([a-zA-Z]{1}|[\w-]{2,}))@(\w+\.)+[A-Za-z]{2,5}$

# Created by me.Allows for checking 1 mail id or more.If more than 1 it should be separated by a , or ; and or space.
# ID: 3034
^\s*((([\w-]+\.)+[\w-]+|([a-zA-Z]{1}|[\w-]{2,}))@(\w+\.)+[A-Za-z]{2,5}[?= ]?[?=,;]?[?= ]?)+?$

# Focused on the website url validation
# ID: 3088
^((http:\/\/www\.)|(www\.)|(http:\/\/))[a-zA-Z0-9._-]+\.[a-zA-Z.]{2,5}$

# Matches currency input with or without commas.
# ID: 70
^\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(.[0-9][0-9])?$

# Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid: !#$%^&amp;amp;amp;*-+~/'`|{}@xyz.com
# ID: 328
^((\"[^\"\f\n\r\t\v\b]+\")|([\w\!\#\$\%\&\'\*\+\-\~\/\^\`\|\{\}]+(\.[\w\!\#\$\%\&\'\*\+\-\~\/\^\`\|\{\}]+)*))@((\[(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))\])|(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))|((([A-Za-z0-9\-])+\.)+[A-Za-z\-]+))$

# Based of from Steward Haddock's domain nam
# ID: 381
^[a-zA-Z0-9]+([a-zA-Z0-9\-\.]+)?\.(aero|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly| ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk| pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr| st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw|AERO|BIZ|COM|COOP|EDU|GOV|INFO|INT|MIL|MUSEUM|NAME|NET|ORG|AC|

# Validates up to two names. Names must start with uppercase followed by letters (including accented and egne). Separator is assumed to be one hyphen or one space.
# ID: 3178
(^[ÑA-Z][a-záéíóúñ'ÑA-Z]*$)|(^[ÑA-Z][a-záéíóúñ'ÑA-Z]*[- ]^[ÑA-Z][a-záéíóúñ'ÑA-Z]*$)

# This expression can validate dates in the range of years 2010-2099 with accounting for leap year. Format of date dd-mmm-yyyy.
# ID: 3637
^((((((0?[1-9])|([1-2][0-9])|(3[0-1]))-(([jJ][aA][nN])|([mM][aA][rR])|([mM][aA][yY])|([jJ][uU][lL])|([aA][uU][gG])|([oO][cC][tT])|([dD][eE][cC])))|(((0?[1-9])|([1-2][0-9])|(30))-(([aA][pP][rR])|([jJ][uU][nN])|([sS][eE][pP])|([nN][oO][vV])))|(((0?[1-9])|(1[0-9])|(2[0-8]))-([fF][eE][bB])))-(20(([13579][01345789])|([2468][1235679]))))|(((((0?[1-9])|([1-2][0-9])|(3[0-1]))-(([jJ][aA][nN])|([mM][aA][rR])|([mM][aA][yY])|([jJ][uU][lL])|([aA][uU][gG])|([oO][cC][tT])|([dD][eE][cC])))|(((0?[1-9])|([1-2][0-9])|(30))-(([aA][pP][rR])|([jJ][uU][nN])|([sS][eE][pP])|([nN][oO][vV])))|(((0?[1-9])|(1[0-9])|(2[0-9]))-([fF][eE][bB])))-(20(([13579][26])|([2468][048])))))$

# This expression will allow whole dollar amounts (along with $ and ,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.
# ID: 2664
^(\$?)((\d{1,20})|(\d{1,2}((,?\d{3}){0,6}))|(\d{3}((,?\d{3}){0,5})))$

# This expression matches the integer or double. A double is separated by the dot.
# ID: 3049
^\d+?(\.\d+)?$

# Parses chess games in PGN notation. It supports variation and curly brace commentaries (just make sure you have commentaries after variations if there are both). It does not support semicolon commentaries, NAGs, % comments or international notation of board pieces. As Regex is not recursive,  parsing must be done on found variations, until there are none left.
# ID: 3355
(?<pgnGame>\s*(?:\[\s*(?<tagName>\w+)\s*"(?<tagValue>[^"]*)"\s*\]\s*)+(?:(?<moveNumber>\d+)(?<moveMarker>\.|\.{3})\s*(?<moveValue>(?:[PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:\=[PNBRQK])?|O(-?O){1,2})[\+#]?(\s*[\!\?]+)?)(?:\s*(?<moveValue2>(?:[PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:\=[PNBRQK])?|O(-?O){1,2})[\+#]?(\s*[\!\?]+)?))?\s*(?:\(\s*(?<variation>(?:(?<varMoveNumber>\d+)(?<varMoveMarker>\.|\.{3})\s*(?<varMoveValue>(?:[PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:\=[PNBRQK])?|O(-?O){1,2})[\+#]?(\s*[\!\?]+)?)(?:\s*(?<varMoveValue2>(?:[PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:\=[PNBRQK])?|O(-?O){1,2})[\+#]?(\s*[\!\?]+)?))?\s*(?:\((?<varVariation>.*)\)\s*)?(?:\{(?<varComment>[^\}]*?)\}\s*)?)*)\s*\)\s*)*(?:\{(?<comment>[^\}]*?)\}\s*)?)*(?<endMarker>1\-?0|0\-?1|1/2\-?1/2|\*)?\s*)

# Regular Expression that validate phone in France.
# ID: 227
^0[1-6]{1}(([0-9]{2}){4})|((\s[0-9]{2}){4})|((-[0-9]{2}){4})$

# Validates Numeric values with commas and limited decimal places. Can change the value d{1,2} to limit decimal places from 1 to n
# ID: 2548
^(\d)?(\d|,)*\.?\d{1,2}$

# This comes from our requirement to have tight clean telephone database column. This expression supports only strict format and none others.It accepts any international country code with optional extension number.
# ID: 2561
^(\+[0-9]{2,}[0-9]{4,}[0-9]*)(x?[0-9]{1,})?$

# Codigos Postales Argentinos (CPA)
# ID: 147
^([A-HJ-TP-Z]{1}\d{4}[A-Z]{3}|[a-z]{1}\d{4}[a-hj-tp-z]{3})$

# All combinations of Roman numeral characters that are needed to invalidate a Roman numeral (to see if the combination isn't a valid Roman numeral).
# ID: 1863
(([IXCM])\2{3,})|[^IVXLCDM]|([IL][LCDM])|([XD][DM])|(V[VXLCDM])|(IX[VXLC])|(VI[VX])|(XC[LCDM])|(LX[LC])|((CM|DC)[DM])|(I[VX]I)|(X[CL]X)|(C[DM]C)|(I{2,}[VX])|(X{2,}[CL])|(C{2,}[DM])

# Validates the format of a Windows folder path ending with a backslash using the Universal Naming Convention (UNC)--without using lookaround.<br><br>Windows UNC folder components: <br>(I) The server name can only contain letters, numbers, and hyphens. However, Windows does allow underscores--which aren’t standard characters in the Request for Comments (RFC) 1035 standard--for networks using the Microsoft DNS Server. (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;222823) <br>(II) The share name (also called the service name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: " * / : ? | < > \ , ; [ ] + = (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;236388) (2) Can begin or end with a period, but cannot contain all periods (3) Cannot begin or end with a space (4) There must be at least one character that is not a space or period if the rest of the share name contains periods and spaces or just periods. <br>(III) The folder and subfolder names (without the share and server names) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: " * / : ? | < > \ (Reference: http://msdn2.microsoft.com/en-us/library/aa365247.aspx) (2) Cannot begin or end with a space or period.
# ID: 1807
^\\{2}[-\w]+\\(([^"*/:?|<>\\,;[\]+=.\x00-\x20]|\.[.\x20]*[^"*/:?|<>\\,;[\]+=.\x00-\x20])([^"*/:?|<>\\,;[\]+=\x00-\x1F]*[^"*/:?|<>\\,;[\]+=\x00-\x20])?)\\([^"*/:?|<>\\.\x00-\x20]([^"*/:?|<>\\\x00-\x1F]*[^"*/:?|<>\\.\x00-\x20])?\\)*$

# Validates the format of a Windows folder path ending with a backslash using the drive path--without using lookaround.<br><br>Windows folder drive path components: <br>(I) The drive can only be one letter. <br>(II) The folder and subfolder names (without the drive) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: " * / : ? | < > \ (Reference: http://msdn2.microsoft.com/en-us/library/aa365247.aspx) (2) Cannot begin or end with a space or period.
# ID: 1808
^[A-Za-z]:\\([^"*/:?|<>\\.\x00-\x20]([^"*/:?|<>\\\x00-\x1F]*[^"*/:?|<>\\.\x00-\x20])?\\)*$

# Validates the format of a Windows folder path ending with a backslash using the drive path or Universal Naming Convention (UNC)--without using lookaround.<br><br>Windows folder components: <br>(I) The drive can only be one letter. <br>(II) The server name (1) can only contain letters, numbers, and hyphens. However, Windows does allow underscores--which aren’t standard characters in the Request for Comments (RFC) 1035 standard--for networks using the Microsoft DNS Server. (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;222823) or (2) can be an IP address <br>(III) The share name (also called the service name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: " * / : ? | < > \ , ; [ ] + = (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;236388) (2) Can begin or end with a period, but cannot contain all periods (3) Cannot begin or end with a space (4) There must be at least one character that is not a space or period if the rest of the share name contains periods and spaces or just periods. <br>(IV) The folder and subfolder names (without the drive, share, or server name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: " * / : ? | < > \ (Reference: http://msdn2.microsoft.com/en-us/library/aa365247.aspx) (2) Cannot begin or end with a space or period.
# ID: 1785
^([A-Za-z]:|\\{2}([-\w]+|((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\\(([^"*/:?|<>\\,;[\]+=.\x00-\x20]|\.[.\x20]*[^"*/:?|<>\\,;[\]+=.\x00-\x20])([^"*/:?|<>\\,;[\]+=\x00-\x1F]*[^"*/:?|<>\\,;[\]+=\x00-\x20])?))\\([^"*/:?|<>\\.\x00-\x20]([^"*/:?|<>\\\x00-\x1F]*[^"*/:?|<>\\.\x00-\x20])?\\)*$

# My first REGEX pattern. Matches all alphanumerics + underscore (_) + dot (.)
# ID: 2362
(^([\w]+[^\W])([^\W]\.?)([\w]+[^\W]$))

# a simplistic path/filename for windows (more restrictive than for Mac OS or *nix). Updated escaping, end of string.
# ID: 1809
^[/]*([^/\\ \:\*\?"\<\>\|\.][^/\\\:\*\?\"\<\>\|]{0,63}/)*[^/\\ \:\*\?"\<\>\|\.][^/\\\:\*\?\"\<\>\|]{0,63}$

# Matches a string used to rewrite urls under the WSRP specification.  It captures the URL-Encoded string that represents a url.  Url validation is not provided.
# ID: 497
wsrp_rewrite\?(?<wsrp_uri>[\w%:&\\/;.]*)/wsrp_rewrite

# Percentage (From 0 to 100)
# ID: 498
^(0*100{1,1}\.?((?<=\.)0*)?%?$)|(^0*\d{0,2}\.?((?<=\.)\d*)?%?)$

# Email validator that adheres directly to the specification for email address naming. It allows for everything from ipaddress and country-code domains, to very rare characters in the username.
# ID: 26
^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$

# Removes "stop" or "delete" words that google removes from search strings.  Ordinarily have no search significance. I used this to remove the words in my own web search application.  Take out the ?: for grouping.
# ID: 974
\b(?:a(?:[nst]|re|nd)?|b[ey]|f(?:or|rom)|i[nst]?|o[fnr]|t(?:o|hat|he|his)|w(?:as|h(?:at|en|ere|ich|o)|i(?:th|ll)))\b

# Using this validate srilankan identity card number
# ID: 3223
(^\d{9}[V|v|x|X]$)

# Matches any alphanumeric string (with spaces in between, not in first and last place)
# ID: 3297
([0-9a-zA-Z]+)|([0-9a-zA-Z][0-9a-zA-Z\\s]+[0-9a-zA-Z]+)

# This expression will match comment blocks in javascript, c, c++, etc
# ID: 779
(?<commentblock>((?m:^[\t ]*\/{2}[^\n\r\v\f]+[\n\r\v\f]*){2,})|(\/\*[\w\W]*?\*\/))

# An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string.
# ID: 2482
^[^\*]{0,}[\*]{0,1}[^\*]{0,}$

# This regular expression finds all opening tags that have the runat='server' attribute specified. It groups the type of the control (eg. asp:Label) in to a group named TYPE and the id of the control into a group named NAME.
# ID: 878
<(?i)(?=.[^>]*runat=["]?server)(?<TYPE>\S[^>\s]+).[^>]*id=["]?(?<NAME>\w+).[^>]*>

# Validates MS FQDNs.  1) Entire fqdn less than 255 chars. 2) Host and domain names may contain an underscore.  3) 1st char can be a number.  4) No part can be all numbers. 5) Allows any TLD
# ID: 1319
(?=^.{1,254}$)(^(?:(?!\d+\.)[a-zA-Z0-9_\-]{1,63}\.?)+(?:[a-zA-Z]{2,})$)

# Based on Remi Sabourin pattern.  Adds total length validation.  Like Remi's this allows a part to be all numbers.  To prevent all numbers just add (?!\d+\.) between (^(?: and ([a-z-A-Z0-9]
# ID: 1320
(?=^.{1,254}$)(^(?:[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]\.?)+(?:[a-zA-Z]{2,})$)

# reg. expr. 4 checking 24 time
# ID: 332
^(([0-9])|([0-1][0-9])|([2][0-3])):(([0-9])|([0-5][0-9]))$

# Modified Joe Lynwood's to allow zero amounts.  Handles US Dollars including zero dollars.
# ID: 1050
^(\$)?(([1-9]\d{0,2}(\,\d{3})*)|([1-9]\d*)|(0))(\.\d{2})?$

# Strip (X)HTML comments
# ID: 851
<!--((?!-->).)*-->

# Strip C style block comments
# ID: 852
\/\*((?!\*\/).)*\*\/

# This pattern matches danish zip codes with optional country identification
# ID: 901
^(?<CountryPrefix>DK-)?(?<ZipCode>[0-9]{4})$

# Expression validating a series of hex codes (byte values) separated by spaces.
# ID: 744
^([0-9a-fA-F]{1,2})(\s[0-9a-fA-F]{1,2})*$

# divides an url into the different parts: protocol, subdomain, tld, port, folder, file, anchor, parameter
# ID: 3115
(http|ftp|https):\/\/(\w[\w\-_\.]*\.)?([_\-\w]+)(:[0-9]+)?([\/[\w_\.-]+]*)\/(\.?\w[\w._-]*[\w_-])?(#\w+)?([\w\-\.,@?^=%&:\~\+#]*[\w\-\@?^=%&\/\~\+#])?

# This is the best RFC 2822 ( http://www.faqs.org/rfcs/rfc2822 ) date format regular expression I could come up with. I've tested it, not very extensively though. This regex also validates obsolete standard, excluding comments anywhere.
# ID: 969
^(?:\s*(Sun|Mon|Tue|Wed|Thu|Fri|Sat),\s*)?(0?[1-9]|[1-2][0-9]|3[01])\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2})\s+(2[0-3]|[0-1][0-9]):([0-5][0-9])(?::(60|[0-5][0-9]))?\s+([-\+][0-9]{2}[0-5][0-9]|(?:UT|GMT|(?:E|C|M|P)(?:ST|DT)|[A-IK-Z]))(\s*\((\\\(|\\\)|(?<=[^\\])\((?<C>)|(?<=[^\\])\)(?<-C>)|[^\(\)]*)*(?(C)(?!))\))*\s*$

# I needed a regex to parse PHP functions, so I made it and here it is. It will not validate with array variables as the function arguments.
# ID: 1370
^\s*\w+\s*\((\s*(("|')([^\3]+|\\\3)\3|\$?[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]|[0-9]*)\s*,?)*\s*\)

# Allows extraction of values vio name. tested with dotnet 2003.
# ID: 2554
^(?<lat>(-?(90|(\d|[1-8]\d)(\.\d{1,6}){0,1})))\,{1}(?<long>(-?(180|(\d|\d\d|1[0-7]\d)(\.\d{1,6}){0,1})))$

# Checks domain names.  This is an attempt to deal with some of the issues of the other reg ex in not handling leading periods(.) and hypens(-).
# ID: 138
^[a-zA-Z0-9]+([a-zA-Z0-9\-\.]+)?\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$

# matches non-negative decimal floating points numbers less than 10
# ID: 162
^[0-9](\.[0-9]+)?$

# Dollar Amount
# ID: 163
(\d{1,3},(\d{3},)*\d{3}(\.\d{1,3})?|\d{1,3}(\.\d{3})?)$

# [Default]
# ID: 164
\$[0-9]?[0-9]?[0-9]?((\,[0-9][0-9][0-9])*)?(\.[0-9][0-9]?)?$

# Yes, bra sizes can also be tested by regular expressions. The numeric digits represent the rib cage circumference, measured under the breast excluding the breast. It MUST be an even number. The letters determine the cup size - AA is the smallest, H (and beyond, which this regular expression does not represent) is the largest. In summary, the cup sizes are determined by the "full chest circumference" (which includes the breast) MINUS the rib cage circumference. Smaller differences are closer to A and larger differences are closest to DDD or F
# ID: 1975
^[2-5](2|4|6|8|0)(A(A)?|B|C|D(D(D)?)?|E|F|G|H)$

# I noticed that a last name is Portuguese if it ends in -eira, -eiro, -nha, or -nho. I know there are other Portuguese names that don't end with these, but I haven't yet come across any other foreign last names (besides Portuguese/Brazilian) that end in those 4.
# ID: 1953
^[A-Z][a-z]+((eir|(n|l)h)(a|o))$

# Scientific notation from school as best as we can put it on textboxes/textareas.
# ID: 1957
^(\d)(\.)(\d)+\s(x)\s(10)(e|E|\^)(-)?(\d)+$

# Flight numbers have two parts: The first 2 characters denote the airline's two-letter code. This airline code MUST be either letter-letter, number-letter, or letter-number, NEVER number-number. The 3rd digit has to be a numeric digit from 1 to 9 inclusive. After this 3rd digit, we may append any integer from 0 to 999.
# ID: 1958
^([A-Z]{2}|[A-Z]\d|\d[A-Z])[1-9](\d{1,3})?$

# Legend has it that if a last name ends in -man or -berg, the person who has that last name is Jewish. Of course there are Jewish people whose names don't follow the pattern, and there could be those whose last names end in -man or -berg who are not Jewish (or are they and they don't just know it?).
# ID: 1959
^[A-Z][a-z]+(tz)?(man|berg)$

# This is how a composer catalogued his or her musical works in classical music, except for Bach (who used BWV) and Mozart (who used K.). There may have been others. However, most other composers used the format Opus x, Number y. Sometimes, it's just Opus x if it's a big work like a concerto or a symphony.
# ID: 1960
^(Op(.|us))(\s)[1-9](\d)*((,)?(\s)N(o.|um(.|ber))\s[1-9](\d)*)?$

# How do you tell whether a last name is of Dutch origin? This pattern captures the -enga's, -stra's, and -ema's. There are also other Dutch names that don't end with these three "suffixes" but you know it's Dutch if it ends with either of those three.
# ID: 1950
^[A-Z][a-z]+((e(m|ng)|str)a)$

# College course numbers are usually in the format LLLLNNN where L is a letter and N is a numeric digit, where the first digit ranges from 1-8 inclusive. 1-4 is undergrad, and 5-8 is masters and above.
# ID: 1951
^[A-Z]{4}[1-8](\d){2}$

# Pattern for Pennsylvania, Ohio, and Michigan (new) regular license plates
# ID: 1940
^[A-Z]{3}(\s)?[0-9]{4}$

# An individual's (soon to be) Medicare number in the USA is a social security number (whether it be the individual's, spouse's, or parent) plus a series of 1 or 2 digit characters at the end.
# ID: 1941
^((\d){3})(-)?(\d){2}(-)?(\d){4}(A|B[1-7]?|M|T|C[1-4]|D)$

# You can tell whether a last name is French or not. How do you teach your programs to recognize French last names? Here's an attempt. We haven't really covered other French names like LaMarre or François yet. Those will be in future French-regonition regular expressions.
# ID: 1942
^[A-Z][a-z]+((i)?e(a)?(u)?[r(re)?|x]?)$

# For all of you who have Blue Cross Blue Shield insurance coverage (not Federal, though)- check out your insurance cards! It ALWAYS begins with 3 letters (called the alpha prefix) and a series of alpha-numeric characters ranging from 8 to 12 digits.
# ID: 1943
^[A-Z]{3}(\d|[A-Z]){8,12}$

# For those who work in the government somewhere who have BCBS coverage, this is your regular expression.
# ID: 1944
^R(\d){8}

# Part II of French last names. Like part 1, it doesn't cover all French names.
# ID: 1945
^[A-Z][a-z]+(o(i|u)(n|(v)?r(t)?|s|t|x)(e(s)?)?)$

# Play guitar or read sheet music for piano/keyboard? You've got to be familiar with chord notations. They've got to have some format that regular expressions can test.
# ID: 1946
^[A-G](b|#)?((m(aj)?|M|aug|dim|sus)([2-7]|9|13)?)?(\/[A-G](b|#)?)?$

# From experience and what I've been told, last names ending in -ian are most likely of Armenian origin. There could be some other foreign names that pass this pattern. Also, not every Armenian has a last name that ends in -ian. -ian is just common enough to stereotype.
# ID: 1947
~[A-Z][a-z]+(b|ch|d|g|j|k|l|m|n|p|r|s|t|v|z)(ian)$

# Modified version of Chris Myers' regexp for po boxes.  This one won't match the word "box" in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations.
# ID: 2245
\b[P|p]?(OST|ost)?\.?\s*[O|o|0]?(ffice|FFICE)?\.?\s*[B|b][O|o|0]?[X|x]?\.?\s+[#]?(\d+)\b

# phone number
# ID: 2138
/*d(9,15)

# Evaluates a date in the format of MMDD. Will evaluate month day ranges accurately with Feb going up to 29.
# ID: 2505
^((0[123456789]|1[0-2])(0[1-3]|1[0-9]|2[0-9]))|((0[13456789]|1[0-2])(30))|((0[13578]|1[02])(31))$

# Validates dates in the format MM/DD/YYYY, M/D/YYYY, or any permutation in between. Takes into account leap year as well as the rule that century marks are leap years only if they are divisible by 400.
# ID: 3529
^(?!0?2/3)(?!0?2/29/.{3}[13579])(?!0?2/29/.{2}[02468][26])(?!0?2/29/.{2}[13579][048])(?!(0?[469]|11)/31)(?!0?2/29/[13579][01345789]0{2})(?!0?2/29/[02468][1235679]0{2})(0?[1-9]|1[012])/(0?[1-9]|[12][0-9]|3[01])/([0-9]{4})$

# finds all addresses in the network starting with "213.61.220."
# ID: 3635
^213\.61\.220\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])$

# 8 to 64 characters. Spaces not allowed. Require at least one UPPER, one lower and one number. Then limit the input to a-z A-Z 0-9 _-+.$ # @ and !
# ID: 3231
(?=.*\d)(?=.*[a-z])(?=.*[A-Z])^[\w!@$#.+-]{8,64}$

# Fromat check for MM/YY, checks month is 1-12 and any 2 digit year.
# ID: 132
((0[1-9])|(1[02]))/\d{2}

# This RE matches the web links which begin http://, ftp://, https:// or www.
# ID: 1051
((http\://|https\://|ftp\://)|(www.))+(([a-zA-Z0-9\.-]+\.[a-zA-Z]{2,4})|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(/[a-zA-Z0-9%:/-_\?\.'~]*)?

# You can use this regular expression in your PHP scripts to convert entered URL in text to URL link. Example:
# ID: 1057
(((file|gopher|news|nntp|telnet|http|ftp|https|ftps|sftp)://)|(www\.))+(([a-zA-Z0-9\._-]+\.[a-zA-Z]{2,6})|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(/[a-zA-Z0-9\&%_\./-~-]*)?

# As always, I couldn't find a regex that worked for me. It only covers full urls with http:// and https://, obviously if you want to add ftp:// then change the first part to: (http://|https://|ftp://) etc..., you get my drift. If you want to cover everything, like short urls, try this site: http://internet.ls-la.net/folklore/url-regexpr.html
# ID: 1719
(http://|https://)([a-zA-Z0-9]+\.[a-zA-Z0-9\-]+|[a-zA-Z0-9\-]+)\.[a-zA-Z\.]{2,6}(/[a-zA-Z0-9\.\?=/#%&\+-]+|/|)

# Regular Expression that validate a phone number inside israel.
# ID: 214
^0[23489]{1}(\-)?[^0\D]{1}\d{6}$

# Regular Expression that validate Cellular phone in israel.
# ID: 215
^0(5[012345678]|6[47]){1}(\-)?[^0\D]{1}\d{5}$

# Get any file extension...
# ID: 733
.+\.([^.]+)$

# Matches basic SMTP server names.
# ID: 759
^(smtp)\.([\w\-]+)\.[\w\-]{2,3}$

# I am using a repeating section to provide multi email check wherein the separator can  be either a comma or a semi-colon. whitespaces are allowed after a delimiter.
# ID: 3029
^(?:(?:[\w\.\-_]+@[\w\d]+(?:\.[\w]{2,6})+)[,;]?\s?)+$

# This regex will search for all relation types like father, mother, grand father, cousin, brother, etc..
# ID: 3557
(([Gg]rand)?([Ff]ather|[Mm]other|mom|pop|son|daughter|parent|((p|m)a)|uncle|aunt)s?)|(([cC]ousin)?((?<=[cC]ousin)\s+(?=brother|sister))?(?<siblings>brother|sister)?((?<=brother|sister)s?)?)

# matches US states and territories in 2 character UPPER case. Reduced from Jason Gaylord's http://regexlib.com/REDetails.aspx?regexp_id=396
# ID: 2176
^((A[LKSZR])|(C[AOT])|(D[EC])|(F[ML])|(G[AU])|(HI)|(I[DLNA])|(K[SY])|(LA)|(M[EHDAINSOT])|(N[EVHJMYCD])|(MP)|(O[HKR])|(P[WAR])|(RI)|(S[CD])|(T[NX])|(UT)|(V[TIA])|(W[AVIY]))$

# The 50 US states and DC (Disctrict of Columbia).
# ID: 2177
^((A[LKZR])|(C[AOT])|(D[EC])|(FL)|(GA)|(HI)|(I[DLNA])|(K[SY])|(LA)|(M[EDAINSOT])|(N[EVHJMYCD])|(O[HKR])|(PA)|(RI)|(S[CD])|(T[NX])|(UT)|(V[TA])|(W[AVIY]))$

# A regex I came up with for validating urls, didn't test thoroughly but seems to do the trick.
# ID: 1818
^((http://)|(https://))((([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*))|(([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*)))/?([a-zA-Z0-9_/?%=&+#.-~]*)$

# This RegEx is based on existing one of Andy Smith ( http://regexlib.com/REDetails.aspx?regexp_id=26 ) here but add UNDERLINE and it validates this email
# ID: 3372
^([a-zA-Z0-9_\-\._]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-_]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$

# Used to return all the html tags and closing tags in a section of html. Can be used to replace all the tags with nothing or itterate through them.
# ID: 1586
<(?![!/]?[ABIU][>\s])[^>]*>

# also matches youtu.be/video_id,
# ID: 3514
^(http:\/\/)?(www\.)?youtu(be)?\.([a-z])+\/(watch(.*?)(\?|\&)v=)?(.*?)(&(.)*)?$

# This regular expression will verify all the moblie numbers in india
# ID: 1883
^([9]{1})([234789]{1})([0-9]{8})$

# This expression matches exclusively .png files. Filenames may contain hyphens, underscores, plusses or brackets, and may be both lower and uppercase.
# ID: 3515
[\w\-_\+\(\)]{0,}[\.png|\.PNG]{4}

# Matches only valid YouTube links. This includes directly linked videos (yimg) and using YouTube's shortening service (youtu.be). Also supports local domains, like youtube.nl, youtube.de, youtube.co.uk, etc.
# ID: 3516
(http://)?(www\.)?(youtube|yimg|youtu)\.([A-Za-z]{2,4}|[A-Za-z]{2}\.[A-Za-z]{2})/(watch\?v=)?[A-Za-z0-9\-_]{6,12}(&[A-Za-z0-9\-_]{1,}=[A-Za-z0-9\-_]{1,})*

# Spanish NIE Number. Currently ignores case, but seems to work quite nicely.
# ID: 1261
^[a-zA-Z]{1}[-][0-9]{7}[-][a-zA-Z]{1}$

# This validation is for Pakistan New CNIC.
# ID: 3228
^[0-9+]{5}-[0-9+]{7}-[0-9]{1}$

# Matches euro currency (portuguese regional options).
# ID: 809
^\s*-?((\d{1,3}(\.(\d){3})*)|\d*)(,\d{1,2})?\s?(\u20AC)?\s*$

# This matches Java class names such as "com.test.Test". It's being used within an XML Schema to validate classname as specified in XML documents.
# ID: 335
^(([a-z])+.)+[A-Z]([a-z])+$

# First attempt at reg ex - work in progress - can't quite get it to work absolutely correctly so any comments would be great.
# ID: 301
^(http|https|ftp)\://(((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])|([a-zA-Z0-9_\-\.])+\.(com|net|org|edu|int|mil|gov|arpa|biz|aero|name|coop|info|pro|museum|uk|me))((:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\-\._\?\,\'/\\\+&%\$#\=~])*)$

# Matches the TLD of a given domain (replace yourdomain.com with whatever domain you're trying to enforce).
# ID: 2181
^.*(yourdomain.com).*$

# Validates 8 or 10 character Bank Idenifier Code (BIC) / SWIFT. Also validates 2-letter country ISO code (5th and 6th characters).
# ID: 3442
^([a-zA-Z]){4}(AF|AX|AL|DZ|AS|AD|AO|AI|AQ|AG|AR|AM|AW|AU|AZ|BS|BH|BD|BB|BY|BE|BZ|BJ|BM|BT|BO|BA|BW|BV|BR|IO|BN|BG|BF|BI|KH|CM|CA|CV|KY|CF|TD|CL|CN|CX|CC|CO|KM|CG|CD|CK|CR|CI|HR|CU|CY|CZ|DK|DJ|DM|DO|EC|EG|SV|GQ|ER|EE|ET|FK|FO|FJ|FI|FR|GF|PF|TF|GA|GM|GE|DE|GH|GI|GR|GL|GD|GP|GU|GT|GG|GN|GW|GY|HT|HM|VA|HN|HK|HU|IS|IN|ID|IR|IQ|IE|IM|IL|IT|JM|JP|JE|JO|KZ|KE|KI|KP|KR|KW|KG|LA|LV|LB|LS|LR|LY|LI|LT|LU|MO|MK|MG|MW|MY|MV|ML|MT|MH|MQ|MR|MU|YT|MX|FM|MD|MC|MC|MN|ME|MS|MA|MZ|MM|MA|NR|NP|NL|AN|NC|NZ|NI|NE|NG|NU|NF|MP|NO|OM|PK|PW|PS|PA|PG|PY|PE|PH|PN|PL|PT|PR|QA|RE|RO|RU|RW|SH|KN|LC|PM|VC|WS|SM|ST|SA|SN|RS|SC|SL|SG|SK|SI|SB|SO|ZA|GS|ES|LK|SD|SR|SJ|SZ|SE|CH|SY|TW|TJ|TZ|TH|TL|TG|TK|TO|TT|TN|TR|TM|TC|TV|UG|UA|AE|GB|US|UM|UY|UZ|VU|VE|VN|VG|VI|WF|EH|YE|ZM|ZW)([0-9a-zA-Z]){2}([0-9a-zA-Z]{3})$

# Validates name of months January, Febuary, ..., December. Also accepts short hand forms jan, feb,..., dec.
# ID: 3443
^(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Sept|Oct(ober)?|Nov(ember)?|Dec(ember)?)$

# A regex that will split a CSV file when used for MATCH function.
# ID: 919
(?<=(?:^|,)")(?:[^"]|"")+

# MM/DD/YYYY
# ID: 3517
^(([1][0-2])|([0]?[1-9]{1}))\/(([0-2]?\d{1})|([3][0,1]{1}))\/(([1]{1}[9]{1}[9]{1}\d{1})|([2-9]{1}\d{3}))$

# Matches a string if it is a valid time in the format of HH:MM / H:MM / HH / H
# ID: 129
(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])$)|(^([0-9]|[1][0-9]|[2][0-3])$)

# This expression is a trim using regular expression.  This expression removes white spaces before and after the given input string
# ID: 748
^\s+|\s+$

# Matches hexadecimal values like in c-sourcecode exists.
# ID: 594
[0][x][0-9a-fA-F]+

# Used with Regex.Split, this pattern split every sentences in a paragraph or a text (it recognizes quotation marks " and » and multiple .!?) It matches the spaces between every sentence.
# ID: 2355
(?<=[\w\s](?:[\.\!\? ]+[\x20]*[\x22\xBB]*))(?:\s+(?![\x22\xBB](?!\w)))

# http://en.wikipedia.org/wiki/National_Drug_Code
# ID: 3074
\d{4}-\d{4}-\d{2}|\d{5}-\d{3}-\d{2}|\d{5}-\d{4}-\d{1}|\d{5}-\*\d{3}-\d{2}

# This expression will allow a time value with 15 minute increments.  It will not accept seconds.  You can use either US time or Military time format.
# ID: 249
^((([0]?[1-9]|1[0-2])(:|\.)(00|15|30|45)?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\.)(00|15|30|45)?))$

# Validates student Grade Point Average (GPA) value (based on U.S. Standard 0 thru 4.0 values)
# ID: 2259
^[0]|[0-3]\.(\d?\d?)|[4].[0]$

# Extension of Alsu Fifty's Simple String pattern: ^(\w(\s)?)+$ that allows inclusion of periods and dashes; useful for validating Name and Address fields
# ID: 1813
^(\w(([.-])*)(\s)?)+$

# This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered.
# ID: 2943
^(000000[1-9])$|^(00000[1-9][0-9])$|^(0000[1-9][0-9][0-9])$|^(000[1-9][0-9][0-9][0-9])$|^(00[1-9][0-9][0-9][0-9][0-9])$|^(0[1-9][0-9][0-9][0-9][0-9][0-9])$|^([1-9][0-9][0-9][0-9][0-9][0-9][0-9])$

# This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long.
# ID: 1737
^((0[1-9])|(1[0-2]))\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))\/(\d{4})$

# Validates a date expression (or empty value) in CCYYMMDD format, checking a leap year from 00000101 A.D. to 99991231
# ID: 609
^(((\d{4}((0[13578]|1[02])(0[1-9]|[12]\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\d|30)|02(0[1-9]|1\d|2[0-8])))|((\d{2}[02468][048]|\d{2}[13579][26]))0229)){0,8}$

# This will work with name in UPPER case and  LOWER case with or without spaces may include single quotes and email ID within fish marks.Email Id may include numbers too
# ID: 2010
([a-z\s.\-_'])*<\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*\>

# this pattern has the option of entering email ID with or without name .The name will allow '  and spaces as Alex D'souza
# ID: 2013
([a-z\s.\-_'])*<\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*\>|^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

# this will accept any number and any alphabet.
# ID: 2022
^\d*$|^\d+$*[a-zA-Z]*$;^\d+$|^\d+$*[a-zA-Z]+$

# This expression helps in finding any text inside [tex] – [/tex] tags. For example returns x+y=z for the following input [tex]x+y=z[/tex] Was written for parsing LaTex equations written by users in Html editor. Despite its’ original purpose it can be used for matching of any arbitrary tags in squared brackets.
# ID: 2973
(?<=[[]tex[]]).*?(?=[[]/tex[]])

# This .NET regex will match "SomeText" while not between the words "aaa" and "bbb". A good use of this is to find certain text while you are not inside of a certain HTML tag.
# ID: 1873
(?<!aaa((?!bbb)[\s\S])*)SomeText

# Will match any valid US or Canada zip code
# ID: 2494
^(\d{5}-\d{4}|\d{5}|\d{9})$|^([a-zA-Z]\d[a-zA-Z]( )?\d[a-zA-Z]\d)$

# This will allow user to enter only AlphaNumeric values. you can use as a Regular expression in Asp.net from version 1.1,2.0,3.5
# ID: 2968
[a-zA-Z0-9]*

# This expression gets a server bound or serverless ldap path without "LDAP://" in front of it.
# ID: 922
^(([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}/(DC=['\w\d\s\-\&]+[,]*){2,})|((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])/(DC=['\w\d\s\-\&]+[,]*){2,})|((DC=['\w\d\s\-\&]+[,]*){2,})$

# here its accepts valied email only
# ID: 2131
/^[-_.[:alnum:]]+@((([[:alnum:]]|[[:alnum:]][[:alnum:]-]*[[:alnum:]])\.)+(ad|ae|aero|af|ag|ai|al|am|an|ao|aq|ar|arpa|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|biz|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|com|coop|cr|cs|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|edu|ee|eg|eh|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gh|gi|gl|gm|gn|gov|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|in|info|int|io|iq|ir|is|it|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mil|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|museum|mv|mw|mx|my|mz|na|name|nc|ne|net|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|org|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pro|ps|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw)$|(([0-9][0-9]?|[0-1][0-9][0-9]|[2][0-4][0-9]|[2][5][0-5])\.){3}([0-9][0-9]?|[0-1][0-9][0-9]|[2][0-4][0-9]|[2][5][0-5]))$/i

# I was making a 301 redirect module and wanted to verify old and new urls
# ID: 3069
^(http\:\/\/[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(?:\/\S*)?(?:[a-zA-Z0-9_])+\.(?:[a-zA-Z])+)$

# RegEx to match Invalid XML character
# ID: 2980
[^\u0009\u000A\u000D\u0020-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]

# Matches any unsigned or signed floating point number/numeric string.
# ID: 1563
^-?\d+(\.\d+)?$

# Matches any unsigned floating point number/numeric string.
# ID: 1415
^\d+(\.\d+)?$

# Validates spanish mobile phones, begining with +34 international code
# ID: 3116
[+]346[0-9]{8}

# Here is a regular expression I wrote that validates U.S. phone numbers with area codes. You can't have a leading '0' or '1' but you can separate the number blocks with a space, a dot, a slash, or a hyphen. It also prevents a '0' or '1' for the first digit of the prefix. No extension is allowed and it must be 10 digits.
# ID: 752
^[\(]? ([^0-1]){1}([0-9]){2}([-,\),/,\.])*([ ])?([^0-1]){1}([0-9]){2}[ ]?[-]?[/]?[\.]? ([0-9]){4}$

# This is intended to split a string by full stop except when inside a pair of quotes.
# ID: 2691
\.(?=([^"]*"[^"]*")*(?![^"]*"))

# Matches groups separated by period/full-stop when outside of one or more balanced and/or nested pairs of brackets (i.e. top level processing).
# ID: 2692
[^.]*\((?>[^()]+|\((?<DEPTH>)|\)(?<-DEPTH>))*(?(DEPTH)(?!))\)[^.]*|[^.]+

# Percent regulaar expression.
# ID: 1478
^100$|^\s*(\d{0,2})((\.|\,)(\d*))?\s*\%?\s*$

# It could be use to validate html input form (checkbox, optionbox, selectbox) when you have multiple numeric value under one field name. The validation is that the user have at lease chose one or more!
# ID: 272
^[0-9]{1,}(,[0-9]+){0,}$

# This pattern matches a Valid Civil ID Number in Kuwait.
# ID: 993
^(1|2|3)((\d{2}((0[13578]|1[02])(0[1-9]|[12]\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\d|30)|02(0[1-9]|1\d|2[0-8])))|([02468][048]|[13579][26])0229)(\d{5})$

# checks German Street Name with housenumber
# ID: 2792
^([A-ZÄÖÜ][a-zäöüß]+(([.] )|( )|([-])))+[1-9][0-9]{0,3}[a-z]?$

# I use this one as a simple way to disallow HTML code in form fields.  It simply doesn't allow the use of the < and > characters.  It does, however, allow the entities for these characters (&lt; and &gt;), which will print the characters to the screen appropriately, if needed.  I'm sure there are more complex expressions to block HTML, but none more concise.
# ID: 1408
^[^<^>]*$

# This expression matches all fields from the format string of the  FormatMessage function. This is .NET version. It is based on Format Fields Specification at http://msdn.microsoft.com/en-us/library/56e442dc.aspx. According to format specification: %1-99[![flags][width][.precision][{h|l|ll|L|I|I32|I64|w}]type!] output match groups will contain: #1 or #7 - argument index, #2 - flags, #3 - width, #4 - precision, #5 - size prefix, #6 - type. If match #7 contains argument number then insert's format string (which is optional) is not specified and defaults to !s!.
# ID: 3361
(?<!%)(?:%%)*%(?(([1-9]\d?)!([\-\+0\ \#])?(\d+|\*)?(\.\*|\.\d+)?([hLIw]|l{1,2}|I32|I64)?([cCdiouxXeEfgGaAnpsSZ])!)|(?:([1-9]\d?)(?![!\d])))

# This expression matches all fields from the format string of the printf/scanf functions. This is .NET version. It is based on Format Fields Specification at http://msdn.microsoft.com/en-us/library/56e442dc.aspx.
# ID: 3363
(?<!%)(?:%%)*%([\-\+0\ \#])?(\d+|\*)?(\.\*|\.\d+)?([hLIw]|l{1,2}|I32|I64)?([cCdiouxXeEfgGaAnpsSZ])

# Applied to a .RTF document, returns all the names of the# bookmarks. Useful to  retrieve# dinamically#   the list of bookmarks from a document.
# ID: 1056
\{\\\*\\bkmkstart\s(.*?)\}

# A regex for cellphone numbers in Portugal, for the three major operators (TMN, Optimus, Vodafone).
# ID: 2833
^([9]{1})+(6|3|2|1{1})+([0-9]{7})$

# This expression matches a US phone number with or without the leading 1.
# ID: 1969
(1 )?\d{3} \d{3}-\d{4}

# This is a regular expression to validate a date string in "MM/DD/YYYY" format, a date time string in "MM/DD/YYYY HH:MM" or a date time string in "MM/DD/YYYY HH:MM:SS" format.
# ID: 230
^([0]\d|[1][0-2])\/([0-2]\d|[3][0-1])\/([2][01]|[1][6-9])\d{2}(\s([0-1]\d|[2][0-3])(\:[0-5]\d){1,2})?$

# Check date format YYYYMMDD
# ID: 2168
((^((1[8-9]\d{2})|([2-9]\d{3}))(10|12|0?[13578])(3[01]|[12][0-9]|0?[1-9])$)|(^((1[8-9]\d{2})|([2-9]\d{3}))(11|0?[469])(30|[12][0-9]|0?[1-9])$)|(^((1[8-9]\d{2})|([2-9]\d{3}))(0?2)(2[0-8]|1[0-9]|0?[1-9])$)|(^([2468][048]00)(0?2)(29)$)|(^([3579][26]00)(0?2)(29)$)|(^([1][89][0][48])(0?2)(29)$)|(^([2-9][0-9][0][48])(0?2)(29)$)|(^([1][89][2468][048])(0?2)(29)$)|(^([2-9][0-9][2468][048])(0?2)(29)$)|(^([1][89][13579][26])(0?2)(29)$)|(^([2-9][0-9][13579][26])(0?2)(29)$))

# This is a regular expression I used to validate negative and positive WHOLE numbers, including 0.
# ID: 724
(^[0]{1}$|^[-]?[1-9]{1}\d*$)

# Parses a person's name such as MR KENNETH L LEFEBVRE PHD, allowing for optional salutation, middle name, and suffix.
# ID: 801
(^((?<salutation>[MRD]\S+)[ ]+)?(?<first>\S+)[ ]+((?<middle>\S+)[ ]+)??(?<last>\S+)([ ]+(?<suffix>(PHD|MD|RN|JR|II|SR|III)))?)

# Well, I don't remember where from I got this expression, but I modified it a bit to work with asp.net 2.0's Regular expression validator. This validates if the password has atleast 6 characters, of which, atleast 1 character has to be Upper case, atleast 1 lower case, atleast 1 number and atleast one non-word character(say special symbols). Hope this is helpful.
# ID: 1901
^.*(?=.{6,})(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\W]).*$

# Validate a Canadian phone number and optional 3 to 4 digits extension
# ID: 2165
^([\(]{1}[0-9]{3}[\)]{1}[ |\-]{0,1}|^[0-9]{3}[\-| ])?[0-9]{3}(\-| ){1}[0-9]{4}(([ ]{0,1})|([ ]{1}[0-9]{3,4}|))$

# Will match valid Hexadecimal characters in a string.
# ID: 3352
/^[0-9a-fA-F]+$/

# Matches any IPv4.
# ID: 3508
\b([0-1]?\d{1,2}|2[0-4]\d|25[0-5])(\.([0-1]?\d{1,2}|2[0-4]\d|25[0-5])){3}\b

# It accepts only two integer after a decimal point. The number may be in Positive or negative.
# ID: 1849
^[-+]?\d+(\.\d{2})?$

# Explain the following  regular expressions. Where would they be used? What potential problems do you foresee in using them?
# ID: 3175
^[a-zA-Z0-9]+([_.-]?[a-zA-Z0-9]+)?@[a-zA-Z0-9]+([_-]?[a-zA-Z0-9]+)*([.]{1})[a-zA-Z0-9]+([.]?[a-zA-Z0-9]+)*$

# Explain the following 2 regular expressions. Where would they be used? What potential problems do you foresee in using them?
# ID: 3176
^[^<>&~\s^%A-Za-z\\][^A-Za-z%^\\<>]{1,25}$

# Used for dutch postalcodes; no leading zero. 4 numbers and 2 letters.
# ID: 401
^[1-9]{1}[0-9]{3}\s{0,1}?[a-zA-Z]{2}$

# Checks the phone number
# ID: 3510
^(\(\d{3}\)|\d{3})[\s.-]?\d{3}[\s.-]?\d{4}$

# Regular expression for validating US and CANADA telephone numbers with OPTIONAL contry code, OPTIONAL area code, and OPTIONAL extension. Matches various permutations of formatting characters (parenthesis, space, dash). Parses the telephone number contry code, area code, prefix, suffix, and extension ...
# ID: 898
^(?:(?<Contry>\d{1,1})(?<5>[- ]?)?)?(?:(?<1>[(])?(?<AreaCode>[2-9]\d{2})(?(1)[)])(?(1)(?<2>[ ])|(?:(?<3>[-])|(?<4>[ ])))?)?(?<Prefix>[1-9]\d{2})(?(AreaCode)(?:(?(1)(?(2)[- ]|[-]?))|(?(3)[-])|(?(4)[- ]))|[- ]?)(?<Suffix>\d{4})(?:[ ]?[#xXeE]?(?<Ext>\d{2,4}))?$

# first regex put on site.
# ID: 2210
^\+?1[0-7]\d(\.\d+)?$)|(^\+?([1-9])?\d(\.\d+)?$)|(^-180$)|(^-1[1-7]\d(\.\d+)?$)|(^-[1-9]\d(\.\d+)?$)|(^\-\d(\.\d+)?$

# Latitude must<90 >=-90
# ID: 2211
^\+?([1-8])?\d(\.\d+)?$)|(^-90$)|(^-(([1-8])?\d(\.\d+)?$))

# validate time
# ID: 2212
^((1[01])|(\d)):[0-5]\d(:[0-5]\d)?\s?([apAP][Mm])?$

# match <td ***>***</td> in html,so any other html mark with<sth></sth> is just do a little change to this
# ID: 2213
^<\s*(td|TD)\s*(\w|\W)*\s*>(\w|\W)*</(td|TD)>$

# match ip
# ID: 2214
^((([1]\d{2})|(22[0-3])|([1-9]\d)|(2[01]\d)|[1-9]).(([1]\d{2})|(2[0-4]\d)|(25[0-5])|([1-9]\d)|\d).(([1]\d{2})|(2[0-4]\d)|(25[0-5])|([1-9]\d)|\d).(([1]\d{2})|(2[0-4]\d)|(25[0-5])|([1-9]\d)|\d))$

# Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. To include more simply add logical 'or' (|) operator and append.
# ID: 343
(.*\.([wW][mM][aA])|([mM][pP][3])$)

# This expression was derived from Mike Cromwell's version, which matches the XSD schema duration built in type as defined by http://www.w3.org/TR/xmlschema-2/#duration.  This version adds named captured groups to assist with extracting the data.
# ID: 2294
^[-]?P(?!$)(?:(?<year>\d+)+Y)?(?:(?<month>\d+)+M)?(?:(?<days>\d+)+D)?(?:T(?!$)(?:(?<hours>\d+)+H)?(?:(?<minutes>\d+)+M)? (?:(?<seconds>\d+(?:\.\d+)?)+S)?)?$

# pass in to your search term, a number and an expression to match.  Replace the 2 and ipsum with those.  Use the "matches" array to return all match strings.  Is tolerant of word matches at start and end of string
# ID: 3250
(\s*\S*){2}(ipsum)(\S*\s*){2}

# Matches TCP port numbers from 0 to 65535. Other than '0', no leading 0's are accepted.
# ID: 1236
^(0|([1-9]\d{0,3}|[1-5]\d{4}|[6][0-5][0-5]([0-2]\d|[3][0-5])))$

# Searches for SQL comments within a T-SQL statement...
# ID: 1053
/\*.+?\*/

# Matchs comma delimited numbers. Easily changed to allow for other delimiters. (Edit ",")
# ID: 1055
^([1-9]{1}(([0-9])?){2})+(,[0-9]{1}[0-9]{2})*$

# This is useful for finding contact numbers, or mobile numbers or phone numbers while crawling websites.
# ID: 1390
[\+]{0,1}(\d{10,13}|[\(][\+]{0,1}\d{2,}[\13)]*\d{5,13}|\d{2,6}[\-]{1}\d{2,13}[\-]*\d{3,13})

# This pattern is a slight modification in pattern submitted by Jacek Sompel. Using this tag one can also match anchor tags not having ' (single quote) or " (double quote) in href. This is useful for web crawler for crawling all links in a web page.
# ID: 1391
<a[\s]+[^>]*?href[\s]?=[\s\"\']*(.*?)[\"\']*.*?>([^<]+|.*?)?<\/a>

# This allows for a single line input of open and close times (for a store/office).
# ID: 3042
^(([0-1][0-9]|2[0-3])[0-5][0-9]\-([0-1][0-9]|2[0-3])[0-5][0-9]|[C|c]losed)$

# Can be used to remove
# ID: 286
(\/\/-->\s*)?<\/?SCRIPT([^>]*)>(\s*<!--\s)?

# Matches only a 32 character hex string (Eg. MD5). Based off Chris Craft's expression:-)
# ID: 1909
^\{?[a-fA-F\d]{32}\}?$

# Validates blood pressure in the format systolic/diastolic.
# ID: 2769
^\b(29[0-9]|2[0-9][0-9]|[01]?[0-9][0-9]?)\\/(29[0-9]|2[0-9][0-9]|[01]?[0-9][0-9]?)$

# A regular expression which allows me to find strings of text floating around in free text that are in fact URLs. I need to tag these as <url>www.bmj.com/advice</url>. The problem has been allowing special characters in the url, but not mixing them up with genuine punctuation marks at the end of the url in the text-e.g. '.' or '?' or ) or ';' etc)
# ID: 1416
((www|http)(\W+\S+[^).,:;?\]\} \r\n$]+))

# It is used to specify a precision
# ID: 2071
[0-9][.][0-9]{3}$

# simulates sql batch parsing behavior of isql.exe given an inputfile.
# ID: 2025
(?:^.*\r*\n*)*?(?:(?=^\s*GO\s*$)|$)

# Validates positive numbers with in the 0 to 4 range and up to two decimal places
# ID: 3538
^((0{1})?([0-3]{0,1}))(\.[0-9]{0,2})?$|^(4)(\.[0]{1,2})?$|^((0{1})?([0-4]{0,1}))(\.)?$

# It verifies that: - Only letters, numbers and email acceptable symbols (+, _, -, .) are allowed - No two different symbols may follow each other - Cannot begin with a symbol - Ending domain must be at least 2 letters - Supports subdomains - TLD must be between 2 and 6 letters (Ex: .ca, .museum) - Only (-) and (.) symbols are allowed in domain, but not consecutively.
# ID: 295
^(([A-Za-z0-9]+_+)|([A-Za-z0-9]+\-+)|([A-Za-z0-9]+\.+)|([A-Za-z0-9]+\++))*[A-Za-z0-9]+@((\w+\-+)|(\w+\.))*\w{1,63}\.[a-zA-Z]{2,6}$

# Thanks to Ariel Merrell, as well as the folks who developed the javascript location object for some of the inspiration for this.
# ID: 1273
# Multiline
(?<url>(?<protocol>http(s?)|ftp)\:\/\/(?<host>(?<hostname>((?<subdomain>([a-z]\w*\.)*[a-z]\w*)\.)?((?<ip>(\d{1,3}\.){3}\d{1,3})|((?<org>[a-z]\w*)\.(?<domain>[a-z]{2,3}))))?(\:(?<port>\d+))?)(?<path>(?<directory>(\/.*)*\/)?(?<file>[a-z]\w*\.\w+)?)?(\#(?<hash>[^?\n\r]+))?(\?(?<search>(\&?[^\=\n\r]+\=[^\&\n\r]*)+))?)

# Validation to Brazilian telephone number (mobile or not), including DDD and allowing "9o Dígito" (on all DDDs). It also accept 2 or 3 digit DDD (11 or 011).
# ID: 3634
^(0{0,1}[1-9][0-9]){1}(\s){0,1}(\-){0,1}(\s){0,1}[1-9]{1}([0-9]{3}|[0-9]{4})(\-){0,1}(\s){0,1}[0-9]{4}$

# Validate a Skype name based on the Skype faq: https://support.skype.com/en-us/faq/FA94/What-is-a-Skype-Name
# ID: 3388
[a-zA-Z][a-zA-Z0-9_\-\,\.]{5,31}

# It will allow to enter 10 digits phone number. the number can start with + symbol or any number as well.
# ID: 3562
^(\+){0,1}\d{1,10}$

# The expression is used to validate all the number which follows the format of pakistani mobile companies cell phone number format.
# ID: 3563
^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$

# Checks file paths for offending characters
# ID: 1212
([,!@#$%^&*()\[\]]+|\\\.\.|\\\\\.|\.\.\\\|\.\\\|\.\.\/|\.\/|\/\.\.|\/\.|;|(?<![A-Z]):)

# This filter is able to filter a full of address. It uses extension definition
# ID: 2104
^[_a-zA-Z0-9-]+(\.[_a-zA-Z0-9-]+)?@[a-zA-Z0-9-]+(((\.[0-9]{1,3}){0,3})|((\.(co|com|net|org|edu|gov|mil|aero|coop|info|museum|name|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|fx|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw)){1,2}))$

# This Blacklist RegEx is designed to search a user input for any malicious code or SQL injection attempts.
# ID: 977
(script)|(<)|(>)|(%3c)|(%3e)|(SELECT) |(UPDATE) |(INSERT) |(DELETE)|(GRANT) |(REVOKE)|(UNION)|(&lt;)|(&gt;)

# Wrote this to accept either decimals or zero, but not whole numbers - for a particular project...
# ID: 612
(^([0-9]+[.]+[0-9]+)|(0)$)

# Only positive values in the range 1.00 to 100.00 (2 decimal places maximum) are valid. The decimal precision is optional. The Percent char % is not used.
# ID: 2997
^(100(\.0{0,2}?)?$|([1-9]|[1-9][0-9])(\.\d{1,2})?)$

# Matches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.
# ID: 144
^((([0]?[1-9]|1[0-2])(:|\.)[0-5][0-9]((:|\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\.)[0-5][0-9]((:|\.)[0-5][0-9])?))$

# Australian phone numbers: Matches all known formats incl normal 10-digit landline numbers (valid area code mandatory) 13, 1300, 1800, 1900, 1902 plus mobile 10 and 11-digit formats. Use a Replace function first to remove non-numerics which are probably separators (E.g. newNum = number.replace(/[\D]/g, &quot;&quot;).  Please contact me if you find any valid Aussie numbers being rejected.
# ID: 66
(^1300\d{6}$)|(^1800|1900|1902\d{6}$)|(^0[2|3|7|8]{1}[0-9]{8}$)|(^13\d{4}$)|(^04\d{2,3}\d{6}$)

# This expression is for matching the currency input. The £ is optional. e.g. £12.12, £ 12.12, 12.12, 12.
# ID: 1786
^(( )*\£{0,1}( )*)\d*(.\d{1,2})?$

# Dutch licenceplate check also including scooters#
# ID: 1129
(([a-zA-Z]{3}[0-9]{3})|(\w{2}-\w{2}-\w{2})|([0-9]{2}-[a-zA-Z]{3}-[0-9]{1})|([0-9]{1}-[a-zA-Z]{3}-[0-9]{2})|([a-zA-Z]{1}-[0-9]{3}-[a-zA-Z]{2}))

# EDI mapping from COPRAR to COPARN
# ID: 2336
((EQD[^']*')(RFF[^']*'){0,9}(EQN[^']*')?(TMD[^']*'){0,9}(DTM[^']*'){0,9}(LOC[^']*'){0,9}(MEA[^']*'){0,9}(DIM[^']*'){0,9}(TMP[^']*'){0,9}(RNG[^']*'){0,9}(SEL[^']*'){0,9}(FTX[^']*'){0,9}(DGS[^']*'){0,9}(EQA[^']*'){0,9}(NAD[^']*')?)((TDT[^']*')(RFF[^']*'){0,9}(LOC[^']*'){0,9}(DTM[^']*'){0,9})?

# Match Segments 2 and 3 of BAPLIE file.  May be repeating.
# ID: 2304
(LOC[^']*')(GID[^']*')?(GDS[^']*')?(FTX[^']*'){0,9}(MEA[^']*'){1,9}(DIM[^']*'){0,9}(TMP[^']*')?(RNG[^']*')?(LOC[^']*'){0,9}(RFF[^']*')((EQD[^']*')(EQA[^']*'){0,9}(NAD[^']*')?){0,3}

# Password validation with any two of combinations: [A-Z],[a-z],Punctuation Symbols with minimum user requirement without digits.If digit is added , it wont validate.As per requirement add '.{n,m}' without quotes before the $ sign in the expression.
# ID: 3412
^((\D*[a-z]\D*[A-Z]\D*)|(\D*[A-Z]\D*[a-z]\D*)|(\D*\W\D*[a-z])|(\D*\W\D*[A-Z])|(\D*[a-z]\D*\W)|(\D*[A-Z]\D*\W))$

# 6-10 characters, at least 4 characters and at least 2 numbers
# ID: 1929
^.*(?=.{6,10})(?=.*[a-zA-Z].*[a-zA-Z].*[a-zA-Z].*[a-zA-Z])(?=.*\d.*\d).*$

# for getting cdata from and xml document.
# ID: 1193
<!\[CDATA\[([^\]]*)\]\]>

# Checks for a MySQL valid date  formated as Y-M-D. January, March, May, July, August, Octobe and December are valid with max of 31 days, February is valid with max of 29 days, April, June, September and November are valis with max of 30 days. Valid for years from 1900 to 2099.
# ID: 3446
^(19|20)[0-9]{2}-((01|03|05|07|08|10|12)-(0[1-9]|[12][0-9]|3[01]))|(02-(0[1-9]|[12][0-9]))|((04|06|09|11)-(0[1-9]|[12][0-9]|30))$

# I was looking for a date format that allowed 1 or 2 digit Month and Days and 2 digit years. I found and tweak this one
# ID: 2148
^((((0?[13578])|(1[02]))[\-]?((0?[1-9]|[0-2][0-9])|(3[01])))|(((0?[469])|(11))[\-]?((0?[1-9]|[0-2][0-9])|(30)))|(0?[2][\-]?(0?[1-9]|[0-2][0-9])))[\-]?\d{2}$

# I just couldn't find any simple expression to check if an entered value is a jp(e)g.
# ID: 1267
(.*\.jpe?g|.*\.JPE?G)

# regular expresion to evalute time
# ID: 2637
(^([1-9]|[1][0-2]):([0-5][0-9])(\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)|(^([0-9]|[1][0-9]|[2][0-3]):([0-5][0-9])$)|(^([1-9]|[1][0-2])(\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)|(^([0-9]|[1][0-9]|[2][0-3])$)

# RegExp for validating the format of IP Addresses. This works great with the ASP.NET RegularExpressionValidator server control.
# ID: 32
^(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])$

# Domain names:
# ID: 25
^[a-zA-Z0-9\-\.]+\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$

# Detects megaupload files and folders links.
# ID: 2924
megaupload\.com.*(?:\?|&)(?:(?:folderi)?d|f)=([A-Z-a-z0-9]{8})

# This regular expression validates an IP address within the range of 1.0.0.0 to 255.255.255.255
# ID: 2922
^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}$

# American spellings: -ize verb forms.
# ID: 1112
\b([a-z]+)(?:(?<=emphas|fantas)|(?<!ba|ma|pr|se|s))([iy])z(a(?:bl[ey]|tion(?:|al(?:|ly)|s))|es?|ed|ers?|ing)\b

# British spellings: -ise verb forms. To construct -ize equivalents, use: \1\2z\3 The project page is https://sourceforge.net/projects/xml-copy-editor/. Released under the GNU GPL.
# ID: 1113
\b([a-z]+)(?:(?<=ic|[ai]m|[^a-z]pr|[eiou][tr])|(?<![rd]a|c|gu|m|parad|o|p|r|[acrs]t|v|w))([iy])s(a(?:bl[ey]|tion(?:|al(?:|ly)|s))|e|ed|ers?|(?<!ys)es|ing)\b

# This matches Natural numbers with or without preceding zeros.
# ID: 2697
^[0]*?[1-9]\d*\.?[0]*$

# This can be used to validate package names ending with %. If % is not needed ^([a-z]+?\.[a-z]+)+. (.....) can be used to make that part common. "+" is for more than one number of occurences. "?" is for one "." (dot) charactor
# ID: 2694
^([a-z]+?\.[a-z]+)+\%$

# Matches the valid date format MM/DD/YY Year from 2000 (00) to 2008 (08) and the month will accept till 12 and the day will accept till 31
# ID: 2191
\b(0?[1-9]|1[0-2])(\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\/)(0[0-8])\b

# Matches the valid date format MM-DD-YY Year from 2000 (00) to 2008 (08) and the month will accept till 12 and the day will accept till 31
# ID: 2192
\b(0?[1-9]|1[0-2])(\-)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\-)(0[0-8])\b

# It will matches the railway time format that 00:00:00 to 23:59:59
# ID: 2193
\b(0[0-9]|1[0-9]|2[0-3])(\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\b

# It will matches the Standard time format that 00:00:00 to 11:59:59
# ID: 2194
\b(0[0-9]|1[0-1])(\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\b

# It will matches the Standard time format that 00:00:00 AM to 11:59:59 PM
# ID: 2195
\b(0[0-9]|1[0-1])(\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\s*(AM|PM|A|P)\b

# VALIDATE THE DATE FORMAT FULL MONTH DAY, CCYY i.e August 30, 2006
# ID: 2196
\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\s*(\,)\s*(200[0-9])\b

# VALIDATE THE DATE FORMAT FULL MONTH DAY, YY i.e August 30, 06 (2006)
# ID: 2197
\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\s*(\,)\s*(0[0-9])\b

# VALIDATE THE DATE FORMAT SHORT MONTH DAY, CCYY i.e Aug 30, 2006
# ID: 2198
\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\s*(\,)\s*(200[0-9])\b

# VALIDATE THE DATE FORMAT SHORT MONTH DAY, YY i.e Aug 30, 06 (2006)
# ID: 2199
\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\s*(\,)\s*(0[0-9])\b

# Matches the valid date format MM/DD/CCYY
# ID: 2109
\b(0?[1-9]|1[0-2])(\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\/)(200[0-8])\b

# Matches the valid date format MM-DD-CCYY
# ID: 2110
\b(0?[1-9]|1[0-2])(\-)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\-)(200[0-8])\b

# Validate American Dollar Amount Format
# ID: 2123
(\$\s*[\d,]+\.\d{2})\b

# Validate the numbers 1 to 9
# ID: 2124
\b[1-9]\b

# Validate the numbers in between 39 to 50 (i.e 40 to 49)
# ID: 2125
\b4[0-9]\b

# This match time format
# ID: 2029
(\d{1,2}(\:|\s)\d{1,2}(\:|\s)\d{1,2}\s*(AM|PM|A|P))

# This will match those string which contains the word "kumar"
# ID: 2781
^.*(?:kumar).*$

# Match the numbers 1 to 99
# ID: 2782
(\b(1|2|3|4|5|6|7|8|9)?[0-9]\b)

# Match the numbers 100 to 199
# ID: 2783
(\b(10|11|12|13|14|15|16|17|18|19)[0-9]\b)

# This Regular Expression is used to match the Companies House 503 Reference number that is given when a customer places an online order.www.companieshouse.gov.uk
# ID: 1656
^[0-9]{3}[-|/]{1}[0-9]{6}[-|/]{1}[0-9]{6}$

# Thie expression is used to match a United Kingdom Limited Company number in the UK. This is for Companies registered in England & Wales ONLY. This does not include Scotland.
# ID: 1657
^[0-9]{8}$

# Thie expression is used to match a United Kingdom Limited Company number in the UK. This is for Companies registered in Scotland. This is not for Companies registered in England & Wales.
# ID: 1658
^[SC]{2}[0-9]{6}$

# This expression can be used to check against the format of a United Kingdom Vehicle Registration plate in the new style.
# ID: 1659
^[A-Za-z]{2}[ ]{0,1}[0-9]{2}[ ]{0,1}[a-zA-Z]{3}$

# Expression to check for .com email addresses
# ID: 1661
^[a-zA-z0-9]+[@]{1}[a-zA-Z]+[.]{1}[a-zA-Z]+$

# Expression to check for a valid ISBN number
# ID: 1662
^[ISBN]{4}[ ]{0,1}[0-9]{1}[-]{1}[0-9]{3}[-]{1}[0-9]{5}[-]{1}[0-9]{0,1}$

# UK Mobile phone number check
# ID: 1663
^[0-9]{0,5}[ ]{0,1}[0-9]{0,6}$

# Companies House Postal Search account number expression
# ID: 1664
[cC]{1}[0-9]{0,7}

# Marine Latitude
# ID: 1973
([0-8][0-9]|[9][0])°' '[0-9][0-9]\.[0-9]´' '[NS]

# Marine Longitude
# ID: 1974
(([01][0-7]|[00][0-9])[0-9]|[1][8][0])°' '[0-9][0-9]\.[0-9]´' '[EW]

# for cut links on PHP
# ID: 3671
<a[\s]+[^>]*?.*?>([^<]+|.*?)?<\/a>

# Checks only for valid ones. Always in lowercase. Separated Tags and contents in three groups for useful handling.
# ID: 1996
(\[b\])([^\[\]]+)(\[/b\])

# Only matches well-constructed tags.
# ID: 1997
(\[[abiu][^\[\]]*\])([^\[\]]+)(\[/?[abiu]\])

# Matches well-formed tags.
# ID: 1998
(\[a url=\"[^\[\]\"]*\"\])([^\[\]]+)(\[/a\])

# Very useful to get a value, Value is in a capture group for best handling.
# ID: 1999
url=\"([^\[\]\"]*)\"

# This small regex is useful to count the number of words of a text.
# ID: 2000
\b\w+\b

# Gets simple tags without parameters
# ID: 2001
(<b>)([^<>]+)(</b>)

# Very useful to detect if there are pieces of HMTL in a text
# ID: 2002
(</?\w*[^<>]*>)

# Mathes any HTML tag with any parameters and HTML Comments. Very useful to clean HTML of a text.
# ID: 1898
<!*[^<>]*>

# This pattern matches any HTML character code in hexadecimal format. Doesn't match numerical code such as &#203; or any friendly code character such as &nbsp;
# ID: 1892
&#x((?=.*[ABCDEF]))*((?=.*[0-9]))*.{2,5};

# This pattern matches any HTML special character code in the knowed friendly-code.
# ID: 1893
&[a-zA-Z]+\d{0,3};

# This pattern matches any HTML special character in numerical code.
# ID: 1894
&#\d{2,5};

# Mathes any HTML tag with any parameters. Very useful to clean HTML of a text.
# ID: 1895
</?[a-z][a-z0-9]*[^<>]*>

# Tests if the input consists of 6 or more letters, digits, underscores and hyphens. The input must contain at least one upper case ltter, one lower case letter and one digit.
# ID: 1896
(?=[-_a-zA-Z0-9]*?[A-Z])(?=[-_a-zA-Z0-9]*?[a-z])(?=[-_a-zA-Z0-9]*?[0-9])[-_a-zA-Z0-9]{6,}

# i can use one regex one times, e.g. i can use regex: ip-address separatly. I can use also regex for NUMBER separatly. But how can i merge this 2 regex to one regex, that i can use my expression for numbers or for ip addresses together.
# ID: 1642
For IP-Address:(?<First>2[0-4]\d|25[0-5]|[01]?\d\d?)\.(?<Second>2[0-4]\d|25[0-5]|[01]?\d\d?)\.(?<Third>2[0-4]\d|25[0-5]|[01]?\d\d?)\.(?<Fourth>2[0-4]\d|25[0-5]|[01]?\d\d?)  For Number: (\+|\*{0,2})?(\d*)

# Accepts a colon-delimited string of positive integers and/or decimal numbers in any combination. Spaces are not permitted. Decimal numbers of less than 1 must be prefixed with a zero (e.g. accepts 0.1, but not .1), and numbers with a trailing decimal point are not accepted (e.g. accepts 3.0, but not 3.). A lone zero is not accpeted (e.g. accepts 1.02:3:4.5, but not 1.02:0:4.5). Developed from a similar expression by Steven Smith on this site.
# ID: 1780
^(([1-9][0-9]*)|((([0])|([1-9][0-9]*))\.[0-9]+)|((([1-9][0-9]*)|((([0])|([1-9][0-9]*))\.[0-9]+))\:)*(([1-9][0-9]*)|((([0])|([1-9][0-9]*))\.[0-9]+)))$

# Intended to validate Australian Phone Numbers.
# ID: 2054
^(\+\d{2}[ \-]{0,1}){0,1}(((\({0,1}[ \-]{0,1})0{0,1}\){0,1}[2|3|7|8]{1}\){0,1}[ \-]*(\d{4}[ \-]{0,1}\d{4}))|(1[ \-]{0,1}(300|800|900|902)[ \-]{0,1}((\d{6})|(\d{3}[ \-]{0,1}\d{3})))|(13[ \-]{0,1}([\d \-]{5})|((\({0,1}[ \-]{0,1})0{0,1}\){0,1}4{1}[\d \-]{8,10})))$

# Based on a pattern I found on this site, this pattern verifies that a number is a multiple of 5. Basically checks the last number before the decimal point to see if it's a 5 or 0. Also works on non-decimal numbers.
# ID: 864
^\d*\d?((5)|(0))\.?((0)|(00))?$

# Meets german norm-standard: DIN 5008: 1996-05 for telephone numbers
# ID: 224
^\(\d{1,2}(\s\d{1,2}){1,2}\)\s(\d{1,2}(\s\d{1,2}){1,2})((-(\d{1,4})){0,1})$

# Validate Indonesian "Mobile Numbers Only" with or without the country code, also base on regular phone number format at http://id.wikipedia.org/wiki/Daftar_kode_telepon_di_Indonesia. This regex only allowed characters that accepted by mobile phone/sms gateway only :D
# ID: 2967
^((?:\+62|62)|0)[2-9]{1}[0-9]+$

# Too complex for a short explanation. It doesn't check for valid IP ranges and it also doesn't obey the rule, that a double colon in IPv6 only can exist once in the address notation. The optional port match at the end can be omitted. The RegEx has been constructed the way, that if an explicit identification fails, the complete match fails. For example someone write "My adress:2001::1234" the match will fail 'cos of the leading colon, even though it's an valid IPv6 address. A "My adress: 2001::1234" or "My adress:[2001::1234]" will work. Beware, that the RegEx is build for case-insensitive usage and no whitespaces are allowed inside the address.
# ID: 2034
(^|\s|(\[))(::)?([a-f\d]{1,4}::?){0,7}(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?=(?(2)\]|($|\s|(?(3)($|\s)|(?(4)($|\s)|:\d)))))|((?(3)[a-f\d]{1,4})|(?(4)[a-f\d]{1,4}))(?=(?(2)\]|($|\s))))(?(2)\])(:\d{1,5})?

# Address match with optional match of protocol and port. Use case-insensitive. The matching brackets are:
# ID: 2035
(?:^|\s)([a-z]{3,6}(?=://))?(://)?((?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.(?:25[0-5]|2[0-4]\d|[01]?\d\d?))(?::(\d{2,5}))?(?:\s|$)

# Host/Domain name validation for perl.
# ID: 158
^([a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9]\.)+([a-zA-Z0-9]{3,5})$

# A simple url search pattern that works against the most generic cases. A little better in terms of matches than the other URL expressions listed.
# ID: 700
[a-zA-Z]{3,}://[a-zA-Z0-9\.]+/*[a-zA-Z0-9/\\%_.]*\?*[a-zA-Z0-9/\\%_.=&]*

# this expression not allowed to enter toll free no.
# ID: 2155
(8[^0]\d|8\d[^0]|[0-79]\d{2})-\d{3}-\d{4}

# Regular expression for find date with time.
# ID: 3248
((\(\d{2}\) ?)|(\d{2}/))?\d{2}/\d{4} ([0-2][0-9]\:[0-6][0-9])

# Phone Number with (+country code) optional and in 3-3-4 format with or without ()and -
# ID: 3201
^( )*(\+?( )?\(?( )?(\d{1,3})?)\)?(.|-|_ )?\(?(\d{3})\)?(.|-|_ )?\(?(\d{3})\)?(.|-|_ )?\(?(\d{4})\)?( )*$

# Intended to validate html5 form input of type=tel in internation E.164 format, to validate Dutch phone numbers for valid routes and length. Geographic (open number plan: subscriber number cannot start with 0,1 or 9), and non-geographic (closed number plan), 0800 and 090x numbers including 8/11 digit length checking. Not implemented are 14xxx style government numbers. This regex can be used in PBXes as part of a larger dial plan string to allow immediate dialing as soon as the correct number of digits has been entered. Replace \+ with your international dialing prefix.
# ID: 3185
^\+31(?:(?:1[035]|2[0346]|3[03568]|4[0356]|5[0358]|7\d)[2-8]\d{6}|(?:11[134578]|16[124-8]|17[24]|18[0-467]|22[2346-9]|25[125]|29[479]|31[3-8]|32[01]|34[1-8]|41[12368]|47[58]|48[15-8]|49[23579]|51[1-9]|52[1-5789]|54[13-8]|56[126]|57[0-3578]|59[1-9])[2-8]\d{5}|(?:6[1-68]|8[4578]|91)\d{7}|(?:800(?:0[013-8]|1\d|2[01]|4[1369]|[5-9][01])|90[069](?:0[0-35-9]|1[345789]|8[013468]|9[235-8]))\d{2}|(?:800(?:0[29]|[26-9][2-9]|3\d|4[24578])|90[069](?:04|1[0126]|[2-7]\d|8[2579]|9[0149]))\d{5})$

# Intended to validate html5 form input of type=tel in internation E.164 format, to validate Belgian phone numbers for valid routes and length. As Belgium has a closed number plan the regex is relatively short and in theory any subscribing number is possible, even ones starting with 0, 1 or 9 as the area code needs to be dialed always. This regex can be used in PBXes as part of a larger dial plan string to allow immediate dialing as soon as the correct number of digits has been entered. Replace \+ with your international dialing prefix.
# ID: 3186
^\+32(?:1[0-69]|[23][2-8]|4[236-9]|5\d|6[01345789]|7[01689]|8[0-79]|9[012])\d{6}$

# Intended to validate html5 form input of type=tel in internation E.164 format, to validate German phone numbers for valid routes and length. As Germany has an open number plan and area codes that are 2, 3, 4 or 5 digits long and emergency services 19222 that can be dialed from outside of the area and number blocks where the owner can choose to have shorter numbers for number queries this regex is enormous in length. This regex can be used in PBXes as part of a larger dial plan string to allow immediate dialing as soon as the correct number of digits has been entered. Replace \+ with your international dialing prefix.
# ID: 3187
\+49(?:(?:30|40|69|89)(?!11)[1-9]\d{3,7}|(?:20[12389]|21[124]|22[18]|23[14]|2[4-9]1|3[35-9][15]|34[015]|4[2-9]1|5[1-9]1|6[1-8]1|7[1-9]1|8[1-8]1|906|9[1-9]1)(?!11)[1-9]\d{2,6}|(?:204[135]|205[1-468]|206[456]|210[234]|2129|213[1237]|215[0-46-9]|216[1-6]|217[1345]|218[123]|219[12356]|22[023][2-8]|224[1-8]|225[1-7]|226[1-9]|227[1-5]|229[1-7]|230[1-9]|232[3457]|233\d|235[1-5789]|236\d|23[78][1-5789]|239[1-5]|24[02][1-9]|243[1-6]|244[013-9]|245[1-6]|246[1-5]|247[1-4]|248[2456]|250[124-9]|252\d|253[3-68]|254[1235-8]|25[56][1-8]|257[1-5]|258[1-8]|259\d|260[1-8]|262[0-8]|263\d|264[1-7]|265[1-7]|266[1-467]|267[1-8]|268\d|269[1-7]|272[1-5]|273[2-9]|274[1-57]|275[0-589]|276[1-4]|277\d|280[1-4]|282[1-8]|283[1-9]|284[1-5]|285\d|286[1-7]|287[1-4]|290[2-5]|29[2-5][1-578]|296[1-4]|297[1-57]|298[1-5]|299[1-4]|330[1-467]|332[12789]|333[124578]|33[46][1246]|337[125789]|338[1256]|339[145]|342[135]|34[34][13578]|346[1246]|347[1356]|349[1346]|350[14]|352[123589]|353[1357]|354[1246]|356[1-4]|357[13468]|358[13568]|359[1246]|360[1356]|362[1-489]|363[12456]|364[1347]|366[13]|367[12579]|368[12356]|369[135]|372[1-7]|373[1357]|374[145]|376[1-5]|377[1-4]|3821|383[1468]|384[1347]|386[0135-9]|387[1467]|388[136]|390[12479]|392[1358]|393[1357]|394[134679]|396[1-9]|397[136]|398[147]|399[1468]|410[1-9]|412\d|413[1-9]|414[0-4689]|415[1-689]|41[67][1-9]|418\d|419[1-5]|420[2-9]|422[1-4]|42[34]\d|425[1-8]|426\d|427[1-7]|428[1-9]|429[2-8]|430[23578]|432[0-46-9]|433\d|434[02346-9]|435[1-8]|436[1-7]|437[12]|438[1-5]|439[234]|440[1-9]|442[12356]|443[1-5]|444[1-7]|445[1-68]|446[1-9]|447[1-5789]|448\d|449[1-9]|450[1-689]|452[1-9]|453[1-79]|454[1-7]|455\d|456[1-4]|460[2-9]|462[1-7]|463\d|464[1-46]|4651|466[1-8]|46[78][1-4]|470[2-8]|472[1-5]|473[1-7]|474\d|475[1-8]|476[1-9]|477\d|479[1-6]|480[2-6]|482[1-9]|483[02-9]|484[1-9]|485[1-9]|486[1-5]|487[1-7]|488[1-5]|489[23]|490[23]|492\d|493[1-689]|494[1-8]|495\d|496[1-8]|497[1-7]|502[1-8]|503[1-7]|504[1-5]|505[1-6]|506[02-9]|507[1-4]|508[2-6]|510[123589]|512[136-9]|513[0125-9]|514[1-9]|515[1-9]|516[1-8]|517[1-7]|518[1-7]|519\d|520[1-9]|522[1-68]|523[1-8]|524[124-8]|525[0-5789]|526[1-6]|527[1-8]|528[1-6]|529[2-5]|53[02]\d|533[1-79]|534[14-7]|53[56][1-8]|537[1-9]|538[1-4]|540[1-79]|54[235][1-9]|54[46][1-8]|547[1-6]|54[89][1-5]|550[2-9]|552[0-5789]|55[345][1-6]|556[1-5]|557[1-4]|558[2-6]|559[2-4]|560[1-9]|56[23][1-6]|564[1-8]|565\d|566[1-5]|567[1-7]|56[89][1-6]|570[2-7]|57[24][1-6]|573[1-4]|575[1-5]|576[13-9]|577[1-7]|580[2-8]|582\d|583[1-9]|584[0-689]|585[0-5789]|586[1-5]|587[2-5]|588[23]|590[1-9]|592[1-6]|593[1-79]|594[1-8]|595[1-7]|596[1-6]|597[135-8]|600[23478]|602[0-46-9]|603[1-69]|604[1-9]|605\d|606[12368]|607[1348]|608[1-7]|609[2-6]|610[1-9]|612[02346-9]|613[0-689]|614[24-7]|615[01245789]|616[1-7]|617[1-5]|618[1-8]|619[02568]|62[04][1-79]|622[0-46-9]|62[36][1-9]|62[59][1-8]|627[12456]|628[1-7]|63[09][1-8]|63[235][1-9]|634\d|636[1-4]|637[1-5]|638[1-7]|64[02]\d|643[0-689]|644[0-79]|645[1-8]|646[124-8]|647[1-9]|648[2-6]|650\d|652[2-7]|653[1-6]|654[1-5]|655\d|656[1-9]|657[1-58]|658\d|659[1-79]|66[25]\d|66[36][013-9]|66[49][1-8]|667[02-8]|668[1-4]|670[1346-9]|67[25][1-8]|67[34][1-7]|67[67][1-6]|678[1-9]|680[2-69]|682[14-7]|68[35][1-8]|684[1-489]|686[14-9]|687[1-6]|688[178]|689[3478]|70[245][1-6]|703[1-4]|706[236]|707[123]|708[1-5]|712[1-9]|713[0-689]|714[1-8]|715[0-46-9]|71[67][1-6]|718[1-4]|719[1-5]|720[2-4]|722\d|72[37][1-7]|724[02-9]|72[56]\d|730[02-9]|73[28][1-9]|73[36][1-7]|734[03-8]|735[1-8]|737[13-6]|739[1-5]|740[234]|742[02-9]|743[1-6]|744\d|745[1-9]|746[1-7]|747[1-8]|748[2-6]|750[2-6]|753[0245789]|754[1-6]|755[1-8]|756[1-9]|757[0-9|758[1-7]|7602|762\d|76[347][1-6]|765[1-7]|766\d|768[1-5]|770[2-9]|772\d|773[1-689]|774[1-8]|775[1345]|776[1-5]|777[13457]|780[2-8]|782[1-6]|783[1-9]|78[45][1-4]|790[3-7]|79[34]\d|795[0-5789]|79[67][1-7]|802\d|803[1-689]|804[12356]|80[56][1-7]|80[78][1-6]|809[1-5]|810[2-6]|812[1-4]|813[13-9]|814[1-6]|815[12378]|816[15-8]|817[016-9]|819[1-6]|820[2-8]|82[29][1-6]|823[

# This pattern handles currency including the following:
# ID: 604
^(\$)?((\d+)|(\d{1,3})(\,\d{3})*)(\.\d{2,})?$

# Matches over 18 different combinations for UK phone numbers that I could find.  If there are any errors please get in touch.
# ID: 2771
((\+44\s?\(0\)\s?\d{2,4})|(\+44\s?(01|02|03|07|08)\d{2,3})|(\+44\s?(1|2|3|7|8)\d{2,3})|(\(\+44\)\s?\d{3,4})|(\(\d{5}\))|((01|02|03|07|08)\d{2,3})|(\d{5}))(\s|-|.)(((\d{3,4})(\s|-)(\d{3,4}))|((\d{6,7})))

# Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.
# ID: 58
^([0-9]( |-)?)?(\(?[0-9]{3}\)?|[0-9]{3})( |-)?([0-9]{3}( |-)?[0-9]{4}|[a-zA-Z0-9]{7})$

# Matches any sequence of decimal digits that represent a positive denary multiple of three.
# ID: 2455
([0369]*([147][0369]*([147][0369]*[258])*[0369]*[147][0369]*([258][0369]*[147])*[0369]*[0369]*([258][0369]*[147])*[0369]*[147]|[258][0369]*([258][0369]*[147])*[0369]*[258][0369]*([147][0369]*[258])*[0369]*[0369]*([147][0369]*[258])*[0369]*[258]|[147][0369]*([147][0369]*[258])*[0369]*[258]|[258][0369]*([258][0369]*[147])*[0369]*[147])*[0369]*)*

# Matches any positive or negative number, with or without decimal places, where the digits are grouped in threes seperated by commas.
# ID: 2456
[+-]?(0|[1-9]([0-9]{0,2})(,[0-9]{3})*)(\.[0-9]+)?

# Matches a number using normalised scientific 'E' notation
# ID: 2457
[+-]?\d(\.\d+)?[Ee][+-]?\d+

# Matches any palindromic word of between 2 and 7 characters length. Best to use without case-sensitivity as "Noon" would not match otherwise because of the capitalisation.
# ID: 2458
(\w)(\w)?(\w)?\w?(?(3)\3)(?(2)\2)\1

# Use in Java programming code to find trailing spaces (a checkstyle warning). Replace All with the empty string to remove them.
# ID: 2459
[ \t]+$

# Matches any of the 66 unicode non-characters (guaranteed never to be used for encoding characters). Could be useful for checking if a document is text-renderable.
# ID: 2461
[\uFDD0-\uFDEF]

# Regular Expression que permite la validación del RFC usado en México, permitiendo los años bisiestos
# ID: 3455
^(([A-Z|a-z|&]{3}|[A-Z|a-z]{4})\d{2}((0[1-9]|1[012])(0[1-9]|1\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)(\w{2})([A|a|0-9]{1})$

# Removes HTML comments with ease. Based off of Chris Craft's /* ... */ comment removal.
# ID: 1853
<!--[\d\D]*?-->

# Validation for Malaysian MyKad number, with or without -
# ID: 2723
^\d{2}[0-1][0-9][0-3][0-9]-{0,1}\d{2}-{0,1}\d{4}$

# Verifies all valid Gregorian dates of the form DD MONTH YY, taking days/month and leap years into account.
# ID: 1025
# Multiline
(0[1-9]|[12][0-9]|3[01])\s(J(anuary|uly)|Ma(rch|y)|August|(Octo|Decem)ber)\s[1-9][0-9]{3}|(0[1-9]|[12][0-9]|30)\s(April|June|(Sept|Nov)ember)\s[1-9][0-9]{3}|(0[1-9]|1[0-9]|2[0-8])\sFebruary\s[1-9][0-9]{3}|29\sFebruary\s((0[48]|[2468][048]|[13579][26])00|[0-9]{2}(0[48]|[2468][048]|[13579][26]))

# Don Johnston's pattern modified to optionally accept a leading 1 or +1. Non-capturing groups are used for efficiency
# ID: 1773
^(?:(?:\+?1[\s])|(?:\+?1(?=(?:\()|(?:\d{10})))|(?:\+?1[\-](?=\d)))?(?:\([2-9]\d{2}\)\ ?|[2-9]\d{2}(?:\-?|\ ?))[2-9]\d{2}[- ]?\d{4}$

# Don Johnston's pattern modified to optionally accept leading 1 or +1 and to allow 7 digit dialing (still legal in some states). Non-capturing groups are used for efficiency
# ID: 1774
(?:^(?:(?:\+?1[\s])|(?:\+?1(?=(?:\()|(?:\d{10})))|(?:\+?1[\-](?=\d)))?(?:\([2-9]\d{2}\)\ ?|[2-9]\d{2}(?:\-?|\ ?))[2-9]\d{2}[- ]?\d{4}$)|(?:^[2-9]\d{2}[- ]?\d{4}$)

# Finds title, first name, middle initial, last name, and suffix of a name. Middle names are added to first name. Uses .Net capture group names.
# ID: 2153
^(?<title>.*\.\s)*(?<firstname>([A-Z][a-z]+\s*)+)(\s)(?<middleinitial>([A-Z]\.?\s)*)(?<lastname>[A-Z][a-zA-Z-']+)(?<suffix>.*)$

# Matches variable names/identifier from C# (and most other languages)
# ID: 336
^[a-zA-Z_][a-zA-Z0-9_]*$

# Danish social security. [ddMMyy-0000]. Validates a correct date, but does not enforce the modulus 11 check (see www.cpr.dk for more information).
# ID: 1580
^((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\d{2}))|((29)(02)(00))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[-]\d{4})$

# determines if the selected string is valid tlen.pl communicator login
# ID: 2698
[a-z]{1}[a-z0-9\-_\.]{2,24}@tlen\.pl

# Matches valid html tag attribute name (without value).
# ID: 3413
[a-zA-Z_:][a-zA-Z0-9_,\.\-]*?

# matches any string  with characters repeated more than twice, sometimes used as fake input
# ID: 460
(.)\1{2,}

# Variable 1 = "complete attribute and value".
# ID: 1830
<.*\b(bgcolor\s*=\s*[\"|\']*(\#\w{6})[\"|\']*).*>

# retrieve any tag and its content
# ID: 1333
(< *balise[ *>|:(.|\n)*>| (.|\n)*>](.|\n)*</balise *>)

# The sip/sips syntax is from http://www.ietf.org/rfc/rfc3261.txt?number=3261, seems the pattern works fine, but I worry about the performance
# ID: 1459
^(sip|sips)\:\+?([\w|\:?\.?\-?\@?\;?\,?\=\%\&]+)

# Latitude and longitude coordinates separated by a comma in the form:
# ID: 2972
[NS] \d{1,}(\:[0-5]\d){2}.{0,1}\d{0,},[EW] \d{1,}(\:[0-5]\d){2}.{0,1}\d{0,}

# match the csharp string Syntax
# ID: 2709
".*?[^"\\]"(?!")|""

# match chsarp method with 2 or 3 string parameters syntax
# ID: 2710
\(\s*@*(".*?[^"\\]"(?!")||"")\s*,\s*@*(".*?[^"\\]"(?!")|"")\s*(?:\)|(?:,\s*@*(".*?[^"\\]"(?!")||"")\s*))?\)

# Matches decimal numbers that are divisible by 3. :-)
# ID: 3451
((?=[^147]*([147][^147]*[147][^147]*[147][^147]*)*$)[^258]*([258][^258]*[258][^258]*[258][^258]*)*)|((?=[^147]*([147][^147]*[147][^147]*[147][^147]*)*[147][^147]*$)[^258]*([258][^258]*[258][^258]*[258][^258]*)*[258][^258]*)|((?=[^147]*([147][^147]*[147][^147]*[147][^147]*)*[147][^147]*[147][^147]*$)[^258]*([258][^258]*[258][^258]*[258][^258]*)*[258][^258]*[258][^258]*)

# Bibe Books, Chapters and versus.
# ID: 1337
([1-3]{0,1}\n{0,1}\s{0,1}\n{0,1}[a-zA-Z]+\s{1}\n{0,1}\d{1,2}:{1}\s{0,1}\d{1,2}){1}(,{1}\n{0,1}\s{0,1}\d{1,2}({1}\s{0,9}\n{0,1}\d{1,2}){0,9}){0,9}(-{1}\s{0,1}\n{0,1}\d{1,2}){0,9}(,{1}\s{0,1}\d{1,2}){0,9}(;\s{0,1}\n{0,1}\d{1,2}\s{0,1}:{1}\s{0,1}\d{1,2}(-{1}\s{0,9}\n{0,1}\d{1,2}){0,9}(,{1}\s{0,9}\d{1,2}(-{1}\s{0,9}\n{0,1}\d{1,2}){0,9}){0,9}){0,9}

# Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric).  Each part of the date will be returned as a selection e.g. \1 will contain the Year, \2 will contain the Month.
# ID: 1403
^(\d{4})\D?(0[1-9]|1[0-2])\D?([12]\d|0[1-9]|3[01])(\D?([01]\d|2[0-3])\D?([0-5]\d)\D?([0-5]\d)?)?$

# match US currency
# ID: 1948
^((\d{1,3}((,\d{3})*|\d*)(\.{0,1})\d+)|\d+)$

# Date in DD/MM/YYYY format.
# ID: 374
(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])(\d{4}))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(\d{4}))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])(\d{4}))|((29)(\.|-|\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))

# This will match all tags in a string, it's good for stripping HTML or XML tags to get the plain text.It works with attributes that include javascript or "<>".
# ID: 746
<(?:[^"']+?|.+?(?:"|').*?(?:"|')?.*?)*?>

# Here is my first regexp. I hope you like it! It parses quite a few different urls, although it's not a high-quality regexp. Http, Ftp protocols are supported, parameters and anchors too.
# ID: 1217
((http|ftp|https):\/\/w{3}[\d]*.|(http|ftp|https):\/\/|w{3}[\d]*.)([\w\d\._\-#\(\)\[\]\\,;:]+@[\w\d\._\-#\(\)\[\]\\,;:])?([a-z0-9]+.)*[a-z\-0-9]+.([a-z]{2,3})?[a-z]{2,6}(:[0-9]+)?(\/[\/a-z0-9\._\-,]+)*[a-z0-9\-_\.\s\%]+(\?[a-z0-9=%&\.\-,#]+)?

# An expression to look for numbers that repeat 3 or more times in succession.
# ID: 1258
0{3,}|1{3,}|2{3,}|3{3,}|4{3,}|5{3,}|6{3,}|7{3,}|8{3,}|9{3,}

# Breaks a PayPal IPN (instant payment notification) into it's respective parts via Groups.
# ID: 2676
^(?<hours>\d{2}):(?<minutes>\d{2}):(?<seconds>\d{2}) (?<month>[a-zA-Z]{3}) (?<day>\d{1,}), (?<year>\d{4}) (?<timezone>[a-zA-Z]{3})$

# Breaks JavaScript Date.toString() out into groups to allow easy reassembly. Works in FireFox 3.0.8, IE 8, Maxthon, Safari, and Chrome
# ID: 2677
^(?<dayOfWeek>\w{3}) (?<monthName>\w{3}) (?<day>\d{1,2}) (?<year>\d{4})? ?(?<hours>\d{1,2}):(?<minutes>\d{1,2}):(?<seconds>\d{1,2}) (GMT|UTC)(?<timeZoneOffset>[-+]?\d{4}) (?<year>\d{4})?\(?(?<timeZoneName>[a-zA-Z\s]+)?\)?$

# US IRS Employee ID Number, aka Federal Tax ID Number
# ID: 3076
^([07][1-7]|1[0-6]|2[0-7]|[35][0-9]|[468][0-8]|9[0-589])-?\d{7}$

# Based on the work of N H (http://regexlib.com/REDetails.aspx?regexp_id=96). Adds named groups including port and top-level-domain (tld), added ftps protocol, makes protocol optional, makes slash after site optional. Suggestions welcome.
# ID: 2766
(?<protocol>(http|ftp|https|ftps):\/\/)?(?<site>[\w\-_\.]+\.(?<tld>([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|arpa|asia|coop|info|jobs|mobi|museum|name|travel))+(?<port>:[0-9]+)?\/?)((?<resource>[\w\-\.,@^%:/~\+#]*[\w\-\@^%/~\+#])(?<queryString>(\?[a-zA-Z0-9\[\]\-\._+%\$#\~',]*=[a-zA-Z0-9\[\]\-\._+%\$#\~',]*)+(&[a-zA-Z0-9\[\]\-\._+%\$#\~',]*=[a-zA-Z0-9\[\]\-\._+%\$#\~',]*)*)?)?

# Based on the work of N H (http://regexlib.com/REDetails.aspx?regexp_id=96). Added ftps protocol, makes protocol optional, makes slash after site optional.
# ID: 2767
((http|ftp|https|ftps):\/\/)?[\w\-_\.]+\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|arpa|asia|coop|info|jobs|mobi|museum|name|travel))+(:[0-9]+)?\/?(([\w\-\.,@^%:/~\+#]*[\w\-\@^%/~\+#])((\?[a-zA-Z0-9\[\]\-\._+%\$#\=~',]*=[a-zA-Z0-9\[\]\-\._+%\$#\=~',]*)+(&[a-zA-Z0-9\[\]\-\._+%\$#\=~',]*=[a-zA-Z0-9\[\]\-\._+%\$#\=~',]*)*)?)?

# Validates Canadian postal codes.
# ID: 2836
^(?![DFIOQU])([ABCEGHJ-NPRSTVXY]\d[A-Z][ ]\d[A-Z]\d)$

# Validates passwords to be 6-20 characters of letter and numbers and NO special characters (that appear on the keyboard). Adjust numbers at the end and remove special characters (after the "(?!") as needed. Numbers appear at the END to address an IE problem with zero-width look-aheads.
# ID: 2809
^(?=.*\d)(?=.*[A-Za-z])(?!.*[!@#\$%\^&\*\(\)\+=\|;'"{}<>\.\?\-_\\/:,~`]).{6,20}$

# Matches the name portion of a named group. Useful for "cleaning" regular expressions for use with ASP controls (since they don't support named groups).
# ID: 2810
\?<.+?>

# Matches valid emails. Suggestions welcome.
# ID: 2811
(?<username>#?[+_a-zA-Z0-9+-]+(\.[+_a-zA-Z0-9+-]+)*)@(?<domain>[a-zA-Z0-9]+(-(?!-)|[a-zA-Z0-9\.])*?[a-zA-Z0-9]+\.([0-9]{1,3}|[a-zA-Z]{2,3}|(aero|arpa|asia|coop|info|jobs|mobi|museum|name|travel)))

# Matches VALID 10 digit US phone numbers. Formatting characters are optional. Valid area codes and prefixes never begin with 0 or 1.
# ID: 2812
\(?(?<areacode>[1]?[2-9]\d{2})\)?[\s-]?(?<prefix>[2-9]\d{2})[\s-]?(?<linenumber>[\d]{4})

# Matches HTML 'amp' codes
# ID: 2882
((&#[0-9]+|&[a-zA-Z]+[0-9]*?);)

# [-90.000000 ... 90.000000]
# ID: 3253
^-?(?:90(?:(?:\.0{1,6})?)|(?:[0-9]|[1-8][0-9])(?:(?:\.[0-9]{1,6})?))$

# [-180.000000 ... 180.000000]
# ID: 3254
^-?(?:180(?:(?:\.0{1,6})?)|(?:[0-9]|[1-9][0-9]|1[1-7][0-9])(?:(?:\.[0-9]{1,6})?))$

# This pattern can find any HTML tag. It supports attributes whose values may be enclosed between single or double quotes. It aslo support spaces between delimeters.
# ID: 2005
<\s*/?\s*\w+(\s*\w+\s*=\s*(['"][^'"]*['"]|[\w#]+))*\s*/?\s*>

# Substitute that regex with null to clean up emails witch got replied 1000 times and are Fed up with a lot of >'s
# ID: 1265
(?<=(\n|^))(>\s*)+

# Matches all chars that are made up of one or more spaces. I found this useful when people were trying to make string length bypasses using consecutive spaces.
# ID: 1930
(\s{1,})

# This Regex matches valid SQL identifiers, including names for Stored Procedures and the like. Note that local variables/parameters (which begin with an "@") will not match this Regex, nor will temporary objects (beginning with a "#"), or global temporary objects (beginning with "##"). All other valid identifiers/variables/table names/stored procedure names/columns etc., will match. Please let me know if you find this useful or have any complaints - trash@primalblaze.com.
# ID: 821
^[a-zA-Z_]{1}[a-zA-Z0-9_@$#]*$

# This matches oracle binding variables in SQL.  Not sure if it is the same with other RDBMS'
# ID: 1131
(:[a-z]{1}[a-z1-9\$#_]*){1,31}

# Basically I didn't like any of the regular expressions that were available because they all failed at parsing them into variables correctly...  This regular expression gives you the full match and then the 3 sections of digits seperately.
# ID: 1335
^\(?([0-9]{3})\)?[\s\.\-]*([0-9]{3})[\s\.\-]*([0-9]{4})$

# Basically this matches into variables for percentages..  It allows as much whitespace before and after the expression.  $1 = Percent before decimal, $2 = percentage after decimal inc decimal, $3 = percentage after decimal. Disallowed anything past 99.99999 repeating percent.  No negative percents either.  Easy to implement but I do not need it.
# ID: 1348
^\s*(\d{0,2})(\.?(\d*))?\s*\%?\s*$

# To check that maximum 3 digits it should be after decimal
# ID: 2048
/^[0-9]+\.d{3}? *$/

# Australian date format d/m/yyyy or dd/m/yyyy, d/mm/yyyy or dd/mm/yyyy. Valid dates from 1900 to 2099 including leap year.
# ID: 3222
^((((([1-9])|(0[1-9])|(1\d)|(2[0-8]))/(([1-9])|(0[1-9])|(1[0-2])))|((31/(((0[13578])|([13578]))|(1[02])))|((29|30)/(((0[1,3-9])|([1,3-9]))|(1[0-2])))))/((20[0-9][0-9]))|(((([1-9])|(0[1-9])|(1\d)|(2[0-8]))/(([1-9])|(0[1-9])|(1[0-2])))|((31/(((0[13578])|([13578]))|(1[02])))|((29|30)/(((0[1,3-9])|([1,3-9]))|(1[0-2])))))/((19[0-9][0-9]))|(29/(02|2)/20(([02468][048])|([13579][26])))|(29/(02|2)/19(([02468][048])|([13579][26]))))$

# Matches all dates (mm/dd/yyyy or mm/dd/yy) greater than or equal to the SQL minimum date of 01/01/1753 and less than or equal to 12/31/9999.  Does not check for leap years.
# ID: 2620
^(0?[1-9]|1[0-2])\/(0?[1-9]|[1-2][0-9]|3[0-1])\/(0[1-9]|[1-9][0-9]|175[3-9]|17[6-9][0-9]|1[8-9][0-9]{2}|[2-9][0-9]{3})$

# Email validation.  With this short expression you can validate for proper email format.  It's short and accurate.
# ID: 35
^\w+[\w-\.]*\@\w+((-\w+)|(\w*))\.[a-z]{2,3}$

# Validador de CPF ou CNPJ brasileiro. Utilizado em campos que podem receber os dois valores, como um campo de busca, que pode buscar por CPF ou CNPJ, como era o meu caso.
# ID: 1095
(^(\d{2}.\d{3}.\d{3}/\d{4}-\d{2})|(\d{14})$)|(^(\d{3}.\d{3}.\d{3}-\d{2})|(\d{11})$)

# good for cleanup none (farsi+arabic+english)letters
# ID: 1493
^[ a - z, 0 - 9 , ?   -   ?   ,?   -   ? , ?    -  ?   ,?   -  ? , . ]

# Cleanup non Alpha Numeric
# ID: 1494
[^""\?\/\&\;\:\|\”\“\(\)\[\]\=\^\.\%\$\#\!\*\?\?\»\«\×\?]

# Most email validation regexps are outdated and ignore the fact that domain names can contain any foreign character these days, as well as the fact that anything before @ is acceptable. The only roman alphabet restriction is in the TLD, which for a long time has been more than 2 or 3 chars (.museum, .aero, .info). The only dot restriction is that . cannot be placed directly after @.
# ID: 174
^.+@[^\.].*\.[a-z]{2,}$

# simple little RegExp to get the IMG tag from HTML
# ID: 322
<[iI][mM][gG]([^>]*[^/>])

# dakjlas
# ID: 2351
^\\w*$

# Matches href links / URLS within html and separates out the Scheme, Email, Domain, Path, Query, Anchor and the full URL.  Based on Andrew Lee's version with some further tweaking.
# ID: 2327
href=(?<QUOTE>[\""\'])?(?<URL>(?<SCHEME>(file|ftp|http|https|news|nntp):\/\/|mailto\:)?(?<EMAIL>[\w-]+@)?(?<HOST>(?(SCHEME)[\w]+(\.[\w-]+)*?))(?<PATH>\/?\w*[\w-%\:\.\+\/]+)?(?<QUERY>\?[\w-%\+:\.]*(=[\w-%\+:\.]*)?(&[\w-%\+\:\.]*(=[\w-%\+:\.]*)?)*)?(?<ANCHOR>\#[\w-%\+:\.]+)?)(?<-QUOTE>[\""\'])?(?(PATH)|(?(SCHEME)|(?!)))(?(QUOTE)(?!))

# Will match an HTML anchor and will include attributes.  It will output various named groups.
# ID: 2328
<a (?:(?<ATTRIBUTES>[\w-]+=[\""\']?[\w\S ]+?[\""\'])[ ]+)*href=(?<QUOTE>[\""\'])?(?<URL>(?<SCHEME>(file|ftp|http|https|news|nntp):\/\/|mailto\:)?(?<EMAIL>[\w-]+@)?(?<HOST>(?(SCHEME)[\w]+(\.[\w-]+)*?))(?<PATH>\/?\w*[\w-%\:\.\+\/]+)?(?<QUERY>\?[\w-%\+:\.]*(=[\w-%\+:\.]*)?(&[\w-%\+\:\.]*(=[\w-%\+:\.]*)?)*)?(?<ANCHOR>\#[\w-%\+:\.]+)?)?(?<-QUOTE>[\""\'])?(?:[ ]+(?<ATTRIBUTES>[\w-]+=[\""\']?[\w\S ]+?[\""\']))*>(?<TEXT>.+?)<\/a>(?(PATH)|(?(SCHEME)|(?!)))(?(QUOTE)(?!))

# Matches any non-negative, non-signed real number with maximum of 2 decimal spaces. The decimal is denoted by a . symbol.
# ID: 3531
^0$|^0\.{1}(\d{1,2})$|^[1-9]{1}[0-9]*\.?(\d{1,2})$|^[1-9]+[0-9]*$

# Match words in English that represent a number
# ID: 2990
\b(((((one|t((en)|(wo)|(hree)|(welve)|(hirteen))|(evelen)|(f((our)|(ive))|s((ix)|(even))|eight|nine)(teen)?))\b(\s+hundred\s*)?)| ((t((wen)|(hir))|f((or)|(if))|s((ix)|(even))|eigh|nin)ty)(-(one|t((wo)|(hree))|f((our)|(ive))|s((ix)|(even))|eight|nine))?) (\s*(hundred|thousand|((([mb]|(t|quad)r))illion))\s*(and\s+)?)?)+

# Another date regex. From year 1600-9999, days in month and leap year checks.  Formats include MM-dd-YYYY, dd-MM-yyyy, yyyy-MM-dd, MMM dd,yyyy or dd MMM yyyy. Years are always four digits,  months can be one or two digits, three letter abbreivation or full name.  Named months (non-digit) can have days with a suffix 1st, 2nd, etc. Numeric months must have a separtate between itself and the other date parts.  For Demo only: This was just a mental exercise don't use this for actual validation.  Used .Net regex engines advanced features for easier constuction. Use this website (or .net engine) to test.
# ID: 1784
^(?ni:(((?:((((((?<month>(?<monthname>(Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)))\ )|(?<month>(?<monthnum>(0?[13578])|10)(?<sep>[-/.])))(?<day>31)(?(monthnum)|st)?)|((((?<month>(?<monthname>Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?))\ )|((?<month>(?<monthnum>(0?[13-9])|1[012]))(?<sep>[-/.])))(?<day>((0?[1-9]|([12]\d)|30)|(?(monthname)(\b2?(1st|2nd|3rd|[4-9]th)|(2|3)0th|1\dth\b))))))|((((?<month>(?<monthname>Feb(ruary)?))\ )|((?<month>0?2)(?<sep>[-/.])))((?(monthname)(?<day>(\b2?(1st|2nd|3rd|[4-8]th)|9th|20th|1\dth\b)|(0?[1-9]|1\d|2[0-8])))|(?<day>29(?=(\k<sep>|(?(monthname)th)?,\ )((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))(?(sep)\k<sep>|((?(monthname)th)?,\ ))(?<year>(1[6-9]|[2-9]\d)\d{2}))$|((?<days>(31(?<suffix>st)?(?!(\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\b|t)t?|Nov)(ember)?))|[-/.](0?[2469]|11)))|((30|29)(?<suffix>th)?(?!((\ Feb(ruary)?)|([-/.]0?2))))|(29(?<suffix>th)?(?=((\ Feb(ruary)?\ )|([ -/.]0?2))(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(?<suffix>(?=\d\d?[nrst][dht]\ [JFMASOND])(\b2?(1st|2nd|3rd|[4-8]th)|20th|1\dth\b)|((0?[1-9])|1\d|2[0-8])))(?<month>(\ (?<monthname>(Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sep(?=\b|t)t?|Nov|Dec)(ember)?))\ )|(?(\k<suffix>)|((?<sep>[-/.])(0?[1-9]|1[012])\k<sep>)))(?<year>(1[6-9]|[2-9]\d)\d{2}))|\b((?<year>((1[6-9])|([2-9]\d))\d\d)(?<sep>[/.-])(?<month>0?[1-9]|1[012])\k<sep>(?<day>((?<!(\k<sep>((0?[2469])|11)\k<sep>))31)|(?<!\k<sep>(0?2)\k<sep>)(29|30)|((?<=((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00)\k<sep>(0?2)\k<sep>)29)|((0?[1-9])|(1\d)|(2[0-8]))))\b)(?:(?=\x20\d)\x20|$))?((?<time>((0?[1-9]|1[012])(:[0-5]\d){0,2}(\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2}))?)$

# This regex match both the old 10 digit ISBNs and the new 13 digit ISBNs.  The ISBN number must be prefixed by the literal text "ISBN:" or "ISBN-10:" or "ISBN-13:".  The colon is optional.  Naturally an ISBN prefixed by "ISBN-10" must be a 10 digit ISBN.  One prefixed by "ISBN-13" must be 13 digits.   If prefixed only by "ISBN:"  it can be either 10 or 13 digits.  This does not evaluate whether the check digit is valid for the given ISBN.  The structure of an ISBN is discribed here http://www.isbn.org/standards/home/isbn/international/html/usm4.htm (this is for 10 digit)
# ID: 1747
ISBN(-1(?:(0)|3))?:?\x20+(?(1)(?(2)(?:(?=.{13}$)\d{1,5}([ -])\d{1,7}\3\d{1,6}\3(?:\d|x)$)|(?:(?=.{17}$)97(?:8|9)([ -])\d{1,5}\4\d{1,7}\4\d{1,6}\4\d$))|(?(.{13}$)(?:\d{1,5}([ -])\d{1,7}\5\d{1,6}\5(?:\d|x)$)|(?:(?=.{17}$)97(?:8|9)([ -])\d{1,5}\6\d{1,7}\6\d{1,6}\6\d$)))

# This regex matches the new 13 digit ISBN.  The ISBN number must be preceded by the text "ISBN:" or "ISBN-13:" , the colon is optional. The proper lengthes of the ISBN elements is checked.  The is no check for the validity of the check digit.
# ID: 1748
ISBN(?:-13)?:?\x20*(?=.{17}$)97(?:8|9)([ -])\d{1,5}\1\d{1,7}\1\d{1,6}\1\d$

# This expression validates dates in the y/m/d format from 1600/1/1 - 9999/12/31. Follows the same validation rules for dates as my other date validator (m/d/y format) located in this library.
# ID: 190
^(?:(?:(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(\/|-|\.)(?:0?2\1(?:29)))|(?:(?:(?:1[6-9]|[2-9]\d)?\d{2})(\/|-|\.)(?:(?:(?:0?[13578]|1[02])\2(?:31))|(?:(?:0?[1,3-9]|1[0-2])\2(29|30))|(?:(?:0?[1-9])|(?:1[0-2]))\2(?:0?[1-9]|1\d|2[0-8]))))$

# This RE validates a path/file of type txt (text file)
# ID: 137
^(([a-zA-Z]:)|(\\{2}\w+)\$?)(\\(\w[\w ]*))+\.(txt|TXT)$

# This RE validates alpha characters that evaluate to Roman numerials, ranging from 1(I) - 3999(MMMCMXCIX). Not case sensitive.
# ID: 128
^(?i:(?=[MDCLXVI])((M{0,3})((C[DM])|(D?C{0,3}))?((X[LC])|(L?XX{0,2})|L)?((I[VX])|(V?(II{0,2}))|V)?))$

# This expression validates dates in the US m/d/y format from 1/1/1600 - 12/31/9999.
# ID: 113
^(?:(?:(?:0?[13578]|1[02])(\/|-|\.)31)\1|(?:(?:0?[13-9]|1[0-2])(\/|-|\.)(?:29|30)\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:0?2(\/|-|\.)29\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:(?:0?[1-9])|(?:1[0-2]))(\/|-|\.)(?:0?[1-9]|1\d|2[0-8])\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$

# DateTime Validator.
# ID: 369
^(?=\d)(?:(?:(?:(?:(?:0?[13578]|1[02])(\/|-|\.)31)\1|(?:(?:0?[1,3-9]|1[0-2])(\/|-|\.)(?:29|30)\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})|(?:0?2(\/|-|\.)29\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))|(?:(?:0?[1-9])|(?:1[0-2]))(\/|-|\.)(?:0?[1-9]|1\d|2[0-8])\4(?:(?:1[6-9]|[2-9]\d)?\d{2}))($|\ (?=\d)))?(((0?[1-9]|1[012])(:[0-5]\d){0,2}(\ [AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$

# This RE validates times patterns.
# ID: 370
^((0?[1-9]|1[012])(:[0-5]\d){0,2}(\ [AP]M))$|^([01]\d|2[0-3])(:[0-5]\d){0,2}$

# This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.
# ID: 404
^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\ (0?[1-9]|([12]\d)|30))|(Feb(ruary)?\ (0?[1-9]|1\d|2[0-8]|(29(?=,\ ((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\,\ ((1[6-9]|[2-9]\d)\d{2}))

# This RE validates dates in the dd MMM yyyy format. Spaces separate the values.
# ID: 405
^((31(?!\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\b|t)t?|Nov)(ember)?)))|((30|29)(?!\ Feb(ruary)?))|(29(?=\ Feb(ruary)?\ (((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8])\ (Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sep(?=\b|t)t?|Nov|Dec)(ember)?)\ ((1[6-9]|[2-9]\d)\d{2})$

# This RE validate the full name of the months.
# ID: 406
^(?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)$

# This RE matches Days of the week or their abbreviations.
# ID: 385
^(Sun|Mon|(T(ues|hurs))|Fri)(day|\.)?$|Wed(\.|nesday)?$|Sat(\.|urday)?$|T((ue?)|(hu?r?))\.?$

# This RE validates the format of an ISBN number
# ID: 463
ISBN\x20(?=.{13}$)\d{1,5}([- ])\d{1,7}\1\d{1,6}\1(\d|X)$

# captures US street address.
# ID: 472
^(?n:(?<address1>(\d{1,5}(\ 1\/[234])?(\x20[A-Z]([a-z])+)+ )|(P\.O\.\ Box\ \d{1,5}))\s{1,2}(?i:(?<address2>(((APT|B LDG|DEPT|FL|HNGR|LOT|PIER|RM|S(LIP|PC|T(E|OP))|TRLR|UNIT)\x20\w{1,5})|(BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR)\.?)\s{1,2})?)(?<city>[A-Z]([a-z])+(\.?)(\x20[A-Z]([a-z])+){0,2})\, \x20(?<state>A[LKSZRAP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADL N]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD] |T[NX]|UT|V[AIT]|W[AIVY])\x20(?<zipcode>(?!0{5})\d{5}(-\d {4})?))$

# This RE will match XML tag elements.  All elements must be closed. Won't match nested tags
# ID: 433
<(\w+)(\s(\w*=".*?")?)*((/>)|((/*?)>.*?</\1>))

# New DateTime Regex. Rebuilt better than before, better, stronger, faster.
# ID: 504
(?n:^(?=\d)((?<month>(0?[13578])|1[02]|(0?[469]|11)(?!.31)|0?2(?(.29)(?=.29.((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00))|(?!.3[01])))(?<sep>[-./])(?<day>0?[1-9]|[12]\d|3[01])\k<sep>(?<year>(1[6-9]|[2-9]\d)\d{2})(?(?=\x20\d)\x20|$))?(?<time>((0?[1-9]|1[012])(:[0-5]\d){0,2}(?i:\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$)

# This pattern captures <lastname><suffix>,<prefix><firstname><mname> Names must start with a capital letter. Last names may be hyphenated. First names can have two parts ie "Mary Anne" if there are more than two names after the comma. Suffixes can number up to XXX (30th). Standard prefixes are optional (Mr Miss)
# ID: 486
^(?n:(?<lastname>(St\.\ )?(?-i:[A-Z]\'?\w+?\-?)+)(?<suffix>\ (?i:([JS]R)|((X(X{1,2})?)?((I((I{1,2})|V|X)?)|(V(I{0,3})))?)))?,((?<prefix>Dr|Prof|M(r?|(is)?)s)\ )?(?<firstname>(?-i:[A-Z]\'?(\w+?|\.)\ ??){1,2})?(\ (?<mname>(?-i:[A-Z])(\'?\w+?|\.))){0,2})$

# This regex validates Currency. The base monetary unit (ex. US dollar) followed by option two digit cent denomination. Base unit can't have leading zero. Comma's are optional on base units. Note: Your regex engine must support the \p character class to use this. For example this will work in .net but not javascript which doesn't support \p Also the ¢ is removed from the match by force. Any other cent symbol would need to be added to the exclude to not match.
# ID: 606
# Multiline
^(?!\u00a2)\p{Sc}?(?!0,?\d)(\d{1,3}(\,\d{3})*|(\d+))(\.\d{2})?$

# The regex validate a quoted string in VBScript or Ansi SQL.  The string may contain the containing quote character if it is escaped by being doubled up.
# ID: 613
^(\x22|\x27)((?!\1).|\1{2})*\1$

# DateTime Validator. This RE validates both dates and/or times patterns. Days in Feb. are also validated for Leap years. Dates: in  dd/mm/yyyy or d/m/yy format between 1/1/1600 - 31/12/9999. Leading zeroes are optional. Date separators can be either matching dashes(-), slashes(/) or periods(.) Times: in the hh:MM:ss AM/PM 12 hour format (12:00 AM - 11:59:59 PM) or hh:MM:ss military time format (00:00:00 - 23:59:59). The 12 hour time format: 1) may have a leading zero for the hour. 2) Minutes and seconds are optional for the 12 hour format 3) AM or PM is required and case sensitive. Military time 1) must have a leading zero for all hours less than 10. 2) Minutes are manditory. 3) seconds are optional. Datetimes: combination of the above formats. A date first then a time separated by a space. ex) dd/mm/yyyy hh:MM:ss This RE is an variation of one of my other Datetime (mm/dd/yyyy) validator already in this library http://www.regexlib.com/REDetails.aspx?regexp_id=369, so the same rules for leap year apply. All 4 digit year and all two digit years except 00, which might not be a leap year.
# ID: 610
^(?=\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\x20|$))|(?:2[0-8]|1\d|0?[1-9]))([-./])(?:1[012]|0?[1-9])\1(?:1[6-9]|[2-9]\d)?\d\d(?:(?=\x20\d)\x20|$))?(((0?[1-9]|1[012])(:[0-5]\d){0,2}(\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$

# This regex can be used to split the values of a comma delimitted list. List elements may be quoted, unquoted or empty.  Commas inside a pair of  quotation marks are not matched.
# ID: 621
,(?!(?<=(?:^|,)\s*\x22(?:[^\x22]|\x22\x22|\\\x22)*,)(?:[^\x22]|\x22\x22|\\\x22)*\x22\s*(?:,|$))

# This regex can be used to find general entites in HTML, XML and SGML files.
# ID: 626
# Multiline
& (?ni:\#((x([\dA-F]){1,5})|(104857[0-5]|10485[0-6]\d|1048[0-4]\d\d|104[0-7]\d{3}|10[0-3]\d{4}|0?\d{1,6}))|([A-Za-z\d.]{2,31}));

# Datetime for Julian and Gregorian Calenders
# ID: 644
# Multiline
(?!(?:10(?<sep>[-./])(?:0?[5-9]|1[0-4])\k<sep>(?:1582))|(?:0?9(?<sep>[-./])(?:0?[3-9]|1[0-3])\k<sep>(?:1752)))(?n:^(?=\d)((?<month>(0?[13578])|1[02]|(0?[469]|11)(?!.31)|0?2(?(.29)(?=.29.(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\d\d)(?:[02468][048]|[13579][26])(?!\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\x20BC)))|(?!.3[01])))(?<sep>[-./])(?<day>0?[1-9]|[12]\d|3[01])\k<sep>(?!0000)(?<year>(?=(?:00(?:4[0-5]|[0-3]?\d)\x20BC)|(?:\d{4}(?:\z|(?:\x20\d))))\d{4}(?:\x20BC)?)(?(?=\x20\d)\x20|$))?(?<time>((0?[1-9]|1[012])(:[0-5]\d){0,2}(?i:\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$)

# Matches any character is the Basic Latin Unicode Range \U0000-U007F  (Ascii 0-127)
# ID: 679
\p{IsBasicLatin}

# Matches numbers.  Note: the second match (?) and the second non-match (IV) are not the same. I cover this in more detail here http://blogs.regexadvice.com/mash/archive/2004/04/17/988.aspx
# ID: 680
\p{N}

# Math Symbols.  NOTE: the second examples of match and non-match are not the same.  The non-match is the keyboard dash.  The match is the unicode minus sign.
# ID: 681
\p{Sm}

# This regex can be used to restrict passwords to a length of 8 to 20 aplhanumeric characters and select special characters. The password also can not start with a digit, underscore or special character and must contain at least one digit.
# ID: 580
^(?=[^\d_].*?\d)\w(\w|[!@#$%]){7,20}

# YYYY/MM/DD hh:mm:ss format DateTime Regex.
# ID: 581
^(?ni:(?=\d)((?'year'((1[6-9])|([2-9]\d))\d\d)(?'sep'[/.-])(?'month'0?[1-9]|1[012])\2(?'day'((?<!(\2((0?[2469])|11)\2))31)|(?<!\2(0?2)\2)(29|30)|((?<=((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00)\2\3\2)29)|((0?[1-9])|(1\d)|(2[0-8])))(?:(?=\x20\d)\x20|$))?((?<time>((0?[1-9]|1[012])(:[0-5]\d){0,2}(\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2}))?)$

# This regex validates a string of non-repeating characters A, B, C, D.
# ID: 564
(?i:([A-D])(?!\1)([A-D])(?!\1|\2)([A-D])(?!\1|\2|\3)([A-D]))

# This regex validates U.S. social security numbers, within the range of numbers that have been currently allocated.
# ID: 535
^(?!000)([0-6]\d{2}|7([0-6]\d|7[012]))([ -]?)(?!00)\d\d\3(?!0000)\d{4}$

# This RE will match all the valid elements in HTML 4.01
# ID: 523
(<\/?)(?i:(?<element>a(bbr|cronym|ddress|pplet|rea)?|b(ase(font)?|do|ig|lockquote|ody|r|utton)?|c(aption|enter|ite|(o(de|l(group)?)))|d(d|el|fn|i(r|v)|l|t)|em|f(ieldset|o(nt|rm)|rame(set)?)|h([1-6]|ead|r|tml)|i(frame|mg|n(put|s)|sindex)?|kbd|l(abel|egend|i(nk)?)|m(ap|e(nu|ta))|no(frames|script)|o(bject|l|pt(group|ion))|p(aram|re)?|q|s(amp|cript|elect|mall|pan|t(r(ike|ong)|yle)|u(b|p))|t(able|body|d|extarea|foot|h|itle|r|t)|u(l)?|var))(\s(?<attr>.+?))*>

# This regex will match all the valid on event attributes in HTML 4.01/XHTML 1.0
# ID: 524
(?i:on(blur|c(hange|lick)|dblclick|focus|keypress|(key|mouse)(down|up)|(un)?load|mouse(move|o(ut|ver))|reset|s(elect|ubmit)))

# Date-time with milliseconds. MM/dd/yyyy HH:mm:ss.fff Time is in military format and requires leading zeroes for single digit hours and seconds and two digit milliseconds. All fields are required. This was a special request modification of another regex.
# ID: 1097
(?n:^(?=\d)((?<month>(0?[13578])|1[02]|(0?[469]|11)(?!.31)|0?2(?(.29)(?=.29.((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00))|(?!.3[01])))(?<sep>[-./])(?<day>0?[1-9]|[12]\d|3[01])\k<sep>(?<year>(1[6-9]|[2-9]\d)\d{2})\x20)(?<time>(?<hours>[01]\d|2[0-3]):(?<minutes>[0-5]\d):(?<seconds>[0-5]\d)\.(?<milliseconds>\d{3}))$)

# Matches drives, folders and file on a Windows OS. Folder matches must end with \
# ID: 800
^((?:[a-zA-Z]:)|(?:\\{2}\w[-\w]*)\$?)\\(?!\.)((?:(?![\\/:*?<>"|])(?![.\x20](?:\\|$))[\x20-\x7E])+\\(?!\.))*((?:(?:(?![\\/:*?<>"|])(?![ .]$)[\x20-\x7E])+)\.((?:(?![\\/:*?<>"|])(?![ .]$)[\x20-\x7E]){2,15}))?$

# yyyy-mm-dd Datetime for AD, with leap year. See http://blogs.regexadvice.com/mash/archive/2004/04/23/1021.aspx for details on similar regexs
# ID: 760
(?!(?:1582\D10\D(?:0?[5-9]|1[0-4]))|(?:1752\D0?9\D(?:0?[3-9]|1[0-3])))(?n:^(?=\d)((?'year'\d{4})(?'sep'[-./])(?'month'0?[1-9]|1[012])\k'sep'(?'day'(?<!(?:0?[469]|11).)31|(?<!0?2.)30|2[0-8]|1\d|0?[1-9]|(?:(?<=(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:\d\d)(?:[02468][048]|[13579][26]))\k'sep'(?:0?2)\k'sep')|(?<!\k'sep'(?:0?2)\k'sep'))29)(?(?=\x20\d)\x20|$))?(?<time>((0?[1-9]|1[012])(:[0-5]\d){0,2}(?i:\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$)

# mm/dd/yyyy hh:MM:ss Datetime for all AD years, including leap years.
# ID: 761
(?=\d)^(?:(?!(?:10\D(?:0?[5-9]|1[0-4])\D(?:1582))|(?:0?9\D(?:0?[3-9]|1[0-3])\D(?:1752)))((?:0?[13578]|1[02])|(?:0?[469]|11)(?!\/31)(?!-31)(?!\.31)|(?:0?2(?=.?(?:(?:29.(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\d\d)(?:[02468][048]|[13579][26])(?!\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\x20BC))))))|(?:0?2(?=.(?:(?:\d\D)|(?:[01]\d)|(?:2[0-8])))))([-.\/])(0?[1-9]|[12]\d|3[01])\2(?!0000)((?=(?:00(?:4[0-5]|[0-3]?\d)\x20BC)|(?:\d{4}(?!\x20BC)))\d{4}(?:\x20BC)?)(?:$|(?=\x20\d)\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\d){0,2}(?:\x20[aApP][mM]))|(?:[01]\d|2[0-3])(?::[0-5]\d){1,2})?$

# dd/mm/yyyy hh:MM:ss Datetime for all AD years, including leap years.
# ID: 762
^(?=\d)(?:(?!(?:(?:0?[5-9]|1[0-4])(?:\.|-|\/)10(?:\.|-|\/)(?:1582))|(?:(?:0?[3-9]|1[0-3])(?:\.|-|\/)0?9(?:\.|-|\/)(?:1752)))(31(?!(?:\.|-|\/)(?:0?[2469]|11))|30(?!(?:\.|-|\/)0?2)|(?:29(?:(?!(?:\.|-|\/)0?2(?:\.|-|\/))|(?=\D0?2\D(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\d\d)(?:[02468][048]|[13579][26])(?!\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\x20BC))))))|2[0-8]|1\d|0?[1-9])([-.\/])(1[012]|(?:0?[1-9]))\2((?=(?:00(?:4[0-5]|[0-3]?\d)\x20BC)|(?:\d{4}(?:$|(?=\x20\d)\x20)))\d{4}(?:\x20BC)?)(?:$|(?=\x20\d)\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\d){0,2}(?:\x20[aApP][mM]))|(?:[01]\d|2[0-3])(?::[0-5]\d){1,2})?$

# yyyy/mm/dd hh:MM:ss Datetime for all AD years, including leap years.
# ID: 763
^(?=\d)(?:(?!(?:1582(?:\.|-|\/)10(?:\.|-|\/)(?:0?[5-9]|1[0-4]))|(?:1752(?:\.|-|\/)0?9(?:\.|-|\/)(?:0?[3-9]|1[0-3])))(?=(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:\d\d)(?:[02468][048]|[13579][26]))\D0?2\D29)|(?:\d{4}\D(?!(?:0?[2469]|11)\D31)(?!0?2(?:\.|-|\/)(?:29|30))))(\d{4})([-\/.])(0?\d|1[012])\2((?!00)[012]?\d|3[01])(?:$|(?=\x20\d)\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\d){0,2}(?:\x20[aApP][mM]))|(?:[01]\d|2[0-3])(?::[0-5]\d){1,2})?$

# Internationally capable currency formats.  It is NOT local aware.  Should be modify for local specific validations.
# ID: 747
# Multiline
^(?!\u00a2)\p{Sc}?(?!0,?\d)(?:\d{1,3}(?:([, .])\d{3})?(?:\1\d{3})*|(?:\d+))((?!\1)[,.]\d{2})?$

# Height notation for feet (') and inches(")
# ID: 727
^\d?\d'(\d|1[01])"$

# Temperature scale.  From ABSOLUTE ZERO  up.  Can use the Fahrenheit, Celsius or Kelvin Scale.  The Degree symbol is required for Fahrenheit and Celsius. Numbers over 1,000 must be comma delimited.
# ID: 728
# Multiline
^(?n:(?!-[\d\,]*K)      (?!-((\d{1,3},)*((([3-9]\d\d|2[89]\d|27[4-9])\xB0C)|(((4[6-9]|[5-9]\d)\d)\xB0F))))  -?\d{1,3}(,\d{3})*(\xB0[CF]|K) )$

# Matches each card in the deck of standard playing cards, not including the Jokers
# ID: 730
([2-9JQKA]|10)([\u2660\u2663\u2665\u2666])

# This pattern matches lower-case letters
# ID: 706
(?-i:\b\p{Ll}+\b)

# Matches uppercase unicode alpha characters
# ID: 707
(?-i:\b\p{Lu}+\b)

# Matches standard scientific notation using E character
# ID: 857
\b-?[1-9](?:\.\d+)?[Ee][-+]?\d+\b

# Unicode Plane 0 character excluding standard ASCII
# ID: 917
(?![\uD800-\uDBFF])(?![\uDC00-\uDFFF])[\u0080-\uFFFF]

# Non-Plane 0 Unicode character
# ID: 918
[\uD800-\uDBFF][\uDC00-\uDFFF]

# Trim Inside.  This pattern can be used with a replace value of "$1 " to remove multiple consecutive spaces between characters and replace with a single space. Trailing and leading spaces are NOT altered.
# ID: 960
(\S+)\x20{2,}(?=\S+)

# Word Break.  This regex can be used to break a long line of text on a full word. The qualifiers specify the minimum and maximum number of character allow before the break and can be changed according to your need. Blogge about this here http://regexadvice.com/blogs/mash/archive/2005/02/09/324.aspx
# ID: 961
^(?:[ -~]{10,25}(?:$|(?:[\w!?.])\s))

# This is the date validator for dates of the format DD-MMM-YYY
# ID: 1848
^((31(?!(\-)((F|f)(E|e)(B|b)|(A|a)(P|p)(R|r)|(J|j)(U|u)(N|n)|(S|s)(E|e)(P|p)|(N|n)(O|o)(V|v))))|((30|29)(?!(\-)((F|f)(E|e)(B|b))))|(29(?=(\-)(F|f)(E|e)(B|b)(\-)(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8])(\-)((J|j)(A|a)(N|n)|(F|f)(E|e)(B|b)|(M|m)(A|a)(R|r)|((M|m)(A|a)(Y|y))|(A|a)(P|p)(R|r)|(J|j)(U|u)(L|l)|(J|j)(U|u)(N|n)|(A|a)(U|u)(G|g)|(O|o)(C|c)(T|t)|(S|s)(E|e)(P|p)|(N|n)(O|o)(V|v)|(D|d)(E|e)(C|c))(\-)((1[6-9]|[2-9]\d)\d{2})$

# Test on current types of Dutch license plates
# ID: 2076
^([A-Z]{2}-[A-Z]{2}-[0-9]{2}$|^([A-Z]{2}-[0-9]{2}-[A-Z]{2}$|^([0-9]{2}-[A-Z]{2}-[A-Z]{2}$|^([A-Z]{2}-[0-9]{2}-[0-9]{2}$/

# This regexp matches all existing TLDs (Top-Level Domains) according to IANA specifications as of 14/07/2007.
# ID: 1066
(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])

# This regexp matches string which represents a fraction.
# ID: 1234
(?:-(?!0))?\d+(?:(?: \d+)?/\d+)?

# Simple validation reg ex that requires 1-15 alphanumeric characters
# ID: 2855
^([a-zA-Z0-9]{1,15})$

# UK Vehicle Registration Plate / Number Plate format as specified by the DVLA. Accepts both "Prefix" and "New" style. Allows only valid DVLA number combinations as not all are supported. Registration number must be exactly as is displayed on car, hence all letters must be in uppercase and a space seperating the two sets of characters.
# ID: 1981
([A-HJ-PR-Y]{2}([0][1-9]|[1-9][0-9])|[A-HJ-PR-Y]{1}([1-9]|[1-2][0-9]|30|31|33|40|44|55|50|60|66|70|77|80|88|90|99|111|121|123|222|321|333|444|555|666|777|888|999|100|200|300|400|500|600|700|800|900))[ ][A-HJ-PR-Z]{3}$

# SQL datetime format tester YYYY-MM-DD HH:MM:SS
# ID: 1824
^([0-9]{4})-([0-1][0-9])-([0-3][0-9])\s([0-1][0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$

# Bobby's Burger Barn
# ID: 780
^[a-zA-Z0-9\x20'\.]{8,64}[^\s]$

# Matches South African telephone/mobile numbers, with or without the country code. Can also include spaces or hyphens between values. Doesn't match brackets around the area code, but that would be easy to add in. Hope it helps someone...
# ID: 2956
^((?:\+27|27)|0)(\d{2})-?(\d{3})-?(\d{4})$

# This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.
# ID: 9
^\d{3}-\d{2}-\d{4}$

# Matches UK postcodes of the below formats. The space is optional.
# ID: 954
^(([A-Z]{1,2}[0-9]{1,2})|([A-Z]{1,2}[0-9][A-Z]))\s?([0-9][A-Z]{2})$

# Validate: First five characters are letters; characters six-17 are letters, numbers, or hyphen; string length is eight characters minimum, 17 characters maximum
# ID: 2305
^([a-zA-Z]{5})([a-zA-Z0-9-]{3,12})

# Validates a Philippine mobile phone number without International code.
# ID: 3059
^09(73|74|05|06|15|16|17|26|27|35|36|37|79|38|07|08|09|10|12|18|19|20|21|28|29|30|38|39|89|99|22|23|32|33)\d{3}\s?\d{4}

# Registro Federal de Contribuyentes (RFC) , used in Mexico as a unique set of characters for a person or corporation registration . Registro Federal de Contribuyentes utilizado en Mexico para el registro en hacienda
# ID: 2703
^([A-Z|a-z|&]{3})(([0-9]{2})([0][13456789]|[1][012])([0][1-9]|[12][\d]|[3][0])|([0-9]{2})([0][13578]|[1][02])([0][1-9]|[12][\d]|[3][01])|([02468][048]|[13579][26])([0][2])([0][1-9]|[12][\d])|([1-9]{2})([0][2])([0][1-9]|[12][0-8]))(\w{2}[A|a|0-9]{1})$|^([A-Z|a-z]{4})(([0-9]{2})([0][13456789]|[1][012])([0][1-9]|[12][\d]|[3][0])|([0-9]{2})([0][13578]|[1][02])([0][1-9]|[12][\d]|[3][01])|([02468][048]|[13579][26])([0][2])([0][1-9]|[12][\d])|([1-9]{2})([0][2])([0][1-9]|[12][0-8]))((\w{2})([A|a|0-9]{1})){0,3}$

# Verifies all valid Gregorian dates of the form DD MONTH YYYY, and short month names, taking days/month and leap years into account. Accepts space, -, . and / between paramters.
# ID: 3506
^(0[1-9]|[12][0-9]|3[01])[\s\.\-/](J(anuary|uly|an|AN)|M(arch|ar|AR|ay|AY)|A(ugust|ug|UG)|(O(ctober|ct|CT)|(D(ecember|ec|EC))))[\s\.\-/][1-9][0-9]{3}|(0[1-9]|[12][0-9]|30)[\s\.\-/](A(pril|pr|PR)|J(une|un|UN)|S(eptember|ep|EP)|N(ovember|ov|OV))[\s\.\-/][1-9][0-9]{3}|(0[1-9]|1[0-9]|2[0-8])[\s\.\-/]F(ebruary|eb|EB)[\s\.\-/][1-9][0-9]{3}|29[\s\.\-/]F(ebruary|eb|EB)[\s\.\-/]((0[48]|[2468][048]|[13579][26])00|[0-9]{2}(0[48]|[2468][048]|[13579][26]))$

# Match all empty (that has no text) tags excluding some (TD, TR). The excluded tags list can be changed by adding / removing tags. See: (?!\btd|tr\b)
# ID: 2038
(<(?!\btd|tr\b)(\w*)[^>/]*>)(\s*)(</\2>)

# Retrieve all HTML tags and its content
# ID: 2039
(<\b(\w*)\b[^>/]*>)(?<content>.*?)(</\2>)

# MM/dd/yyyy with 100% leap years. Valid since year 1900.
# ID: 1071
^(((0?[1-9]|1[012])/(0?[1-9]|1\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\d)\d{2}|0?2/29/((19|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$

# MM/dd/yyyy with 100% leap year validation starting from year 2000.
# ID: 1038
^(((0[1-9]|1[012])/(0[1-9]|1\d|2[0-8])|(0[13456789]|1[012])/(29|30)|(0[13578]|1[02])/31)/[2-9]\d{3}|02/29/(([2-9]\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$

# dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999.
# ID: 1019
^(((0[1-9]|[12]\d|3[01])\/(0[13578]|1[02])\/((19|[2-9]\d)\d{2}))|((0[1-9]|[12]\d|30)\/(0[13456789]|1[012])\/((19|[2-9]\d)\d{2}))|((0[1-9]|1\d|2[0-8])\/02\/((19|[2-9]\d)\d{2}))|(29\/02\/((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$

# yyyyMMdd with leap year validation, starting from year 2000 only.
# ID: 1032
^([2-9]\d{3}((0[1-9]|1[012])(0[1-9]|1\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$

# yyMMdd with leap years.
# ID: 1033
^(\d{2}((0[1-9]|1[012])(0[1-9]|1\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)$

# HHmmss without any separators. Hours in 24h format.
# ID: 1034
^([01]\d|2[0123])([0-5]\d){2}$

# Date with leap years. Accepts '.' '-' and '/' as separators
# ID: 320
^((((0?[1-9]|[12]\d|3[01])[\.\-\/](0?[13578]|1[02])[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|((0?[1-9]|[12]\d|30)[\.\-\/](0?[13456789]|1[012])[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|((0?[1-9]|1\d|2[0-8])[\.\-\/]0?2[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|(29[\.\-\/]0?2[\.\-\/]((1[6-9]|[2-9]\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))|(((0[1-9]|[12]\d|3[01])(0[13578]|1[02])((1[6-9]|[2-9]\d)?\d{2}))|((0[1-9]|[12]\d|30)(0[13456789]|1[012])((1[6-9]|[2-9]\d)?\d{2}))|((0[1-9]|1\d|2[0-8])02((1[6-9]|[2-9]\d)?\d{2}))|(2902((1[6-9]|[2-9]\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00))))$

# Date expression validator with format YYMMDD
# ID: 326
^((\d{2}((0[13578]|1[02])(0[1-9]|[12]\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\d|30)|02(0[1-9]|1\d|2[0-8])))|([02468][048]|[13579][26])0229)$

# DD.MM.YY or DD.MM.YYYY
# ID: 665
^(((0?[1-9]|[12]\d|3[01])[\.\-\/](0?[13578]|1[02])[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|((0?[1-9]|[12]\d|30)[\.\-\/](0?[13456789]|1[012])[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|((0?[1-9]|1\d|2[0-8])[\.\-\/]0?2[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|(29[\.\-\/]0?2[\.\-\/]((1[6-9]|[2-9]\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))$

# This regexp has been posted specialy for "Mike O Shea" as he requested a mono digit year validation.
# ID: 666
^(((0?[1-9]|[12]\d|3[01])[\.\-\/](0?[13578]|1[02])[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}|\d))|((0?[1-9]|[12]\d|30)[\.\-\/](0?[13456789]|1[012])[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}|\d))|((0?[1-9]|1\d|2[0-8])[\.\-\/]0?2[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}|\d))|(29[\.\-\/]0?2[\.\-\/]((1[6-9]|[2-9]\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00|[048])))$

# Matching : dd/MM/yy
# ID: 488
^(((0[1-9]|[12]\d|3[01])\/(0[13578]|1[02])\/(\d{2}))|((0[1-9]|[12]\d|30)\/(0[13456789]|1[012])\/(\d{2}))|((0[1-9]|1\d|2[0-8])\/02\/(\d{2}))|(29\/02\/((0[48]|[2468][048]|[13579][26])|(00))))$

# dd/MM/yyyy with leap years 100% integrated
# ID: 409
^(((0[1-9]|[12]\d|3[01])\/(0[13578]|1[02])\/((1[6-9]|[2-9]\d)\d{2}))|((0[1-9]|[12]\d|30)\/(0[13456789]|1[012])\/((1[6-9]|[2-9]\d)\d{2}))|((0[1-9]|1\d|2[0-8])\/02\/((1[6-9]|[2-9]\d)\d{2}))|(29\/02\/((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$

# Matches strings that only contain Arabic letters (no spaces). if you want to include spaces it should be ^[\u0621-\u064A\040]+$
# ID: 1759
^[\u0621-\u064A]+$

# This regular expression using named groups returns semantic tokens and is designed for Australian addresses in one line. Any part of an address may be omitted, as long as parts are in minor to major order. It should not be difficult to modify the regular express for analysing multi-line addresses. With a little modification, this regex may work for other postal address formats in minor to major order. The syntax is based on dot Net regular expression, with "options = RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.IgnorePatternWhitespace". The order is
# ID: 1964
((?<strPOBox>((POBox|PO\sBox)\s*\d*)),?\s?)?(((?<strUnit>([\w\d\s\,]*)),\s?)?( (?<strStreet>([\w\s\-]*\w\s(st\s)?[\w]*\s(street|st|road|rd|close|cl|avenue|ave|av|path|ph|drive|drv|LOOP|COURT|CT|CIRCLE|LANE|LN))  ),?\s?))?((?<strTown>([\p{Ll}\p{Lu}\p{Lo}\p{Pc}\p{Lt}\p{Lm}\s]*)),?\s?)?((?<strState>(Victoria|VIC|New South Wales|NSW|South Australia|SA|Northern Territory|NT|West Australia|WA|Tasmania|TAS|ACT|Queensland|QLD))\s*)?(?<strPostalCode>(\d{4}),?\s?)?(?<strCountry>(Australia))?

# .NET 3.5 Tested. Used to extract the YouTubeID from a fully qualified YouTube URL.
# ID: 3333
(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\.[Cc][Oo][Mm]/watch\?v=)([\w-]{11})

# Mach with constant string in SQL style.
# ID: 1528
'('{2})*([^'\r\n]*)('{2})*([^'\r\n]*)('{2})*'

# Matches New Zealand local, mobile and freecall (0800) phone numbers.
# ID: 1600
(^\([0]\d{1}\))(\d{7}$)|(^\([0][2]\d{1}\))(\d{6,8}$)|([0][8][0][0])([\s])(\d{5,8}$)

# CEP do Brasil com separação ex: 99999-999
# ID: 1450
^\d{5}(\-)(\d{3})?$

# A range of numbers 0-35 optionally including a percent sign and 2 position decimal.
# ID: 1612
^[0-9]%?$|^1[0-9]%?$|^2[0-9]%?$|^3[0-5]%?$|^[0-9]\.\d{1,2}%?$|^1[0-9]\.\d{1,2}%?$|^2[0-9]\.\d{1,2}%?$|^3[0-4]\.\d{1,2}%?$|^35%?$

# This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999.
# ID: 2749
^(([0]?[1-9])|(1[0-2]))\/(([0]?[1-9])|([1,2]\d{1})|([3][0,1]))\/[12]\d{3}$

# This Regular Expression Chack Matching Persian Mobile Numbers
# ID: 2371
(^(09|9)[1][1-9]\\d{7}$)|(^(09|9)[3][12456]\\d{7}$)

# This Regex Will Remove All Html Tags And Return Simple Plain Text .
# ID: 2372
<[^>]*>

# This Regex chceck an input string for persian unicode character
# ID: 2373
[\u0600-\u06FF]

# Expression validating a Binary string of any length
# ID: 975
^([0-1])*$

# Expression validating a octal string of any length.
# ID: 976
^([0-7])*$

# Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products.
# ID: 978
^([0-9a-fA-F]){8}$

# Expression validating a hex string of any length.
# ID: 886
^([0-9a-fA-F])*$

# This is a regex for Brazilian Reais, that can be transformed to another currencies. The main modification is the exchange of . and , plus the addition of the R matching R$.
# ID: 915
^(\$|R\$|\-\$|\-R\$|\$\-|R\$\-|-)?([0-9]{1}[0-9]{0,2}(\.[0-9]{3})*(\,[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\,[0-9]{0,2})?|0(\,[0-9]{0,2})?|(\,[0-9]{1,2})?)$

# Validates rfc2822 for the mostpart
# ID: 2452
^[a-z0-9,!#\$%&'\*\+/=\?\^_`\{\|}~-]+(\.[a-z0-9,!#\$%&'\*\+/=\?\^_`\{\|}~-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*\.([a-z]{2,})$

# Remi provided an example that would match all domain names (http://www.regexlib.com/REDetails.aspx?regexp_id=391).  I'm adding it so that it can be tested.
# ID: 1316
^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?$

# Esta expressão permite a entrada de nomes compostos com quaisquer letras (incluindo acentos), espaços, alguns símbolos gráfcos, com comprimento entre 1 e 40 posições, mas bloqueia números.
# ID: 3426
^([a-zA-ZáéíóúàèìòùãõâêîôûüïçÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÃÕÜÏÇ£¢$#,.ºª°\s/-[0-9]]){1,40}$

# Regular exp to match the VTU USN
# ID: 3646
^\d[a-zA-Z]\w{1}\d{2}[a-zA-Z]\w{1}\d{3}$

# Matches a string starting with numeric digit
# ID: 3647
^\d[a-zA-Z0-9]+$

# This is the expression to validate the personal key for tax payers in Mexico (called RFC) as individuals (not for enterprises).
# ID: 2185
Validation of Mexican RFC for tax payers (individuals)

# A short and sweet email address validator. Checks that the username starts and ends with an alphanumeric character, allows a few non-repeating 'special characters' (namely -, ., _, +, &) and checks for a sensible domain name (2-6 character TLD required). Some unconventional, yet technically valid, addresses will not be matched, but this is only a simple expression ;-)
# ID: 1012
^([0-9a-zA-Z]+[-._+&])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$

# Simple URL Validator -- allows http, https, ftp, ftps, 2-6 letter TLD, ports, any path. Sorry, no IP addresses. Not too fussy, but then, it's not too long either ;-)
# ID: 806
^((ht|f)tp(s?))\://([0-9a-zA-Z\-]+\.)+[a-zA-Z]{2,6}(\:[0-9]+)?(/\S*)?$

# Validate UAE Mobile Numbers
# ID: 3543
^(\+971[\s]{0,1}[\-]{0,1}[\s]{0,1}|[\s]{0,1}0)(5[056]{1})[\s]{0,1}[\-]{0,1}[\s]{0,1}[1-9]{1}[0-9]{6}$

# UK Phone Number Allows leading and trailing spaces and optional spaces after the dialing code.
# ID: 297
(\s*\(?0\d{4}\)?\s*\d{6}\s*)|(\s*\(?0\d{3}\)?\s*\d{3}\s*\d{4}\s*)

# Easy way to transform header tag to its local referer. I use it to make TOC after reading headers.<br><b> <h# id="identifier">Caption</h#> -> #~<a href="#identifier">Caption</a> </b><br>There is stored original heading's level in output.
# ID: 1432
"{(<h)([1-6])(.id=\")(.+?\")(.+?)(</h[1-6])}",'\\2~<a href="#\\4\\5</a'

# Allows either inclusion of $ symbol or not. Allows a whitespace character after the $ sysmbol or not. Allows a negative symbol in front of the starting digit or not. Allows comma separators at thousands, but nowhere else. Allows more than two decimal places.
# ID: 803
^(\$)?(\s)?(\-)?((\d+)|(\d{1,3})(\,\d{3})*)(\.\d{2,})?$

# U.S. Individual Taxpayer Identification Number (ITIN) as defined in December 2006. The valid range is 900-70-0000 through 999-88-9999, all numeric values. This regular expression will accept anything in this range with space, dash or no separators.
# ID: 1919
^(9\d{2})([ \-]?)([7]\d|8[0-8])([ \-]?)(\d{4})$

# Matches /* style comments */.
# ID: 1108
/\*((?!\*/)[\d\D\s])*\*/

# Matches full windows paths and UNC paths (allowing spaces in quoted text).
# ID: 3401
("(([a-zA-Z]:)|(\\\\[^/\\:\*\?""<>\|]+(\\[a-zA-Z]\$)?))\\([^/\\:\*\?""<>\|]+\\)*[^/\\:\*\?""<>\|]+(\.[^/\\:\*\?""<>\|]+[^/\\:\*\?""<>\|\s])?")|((([a-zA-Z]:)|(\\\\[^/\\:\*\?""<>\|\s]+(\\[a-zA-Z]\$)?))\\([^/\\:\*\?""<>\|\s]+\\)*[^/\\:\*\?""<>\|\s]+(\.[a-zA-Z0-9]+)?)

# Regular expression to evaluate dutch-style phone numbers. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031
# ID: 75
(^\+[0-9]{2}|^\+[0-9]{2}\(0\)|^\(\+[0-9]{2}\)\(0\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\-\s]{10}$)

# Regular expression to evaluate dutch zipcodes. This is an updated version of Roland Mensenkamp.
# ID: 76
^[0-9]{4}\s{0,1}[a-zA-Z]{2}$

# This is a cleanup of Vijay Joshi's "Email" pattern.  It matches the same characters that his does, but matches them anywhere in the line.  It adds useful substitution groups -- [1] - username portion of email (before @), [3] domain portion of email - after the @.  It also was a bit overly-complex, so I reduced this as well..  Remember -- if you're planning to use this with something that uses 1003.2 BREs, you'll have to backquote + | ? ( ) { and }.
# ID: 1861
([^_.]([a-zA-Z0-9_]*[.]?[a-zA-Z0-9_]+[^_]){2})@([a-z0-9]+[.]([a-z]{2,3}|[a-z]{2,3}[.][a-z]{2,3}))

# Validate date in mysql regexp.
# ID: 3559
^\[0-9]{4}\-\[0-9]{2}\-\[0-9]{2}$

# This RE validates standard Bible verse notation.
# ID: 225
(?:\d|I{1,3})?\s?\w{2,}\.?\s*\d{1,}\:\d{1,}-?,?\d{0,2}(?:,\d{0,2}){0,2}

# This regex matches US phone number formats that I found to be commonly used.
# ID: 2379
(?:\+?1[ .*-]?)?(?:\(? ?)?\d{3}(?: ?\)?)? ?(?:\*|(?:\.|-){1,2})? ?\d{3} ?(?:\*|(?:\.|-){1,2})? ?\d{4}

# Matches decimals and integer in efficient way with minimal grouping allowing you to get the match as a whole decimal/integar
# ID: 3140
(-?(\d*\.\d{1}?\d*|\d{1,}))

# ONLY PURE string and numric only
# ID: 548
[0-9A-Za-z]

# To detect non-alphanumeric characters (for new username/password validation, for instance):
# ID: 549
[^A-Za-z0-9]

# PHP/Perl based regular expression: find aplhanumeric only(alpha and numeric only) (string and numeric only)
# ID: 550
[a-z0-9]{1,11}

# Match italian telephone number with prefix followed by "/", "-" or blank and number. Usefull with numeric keybord!
# ID: 432
^([0-9]*\-?\ ?\/?[0-9]*)$

# This pattern match italian fiscal code (codice fiscale).
# ID: 473
^[A-Za-z]{6}[0-9]{2}[A-Za-z]{1}[0-9]{2}[A-Za-z]{1}[0-9]{3}[A-Za-z]{1}$

# v allow Symbol [(_) (-) (DOT)] (number) (a-z and caps), X disallow symbol&number at begining (avoid bad sorting database, including bad subdomain name (1.example.com) & fake email) and ending (before "@") & other symbols are disallowed;
# ID: 3340
(^([A-Za-z])([-_.\dA-Za-z]{1,10})([\dA-Za-z]{1}))(@)(([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})|(([\dA-Za-z{1}][-_.\dA-Za-z]{1,25})\.([A-Za-z]{2,4}))$)

# Matches a whole number between 1 and 20 inclusively
# ID: 363
^1?[1-9]$|^[1-2]0$

# Matches integers (no decimal points), that may have an option +/- at the front, and may be grouped by comma every three digits.
# ID: 2445
^[+-]?(?(\d{1,3},)(\d{1,3}(,\d{3})+)|\d+)$

# Chemical elements of the periodic table from 1 to 118.
# ID: 1373
^((?-i)A[cglmrstu]|B[aehikr]?|C[adeflmorsu]?|D[bsy]|E[rsu]|F[emf]?|G[ade]|H[efgos]?|I[nk]?|Kr?|L[airu]|M[dgnot]|N[abdeiop]|Os?|P[abdmortu]?|R[abefghnu]|S[bcegimnr]?|T[abcehil]|U(u[bhopqst])?|V|W|Xe|Yb?|Z[nr])$

# This pattern can be used to validate URLs starting with ftp, http or https
# ID: 2139
^(ftp|https?):\/\/([^:]+:[^@]*@)?([a-zA-Z0-9][-_a-zA-Z0-9]*\.)*([a-zA-Z0-9][-_a-zA-Z0-9]*){1}(:[0-9]+)?\/?(((\/|\[|\]|-|~|_|\.|:|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*)\?((\/|\[|\]|-|~|_|\.|,|:|=||\{|\}|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*\&?)*)?(#([-_.a-zA-Z0-9]|%[a-fA-F0-9]{2})*)?$

# Checks if an email address is valid.
# ID: 2977
^([+a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,6}|[0-9]{1,3})(\]?)$

# Validates datetimes in an internationally resilient form that is still readable by the average person.
# ID: 1518
(?i)^((((0[1-9])|([12][0-9])|(3[01])) ((JAN)|(MAR)|(MAY)|(JUL)|(AUG)|(OCT)|(DEC)))|((((0[1-9])|([12][0-9])|(30)) ((APR)|(JUN)|(SEP)|(NOV)))|(((0[1-9])|([12][0-9])) FEB))) \d\d\d\d ((([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9])$

# looks for line concantenation character "_" in vb/vb.net source files.
# ID: 934
(?mi:(?<=^(([^'"\n])|("[^"]*"))*[\t ])_(?=\s*$))

# *CORRECTED: Again thanks for all the comments below. If you want to include internal domain as well change the partial code (\.[\w-_]+)+ to (\.[\w-_]+)?
# ID: 96
(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?

# this is reg expression for 0.00 to 25.00
# ID: 1970
^(([0-9]|1[0-9]|2[0-4])(\.[0-9][0-9]?)?)$|([2][5](\.[0][0]?)?)$

# Matches quoted strings. Do not use anchors or it will not work as expected
# ID: 2017
(?<!\\)\"(?:[^\"]*(?<!\\)\\\")*[^\"]*\"

# Matches URI's!
# ID: 2237
^(?:(?<scheme>[a-z]+):\/\/)?(?:(?<usern>[a-z0-9_.]*)(?::(?<passw>[a-z0-9_.]*))?@)?(?<domain>(?:(?:[a-z][a-z0-9_-]+\.?)+|[0-9]{1,3}(?:\.[0-9]{1,3}){3}))(?::(?<port>[0-9]+))?(?<path>(?:\/[.%a-z0-9_]*)+)?(?:\?(?<query>(?:&?[][a-z0-9_]+(?:\=?[a-z0-9_;]*)?)+))?(?:#(?<fragment>[a-z0-9_]+))?$

# US telephone check
# ID: 784
^\([0-9]{3}\)\s?[0-9]{3}(-|\s)?[0-9]{4}$|^[0-9]{3}-?[0-9]{3}-?[0-9]{4}$

# By using this we can upload only images files. This is the simplest and its execution is fast.
# ID: 2687
^.*([^\.][\.](([gG][iI][fF])|([Jj][pP][Gg])|([Jj][pP][Ee][Gg])|([Bb][mM][pP])|([Pp][nN][Gg])))

# This is only +ive numbers excluding 0. It takes 1 to 9999.
# ID: 2930
^[1-9]{1}$|^[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}$|^9999$

# It is use for 0 to 29.
# ID: 2916
^(([0-2])?([0-9]))$

# By using this you can validate your date string in (dd-MMM-yyyy) format.
# ID: 3125
^\d{2}\-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\-\d{4}$

# Test a date in the format of YYYYMMDD. and returns a match with the grouped date parts. The groups are:
# ID: 1614
# Multiline
(?<DATE>(?:(?:(?<year1>(?:1[89])|(?:[2468][048]|[3579][26])(?!00))(?<year2>00|[02468][1235679]|[13579][01345789])(?:(?:(?<month>(?:[0][13578])|(?:1[02]))(?<day>0[1-9]|[12][0-9]|3[01]))|(?:(?<month>0[469]|11)(?<day>0[1-9]|[12][0-9]|30))|(?:(?<month>02)(?<day>0[1-9]|1[0-9]|2[0-8])))|(?:(?:(?<year1>(?:[2468][048]|[3579][26])00)|(?<year1>(?:(?:1[89])|[2468][048]|[3579][26])(?!00))(?<year2>[02468][048]|[13579][26]))(?:(?:(?<month>(?:(?:[0][13578])|(?:1[02])))(?<day>0[1-9]|[12][0-9]|3[01]))|(?:(?<month>0[469]|11)(?<day>(?:0[1-9]|[12][0-9]|30)))|(?:(?<month>02)(?<day>0[1-9]|[12][0-9])))))))

# Formatted Number with "," as thousand separator and "." as decimal separator. now accept numbers without separators of thousands.
# ID: 1039
^\-?[0-9]{1,3}(\,[0-9]{3})*(\.[0-9]+)?$|^[0-9]+(\.[0-9]+)?$

# Expression to handle US currency entry in .NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.
# ID: 276
^\$?(\d{1,3},?(\d{3},?)*\d{3}(\.\d{1,3})?|\d{1,3}(\.\d{2})?)$

# An expression for .NET regular expression validation controls intended to faciliate the entry of percentage values both a whole numbers or as their decimal representations. Also compatible with the default US format for string formatting for percentages.
# ID: 277
^\d{0,2}(\.\d{1,4})? *%?$

# If you need a textbox to allow only positive numbers with two decimal places, try this. I wanted the user to be able to enter any type of currency amount (US of course) but also have two decimal places for database field.
# ID: 1101
(^\d*\.\d{2}$)

# This pattern matches the windows console (cmd) prompt (also know as command prompt)
# ID: 869
^[a-zA-Z]:(\\|(\\[^\\/\s:*"<>|]+)+)>

# Modified version- to capture the PO BOX based on user input on the website - It will not include any Rural Route
# ID: 2347
[p|P][\s]*[o|O][\s]*[b|B][\s]*[o|O][\s]*[x|X][\s]*[a-zA-Z0-9]*|\b[P|p]+(OST|ost|o|O)?\.?\s*[O|o|0]+(ffice|FFICE)?\.?\s*[B|b][O|o|0]?[X|x]+\.?\s+[#]?(\d+)*(\D+)*\b

# Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.
# ID: 3249
(((^[>]?1.0)(\d)?(\d)?)|(^[<]?1.0(([1-9])|(\d[1-9])|([1-9]\d)))|(^[<]?1.4(0)?(0)?)|(^[<>]?1.(([123])(\d)?(\d)?)))$

# This provides an expression to calidate the four major credit cards.  It can be easily broken up to use for a specific type of card.  It does not validate the number being a potential real number, only in the correct format.
# ID: 67
(^(4|5)\d{3}-?\d{4}-?\d{4}-?\d{4}|(4|5)\d{15})|(^(6011)-?\d{4}-?\d{4}-?\d{4}|(6011)-?\d{12})|(^((3\d{3}))-\d{6}-\d{5}|^((3\d{14})))

# Validates a userID to be between 4 and 8 characters - no whitespace or asterisks and at least one alpha.
# ID: 2871
^(?=.*[a-zA-Z])[^\*\s]{4,8}$

# Validates an RFC 2822 email address, except does not allow most punctuation and non-ascii alphanumeric characters. Also does not take length requirements into account. Allows domain name and IP addresses, but ensures that the IP address entered is valid.
# ID: 1414
^(?:"[^\"]*"|[a-z0-9&+_-](?:\.?[a-z0-9&+_-]+)*)@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])*(?:\.[a-z0-9](?:[a-z0-9-]*[a-z0-9])*)*|(\[)?(?:[01]?\d?\d|2[0-4]\d|25[0-5])(?:\.(?:[01]?\d?\d|2[0-4]\d|25[0-5])){3}(?(1)\]|))$

# This will match fields in a row of a csv file.  Values can be double quoted or not.  If a value is double quoted it can have commas inside it.  Each value will be captured to word.
# ID: 2067
(\"(?<word>[^\"]+|\"\")*\"|(?<word>[^,]*))

# This should be pretty complete phone number pattern. I use [0-9] when most people seem to use \d because it is easier for me to read.
# ID: 1837
^(\{1}[2-9]{1}[0-9]{2}\){1}[ ]?[2-9]{1}[0-9]{2}(-| )?[0-9]{4}|[2-9]{1}[0-9]{2}[ ]{1}[2-9]{1}[0-9]{2}[ ]{1}[0-9]{4}|[2-9]{1}[0-9]{2}[2-9]{1}[0-9]{6}|[2-9]{1}[0-9]{2}-{1}[2-9]{1}[0-9]{2}-{1}[0-9]{4}){1}$

# This will allow to check to make sure the string is a First or Given Name and it can be initials and it can include a prefix.
# ID: 1838
^((Sir|Dr.|Mr.|Mrs.|Ms.|Rev.){1}[ ]?)?([A-Z]{1}[.]{1}([A-Z]{1}[.]{1})?|[A-Z]{1}[a-z]{1,}|[A-Z]{1}[a-z]{1,}[-]{1}[A-Z]{1}[a-z]{1,}|[A-Z]{1}[a-z]{0,}[ ]{1}[A-Z]{1}[a-z]{0,}){1}$

# Can anyone help me with this problem?  I want X to give me the correct index of >.  For example if this is my code:
# ID: 435
<(.*?)>

# This regular expression matches 'Switch' card numbers - a payment method used extensively in the UK.
# ID: 68
^([0-9]{6}[\s\-]{1}[0-9]{12}|[0-9]{18})$

# Matches properly formatted US phone numbers. Based on: http://regexlib.com/REDetails.aspx?regexp_id=22
# ID: 3492
^[1-9]\d{2}\s*-\s*\d{3}\s*-\s*\d{4}$|^[2-9]\d{9}|^\x28\s*[2-9]\d{2}\s*\x29\s*\d{3}\s*-\s*\d{4}$

# Matches valid UK post codes in both upper and lower case, allowing for one or zero spaces between outcode and incodes.
# ID: 2113
^ ?(([BEGLMNSWbeglmnsw][0-9][0-9]?)|(([A-PR-UWYZa-pr-uwyz][A-HK-Ya-hk-y][0-9][0-9]?)|(([ENWenw][0-9][A-HJKSTUWa-hjkstuw])|([ENWenw][A-HK-Ya-hk-y][0-9][ABEHMNPRVWXYabehmnprvwxy])))) ?[0-9][ABD-HJLNP-UW-Zabd-hjlnp-uw-z]{2}$

# Single- or multi-digit signed Integer.
# ID: 2683
^[+-]?[0-9]+$

# Matches any integer or decimal number with either dot (.) or comma (,) as decimal- and thousands-separator. Also accepts Scientific notation.
# ID: 2684
^[+-]?\d*(([,.]\d{3})+)?([,.]\d+)?([eE][+-]?\d+)?$

# This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255.
# ID: 2685
^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$

# Matches any valid 3 or 6 digit hexadecimal colour value.
# ID: 2689
^#?(([a-fA-F0-9]{3}){1,2})$

# This matches all valid forms of an IPv6 address. Including the compatibility form used to map IPv4 addresses. As well as the base-85 encoded integer form.
# ID: 2690
(^\d{20}$)|(^((:[a-fA-F0-9]{1,4}){6}|::)ffff:(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$)|(^((:[a-fA-F0-9]{1,4}){6}|::)ffff(:[a-fA-F0-9]{1,4}){2}$)|(^([a-fA-F0-9]{1,4}) (:[a-fA-F0-9]{1,4}){7}$)|(^:(:[a-fA-F0-9]{1,4}(::)?){1,6}$)|(^((::)?[a-fA-F0-9]{1,4}:){1,6}:$)|(^::$)

# Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not.
# ID: 736
^(\(?[0-9]{3}[\)-\.]?\ ?)?[0-9]{3}[-\.]?[0-9]{4}$

# Password between 8 and 20 characters; must contain at least one lowercase letter, one uppercase letter, one numeric digit, and one special character, but cannot contain whitespace.
# ID: 2983
^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\s).{8,20}$

# email format for registered worlwide domains only country domains are not included
# ID: 3524
[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+(?:\.)+(?:[A-Z]{2}|aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|xxx|us)\b

# Date format yyyy-mm-dd
# ID: 3525
^((19|20)\d\d)[- /.](([1-9]|[0][1-9]|1[012]))[- /.](([1-9]|[0][1-9]|1[012])|([12][0-9]|3[01]))$

# match valid ip
# ID: 1264
\b(((?!\d\d\d)\d+|1\d\d|2[0-4]\d|25[0-5])(\b|\.)){4}

# Finds the last word in a string eg. the user in \\domain\user or the extension/file type in a file name.
# ID: 1609
\w*$

# Currently decimal(9,2)
# ID: 3427
\d{0,7}([\.|\,]\d{0,2})?

# remove the tailling zero (0)
# ID: 3428
\d+([\.|\,][0]+?[1-9]+)?

# This regex will match all text inside angle brackets and HTML comments.
# ID: 3394
(<(!--.*|script)(.|\n[^<])*(--|script)>)|(<|<)(/?[\w!?]+)\s?[^<]*(>|>)|(\&[\w]+\;)

# This is a modification of the zip code regular expression submitted by Steven Smith (ssmith@aspalliance.com)
# ID: 87
^(\d{5}-\d{4}|\d{5})$|^([a-zA-Z]\d[a-zA-Z] \d[a-zA-Z]\d)$

# This re was used for a security routine. The format is:
# ID: 44
^(user=([a-z0-9]+,)*(([a-z0-9]+){1});)?(group=([a-z0-9]+,)*(([a-z0-9]+){1});)?(level=[0-9]+;)?$

# It will compare no. from zero to Nine lenght == 2
# ID: 2648
^[0-9]{2}

# Simple expression to validate PassCode
# ID: 2649
^[1-9][0-9]{3}$

# Simple email expression. Doesn't allow numbers in the email name.
# ID: 3194
^([a-zA-Z0_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,3}|[0-9]{1,3})(\]?)$

# Oracle like time stamp with format:
# ID: 2403
^((((((0[1-9])|(1\d)|(2[0-8]))\.((0[123456789])|(1[0-2])))|(((29)|(30))\.((0[13456789])|(1[0-2])))|((31)\.((0[13578])|(1[02]))))\.\d{4})|((29)\.(02)\.\d{2}(([02468][048])|([13579][26]))))(\s((0\d)|(1\d)|(2[0-3]))\:([0-5]\d)\:([0-5]\d)\.\d{7})$

# Simple UK Date Format dd/mm/yy or dd/mm/yyyy.
# ID: 3060
^(([0-9])|([0-2][0-9])|(3[0-1]))\/(([1-9])|(0[1-9])|(1[0-2]))\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))$

# In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, "271545Z FEB 08" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.
# ID: 3061
^(3[0-1]|2[0-9]|1[0-9]|0[1-9])(0[0-9]|1[0-9]|2[0-3])([0-5][0-9])\sUTC\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s[0-9]{2}$

# returns string between two quotes
# ID: 1059
"[^"\r\n]*"

# Indian Passport No Format
# ID: 2567
^[A-Z]{1}-[0-9]{7}$

# Least 1 upper case letter
# ID: 3545
(?=.*[A-Z]+.*)[A-Z0-9&%./-]*

# simply checks to see if the first charactor is a . (dot)
# ID: 824
^\.{1}

# For numbers such as 27 or a range using spaces and/or a hyphen such as 5 - 10 (meaning between 5 and 10).
# ID: 2615
^(\d*\s*\-?\s*\d*)$

# UK phone number for both Geographic (landline) and Non-Geographic (Cell) numbering. It validates a complete range of combination of area code, location and formate , it also allows international number starting from +44 or 0044 and it also allows () with area code and spaces.
# ID: 3216
^(((\+44\s?|0044\s?)?|(\(?0))((2[03489]\)?\s?\d{4}\s?\d{4})|(1[23456789]1\)?\s?\d{3}\s?\d{4})|(1[23456789][234578][0234679]\)?\s?\d{6})|(1[2579][0245][0467]\)?\s?\d{5})|(11[345678]\)?\s?\d{3}\s?\d{4})|(1[35679][234689]\s?[46789][234567]\)?\s?\d{4,5})|([389]\d{2}\s?\d{3}\s?\d{4})|([57][0-9]\s?\d{4}\s?\d{4})|(500\s?\d{6})|(7[456789]\d{2}\s?\d{6})))$

# Matches any-length chilean RUT (Rol Unico Tributario) and RUN (RUT (Rol Unico Nacional), with or without dots as thousand separator, and with or without hyphen as verification digit separator. Grab 1st and 3rd match for best results. Delete the dots from 1st match
# ID: 2444
^0*(\d{1,3}(\.?\d{3})*)\-?([\dkK])$

# This function does basic testing for the YYYY-MM-DD date format.
# ID: 1741
[0-9]{4}-([0][0-9]|[1][0-2])-([0][0-9]|[1][0-9]|[2][0-9]|[3][0-1])

# Needed to verify a currency amount entered has commas and two decimal spaces to the right. This has a range between 1.99 to the tens of millions. If you want to make the decimal side optional, add a question mark before the final $ in each expression.
# ID: 2339
^\$?\d{1,2}\,\d{3}?\,\d{3}?(\.(\d{2}))$|^\$?\d{1,3}?\,\d{3}?(\.(\d{2}))$|^\$?\d{1,3}?(\.(\d{2}))$

# This expression can be used against HTML response from some methods of FrontPage RPC protocol (this protocol is used in SharePoint)
# ID: 2346
<ul>\n<li>(?<type>document_name|url)=(?<doc>.*?)<li>.*?<ul>\n(?:<li>(?<propName>.*?)\n<li>(?<propValue>.*?))+</ul>\n</ul>

# this regex was developed for command line parsing. it will get you one parameter per match while checking for strings enclosed in double quotes and double quotes escaping ("").
# ID: 1230
(?<quote>["]?)(?<param>(?:\k<quote>{2}|[^"]+)*)\k<quote>[ ]+

# Validates Date and time in the format mm/dd/yyyy hh:mi:ss
# ID: 3507
(([1-9])|(0[1-9])|(1[0-2]))\/(([0-9])|([0-2][0-9])|(3[0-1]))\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\s+(20|21|22|23|[01]\d|\d)(([:.][0-5]\d){1,2})$

# This is a Microsoft .NET/Mono regular expression that can be used to find the address of an embedded image inside an HTML email body.
# ID: 1240
[ ]*=[ ]*[\"]*cid[ ]*:[ ]*([^\"<> ]+)

# Gets the image url in an HTML <IMG> tag.
# ID: 1202
<img .+ src[ ]*=[ ]*\"(.+)\"

# Matches all positive & negative decimal floating point numbers, to any magnitude. Allows empty string.
# ID: 729
^-?\d*(\.\d+)?$

# Use this along with this replacement string <img\1 /> to convert image tags to XHTML compliant image tags.
# ID: 208
<img([^>]*[^/])>

# This Regular Expression. I have used with ASP.NET Regular expression for validating that input string should not have special characters(e.g. $,#,@ etc.]
# ID: 2497
^[a-zA-Z0-9]+(([_][a-zA-Z0-9])?[a-zA-Z0-9]*)*$

# This expression will validate date format to be yyyy-mm-dd hh:mm.
# ID: 2512
^((\d{2}(([02468][048])|([13579][26]))[-]?((((0?[13578])|(1[02]))[-]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[-]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[-]?((0?[1-9])|([1-2][0-9])))))|(\d{2}(([02468][1235679])|([13579][01345789]))[-]?((((0?[13578])|(1[02]))[-]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[-]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[-]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\s((([0-1]?[0-9])|([2][0-3]))\:([0-5][0-9])))?$

# Matches only arabic characters
# ID: 1832
\p{IsArabic}

# I know its probaly in the library, but i did not see it.
# ID: 480
(^\d{5}$)|(^\d{5}-\d{4}$)

# find the body-tag of a html page
# ID: 1587
((<body)|(<BODY))([^>]*)>

# Validate for US monetary value pattern
# ID: 3196
^-?((([0-9]{1,3},)?([0-9]{3},)*?[0-9]{3})|([0-9]{1,3}))\.[0-9]*$

# This regular expression is used for validating five digit numeric value which can be an amount $ separated with , sign.
# ID: 1902
^(\$)?((\d{1,5})|(\d{1,3})(\,\d{3})*)(\.\d{1,2})?$

# Validates some common email-adresses.
# ID: 1548
\b[\w]+[\w.-][\w]+@[\w]+[\w.-]\.[\w]{2,4}\b

# It is useful to validate Expiry date in mm/yyyy format. But it not support when year comes like 2020,2030,2040etc
# ID: 3221
^((0[1-9])|(1[0-2]))\/*((2011)|(20[1-9][1-9]))$

# Matches SpamAsssasin score above an arbitrary number.  Allows sorting of spam based on SpamAssassin score.  * should be replaced the symbol configured in SpamAssassin.
# ID: 743
X-Spam-Level:\s[*]{11}

# this will validate most legal email addresses, even allows for some discouraged but perfectly legal characters in local part; allows IP domains with optional []; keeps final tld at a minmum of 2 chars; non capturing groups for efficiency
# ID: 980
^(?:[a-zA-Z0-9_'^&/+-])+(?:\.(?:[a-zA-Z0-9_'^&/+-])+)*@(?:(?:\[?(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\.){3}(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\]?)|(?:[a-zA-Z0-9-]+\.)+(?:[a-zA-Z]){2,}\.?)$

# This expression matches brazilian's phone numbers with area codes or not.
# ID: 2568
^([(][1-9]{2}[)] )?[0-9]{4}[-]?[0-9]{4}$

# Matches unencrypted or encrypted SAS password in OMR configuration files
# ID: 1218
Password="(\{.+\}[0-9a-zA-Z]+[=]*|[0-9a-zA-Z]+)"

# Support 13 Formats (Country Code 1)
# ID: 3203
^((([+])?[1])?\s{0,1}\d{3}\s{0,1}\d{3}\s{0,1}\d{4})$

# Allow Time with AM/PM
# ID: 3204
^([0]?[1-9]|[1][0-2]):([0-5][0-9]|[1-9]) [aApP][mM]$

# Allow 24 hrs time format
# ID: 3205
^([0]?[1-9]|[1][0-2]|[2][0-3]):([0-5][0-9]|[1-9])$

# US Telephone Reg expression that allows 7, 10 or 11 digits with or without hyphens.
# ID: 97
^(1?(-?\d{3})-?)?(\d{3})(-?\d{4})$

# DDD Brasileiro no Formato de 2 digitos não é aceito zero na primeira casa
# ID: 1001
[1-9][0-9]

# Validação para letras maiusculas e minusculas sem acentos, incluinto os caracteres . - & e /
# ID: 880
^\s*[a-zA-Z0-9&\-\./,\s]+\s*$

# Expressão para a Validação do CNPJ contendo ou não os caracteres de separação . e /.
# ID: 881
(^(\d{2}.\d{3}.\d{3}/\d{4}-\d{2})|(\d{14})$)

# Expressão para a Validação de Telefones Celulares sem o DDD valida celulares com inicio igual a 7,8 e 9.
# ID: 882
((([7-9])(\d{3})([-])(\d{4}))|(([7-9])(\d{7})))

# Validação de CPF Brasileiro com ou sem os divisores.
# ID: 872
(^(\d{3}.\d{3}.\d{3}-\d{2})|(\d{11})$)

# Formato de Telefone Brasileiro, sem o DDD
# ID: 873
(^\d{3,4}\-\d{4}$)|(^\d{7,8}$)

# This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression  to Client From MOnth/Year.
# ID: 721
(((0[123456789]|10|11|12)([/])(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))

# This is the Brazilian Date Format.
# ID: 709
(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])([1-2][0,9][0-9][0-9]))|((29)(\.|-|\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))

# Expression to validate values to fields Decimal 5,2 or 5 numbers. values >=100,00 <=99999,99
# ID: 710
(^\d{3,5}\,\d{2}$)|(^\d{3,5}$)

# simply email regular expression
# ID: 863
^\+?[a-z0-9](([-+.]|[_]+)?[a-z0-9]+)*@([a-z0-9]+(\.|\-))+[a-z]{2,6}$

# This regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal.
# ID: 152
^\d{0,2}(\.\d{1,2})?$

# This RegEx will match a RTF color taken from a color tabel in a RTF document (having the form '\redXXX\greenXXX\blueXXX;', where XXX is a number between 0 and 255).
# ID: 1208
\\red([01]?\d\d?|2[0-4]\d|25[0-5])\\green([01]?\d\d?|2[0-4]\d|25[0-5])\\blue([01]?\d\d?|2[0-4]\d|25[0-5]);

# Verifies URLs.  Checks for the leading protocol, a good looking domain (two or three letter TLD; no invalid characters in domain) and a somwhat reasonable file path.
# ID: 90
^http\://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(/\S*)?$

# it validates a simple URL like http://www.google.com , ftp://www.soso.com
# ID: 1517
^[http|ftp|wap|https]{3,5}:\//\www\.\w*\.[com|net]{2,3}$

# Check Password: 5 - 10 characters long, start with a letter and contain at least one number. No special characters
# ID: 2667
^([a-zA-Z])(?=.*\d)\w{4,9}$

# Simply match to a combination of 5 characters, using capital letters and numbers only. No special characters or lower case letters.
# ID: 2704
^([A-Z0-9]{5})$

# Valid for years 1800-2099. Can be easily modified to extend the range
# ID: 2958
(1[8,9]|20)[0-9]{2}

# This expression can be used to set the bugtraq:logrexep property of a subversion repository. It uses the format supported by trac and enables for example tortoisesvn to transform the issue numbers used in the commit messages into links pointing to the issue in the bugtracker.
# ID: 1617
(refs|references|re|closes|closed|close|see|fixes|fixed|fix|addresses) #(\d+)(( and |, | & | )#(\d+))*

# this expression validates a date-time field in European dd/mm/yyyy hh:mm format
# ID: 2712
(((((0[1-9]|[12][0-9]|3[01])/(0[13578]|1[02]))|((0[1-9]|[12][0-9]|30)/(0[469]|11))|((0[1-9]|[1][0-9]|2[0-8]))/02)/([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$))|(29/02/(([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00)) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$)))

# Finds all one syllable words. the letters in brackets are vowels and they can be changed depending on the language.
# ID: 1834
\b[^aeiou]+[aeiou][^aeiou]+\b

# This is an update of Paul Miller's RegEx.  It will cut out literal &lt;&gt; but I haven't fully tested it, it's just a quick fix since his didn't work all that well.
# ID: 317
^([0-9A-Za-z@.]{1,255})$

# spam stopper, catches non english language flocks for letter A
# ID: 554
(À|Á|Â|Ã|Ä|Å|à|á|â|ã|ä|å|&#097;|&#065;|&#064;|&commat;|&alpha;|&#192;|&#193;|&#194;|&#195;|&#196;|&#197;|&Agrave;|&Aacute;|&Acirc;|&Atilde;|&Auml;|&Aring;|&#224;|&#225;|&#226;|&#227;|&#228;|&#229;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;)

# Spam stopper, catches non english characters used in flocks.
# ID: 555
(È|É|Ê|Ë|è|é|ê|ë|&#069;|&#101;|&#200;|&#201;|&#202;|&#203;|&Egrave;|&Eacute;|&Ecirc;|&Euml;|&#232;|&#233;|&#234;|&#235;|&egrave;|&eacute;|&ecirc;|&euml;)

# Spam stopper, catches any non english characters for i used in flocks
# ID: 556
(¡|Ì|Í|Î|Ï|ì|í|î|ï|&#033;|&#161;|&iexcl;|&#185;|&sup1;|&brvbar;|&Igrave;|&Iacute;|&Icirc;|&Iuml;|&igrave;|&iacute;|&iuml;|&#204;|&#205;|&#206;|&#207;|&#236;|&#237;|&#238;|&#239;|&#073;|&#105;)

# Spam stopper, catches any non english characters used for o in flocks
# ID: 557
(Ò|Ó|Ô|Õ|Ö|Ø|ð|ò|ó|ô|õ|ö|ø|&#048;|&#079;|&#111;|&#210;|&#211;|&#212;|&#213;|&#214;|&#216;|&Ograve;|&Oacute;|&Ocirc;|&Otilde;|&Ouml;|&Oslash;|&#242;|&#243;|&#244;|&#245;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&oslash;)

# Spam stopper, catches any non english characters for u used in flocks
# ID: 558
(Ù|Ú|Û|Ü|ù|ú|û|ü|µ|&#085;|&#117;|&#181;|&micro;|&#217;|&#218;|&#219;|&#220;|&Ugrave;|&Uacute;|&Ucirc;|&Uuml;|&#249;|&#250;|&#251;&#252;|&ugrave;|&uacute;|&ucirc;|&uuml;)

# Spam stopper
# ID: 489
.*[\$Ss]pecia[l1]\W[Oo0]ffer.*

# Spam Stopper
# ID: 490
.*[Vv][Ii1]agr.*

# Spam Stopper
# ID: 491
.*[Oo0][Ee][Mm].*

# Spam Stopper
# ID: 492
.*\$AVE|\$ave.*

# Spam Stopper
# ID: 493
.*[Pp]re[Ss\$]cr[iI1]pt.*

# Spam Stopper
# ID: 494
.*[Pp]en[Ii1][\$s].*

# [Default]
# ID: 567
^[-+]?\d+(\.\d+)?|[-+]?\.\d+?$

# matches 0 and all positive integers only. will accept comma formatting only.
# ID: 568
^(\d|,)*\d*$

# Complete date-time format according to the ISO 8601 standard.
# ID: 2468
\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:.\d{7})?[+|-](0[0-9]|1[0-2]):(00|15|30|45)

# to accept only alphanumeric with all special characters except (double/single Quotes). and if numbers then only positive numbers
# ID: 3334
^[^-]{1}?[^\"\']*$

# (Corrected)
# ID: 1146
([^a-zA-Z0-9])

# Matches valid Medicare HIC number according to CMS specifications
# ID: 3014
(?![A-Z](\d)\1{5,})(^[A-Z]{1,3}(\d{6}|\d{9})$)|(^\d{9}[A-Z][0-9|A-Z]?$)

# This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003.  It can easily be adapted for different date ranges.  It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003.  The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month.  An example of an invalid date that it would allow to pass through would be 11/31/2002.  This date is invalid because 11/31 of any year does not exist, but this expression would allow it pass through since the day part is in the range 01-31.
# ID: 109
^(0[1-9]|1[0-2])\/((0[1-9]|2\d)|3[0-1])\/(19\d\d|200[0-3])$

# This Pattern is to Validate Mobile Number with 10 digit Number and Countrycode as Optional.
# ID: 1488
^((\+)?(\d{2}[-]))?(\d{10}){1}?$

# Telephone Number Validation with Country code Optional but Mandatory Area Code.
# ID: 1489
^((\+)?(\d{2})[-])?(([\(])?((\d){3,5})([\)])?[-])|(\d{3,5})(\d{5,8}){1}?$

# This Pattern is used to validate Login Name with . and _ seprators only.
# ID: 1490
^([a-zA-Z](?:(?:(?:\w[\.\_]?)*)\w)+)([a-zA-Z0-9])$

# This Pattern used to Validate single Email Address .with first character as Alphabate and allowing . and _ as seprator more that once.
# ID: 1491
^[a-zA-Z]([a-zA-Z[._][\d]])*[@][a-zA-Z[.][\d]]*[.][a-z[.][\d]]*

# This validates for Strings for Various Industry Types / Functional Areas. Useful in case of  Validation for diferent Inputs Related.This RegEx allows  following characters as seprator_ - / & and white spaces
# ID: 1460
^([a-zA-Z0-9])+(([a-zA-Z0-9\s])+[_-//&a-zA-Z0-9]([a-zA-Z0-9\s])+)*([a-zA-Z0-9])+$

# [Default]
# ID: 750
^((31(?!\ (Apr(il)?|June?|(Sept|Nov)(ember)?)))|((30|29)(?!\ Feb(ruary)?))|(29(?=\ Feb(ruary)?\ (((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\d|2[0-8])\ (Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\ ((1[6-9]|[2-9]\d)\d{2})$

# Use this regex to match urls (including folder, file and querystring) in unstructured text that are not in anchor tags. Replace with <a href="$1">$1</a> to create anchor tags.
# ID: 2231
\b((?<!["'>])(?:https?://)?(?<![-@>])(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])\.)+(?:com|org|net|gov|mil|biz|info|name|aero|mobi|jobs|museum|[A-Z]{2})(?:/[-A-Z0-9\/_.]+)?(?:\?[-A-Z0-9&\._%=,]+)?(?!['"<]))\b

# Cheap and cheerful URL checker. Requires a http/https/ftp at the start and will then allow anything starting with at least a <something>.<something>.<something> then valid characters separated by dots and slashes
# ID: 732
^(ht|f)tp(s?)\:\/\/[a-zA-Z0-9\-\._]+(\.[a-zA-Z0-9\-\._]+){2,}(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&%\$#_]*)?$

# It validates the leap year also
# ID: 1685
(^(3[01]|[12][0-9]|0?[1-9])\s{1}(Jan|Mar|May|Jul|Aug|Oct|Dec)\s{1}((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(30|[12][0-9]|0?[1-9])\s{1}(Apr|Jun|Sep|Nov)\s{1}((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(2[0-8]|1[0-9]|0?[1-9])\s{1}(Feb)\s{1}((1[8-9]\d{2})|([2-9]\d{3}))$)|(^(29)\s{1}(Feb)\s{1}([2468][048]00)$)|(^(29)\s{1}(Feb)\s{1}([3579][26]00)$)|(^(29)\s{1}(Feb)\s{1}([1][89][0][48])$)|(^(29)\s{1}(Feb)\s{1}([2-9][0-9][0][48])$)|(^(29)\s{1}(Feb)\s{1}([1][89][2468][048])$)|(^(29)\s{1}(Feb)\s{1}([2-9][0-9][2468][048])$)|(^(29)\s{1}(Feb)\s{1}([1][89][13579][26])$)|(^(29)\s{1}(Feb)\s{1}([/])([2-9][0-9][13579][26])$)

# This RegEx allow every positive number except 0 with a limit of 1 decimal.
# ID: 3502
^([1-9]+[0-9]*|\d*[.,]\d)$

# This Regular Expression searches for a valid eMail address. It uses a list of all the known top-level-domains to verify that the domain is correct. Also Possible to find the IP Address
# ID: 1605
^([_a-zA-Z0-9-]+\.[_a-zA-Z0-9-]*)\@((([a-zA-Z0-9-]{2,255})\.(ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|di|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|in|io|iq|ir|is|it|jo|jm|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|an|nc|ne|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sq|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw|arpa|arts|biz|com|edu|firm|gov|info|int|mil|nato|net|nom|org|rec|store|web))|((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])))$

# Checks for a valid Filepath, either located on a local drive or a UNC share on the network. Use the following string to include the regex within a XML defintion file: RegEx="^([a-zA-Z]\:)|(\\)(\\{1}|((\\{1})[^\\]([^/:*?<>"|]*(?<!\[\])))+)$"/> (encode the appropiate HTML characters like <,>," with the appropiate HTML codes < = (ampersand)lt; > = (ampersand)gt; " = (ampersand)quote;
# ID: 1623
^(([a-zA-Z]\:)|(\\))(\\{1}|((\\{1})[^\\]([^/:*?<>"|]*))+)$

# [Default]
# ID: 967
# Multiline
(?n:^(?=\d)((?<month>(0?[13578])|1[02]|(0?[469]|11)(?!.31)|0?2(?(.29)(?=.29.((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00))|(?!.3[01])))(?<sep>[-./])(?<day>0?[1-9]|[12]\d|3[01])\k<sep>(?<year>(1[6-9]|[2-9]\d)\d{2})(?(?=\x20\d)\x20|$))?(?<time>((0?[1-9]|1[012])(:[0-5]\d){0,2}(?i:\x20[AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$)

# This pattern is designed to allow user to enter percentage values.
# ID: 1753
^(^(100{1,1}$)|^(100{1,1}\.[0]+?$))|(^([0]*\d{0,2}$)|^([0]*\d{0,2}\.(([0][1-9]{1,1}[0]*)|([1-9]{1,1}[0]*)|([0]*)|([1-9]{1,2}[0]*)))$)$

# Deisgned to verify a MAC address with hex values seperated by a colon.
# ID: 856
((\d|([a-f]|[A-F])){2}:){5}(\d|([a-f]|[A-F])){2}

# This regular expression will find the highest level groups within recursive tokens. For instance, if I have "This is [just [an] example] of the [expression]", it'll find [just [an] example] and [expression], and nothing else. It will also not find an escaped bracket expression. If you want to replace the bracket with curly braces or parenthesis, be careful. As an example, curly braces will be: (?<!\\)\{(\\\{|\\\}|[^\{\}]|(?<!\\)\{.*(?<!\\)\})*(?<!\\)\}
# ID: 1135
(?<!\\)\[(\\\[|\\\]|[^\[\]]|(?<!\\)\[.*(?<!\\)\])*(?<!\\)\]

# This simple expression validates a USA phone number format where the +1 is required and that the phone number must only consist of numbers and spaces.
# ID: 2200
(\+1 )?\d{3} \d{3} \d{4}

# Simple expression to validate a UK phone number including country code and area code.  Requires spacing.
# ID: 2484
\+44\s\(0\)\s\d{2}\s\d{4}\s\d{4}

# This simple expression evaluates an Ireland phone number.  It requires the country code and dialing instructions for an international call plus spaces within the number.
# ID: 2485
\+353\(0\)\s\d\s\d{3}\s\d{4}

# If you are caching PHP code you may want to remove long comments from the code before caching it.  This expression will remove all /* */ style comments.
# ID: 2718
/\/\*[\d\D]*?\*\//

# Checking Iran's mobile no with or without country code.
# ID: 3376
^(((\+{1})|(0{2}))98|(0{1}))9[1-9]{1}\d{8}\Z$

# Spam trap
# ID: 656
[v,V,(\\/)](\W|)[i,I,1,l,L](\W|)[a,A,@,(\/\\)](\W|)[g,G](\W|)[r,R](\W|)[a,A,@,(\/\\))]

# I need a pattern to match the whole number / integer (0-99999...), but also allow users to put comma in the thousand positions.
# ID: 1041
^0$|^[1-9][0-9]*$|^[1-9][0-9]{0,2}(,[0-9]{3})$

# Validates a 32bit integer from 0 through 4294967296 without leading zeros. An expansion of the 16 bit version http://regexlib.com/REDetails.aspx?regexp_id=1427
# ID: 2266
^(429496729[0-6]|42949672[0-8]\d|4294967[01]\d{2}|429496[0-6]\d{3}|42949[0-5]\d{4}|4294[0-8]\d{5}|429[0-3]\d{6}|42[0-8]\d{7}|4[01]\d{8}|[1-3]\d{9}|[1-9]\d{8}|[1-9]\d{7}|[1-9]\d{6}|[1-9]\d{5}|[1-9]\d{4}|[1-9]\d{3}|[1-9]\d{2}|[1-9]\d|\d)$

# This regular expression allows you to extract literal text from an HTML (SGML compliant?) document. i believe it will also work for XML. using code to replace the HTML element you can extract the literal text only.
# ID: 1899
<[\w\"\ '\#\* \=\',\.\\\(\)\/\-\$\{\}\[\]\|\*\?\+\^\&\:\%\;\!]+>

# Useful for verifying VAT Registration Numbers
# ID: 1619
((19|20)[\d]{2}/[\d]{6}/[\d]{2})

# use this to produce search strings in your programs that run more efficiently. use the replace of the regex class to remove the characters from the user input then use the resulting string to query the database...
# ID: 1578
[\s]a[\s]|[\s]about[\s]|[\s]an[\s]|[\s]are[\s]|[\s]as[\s]|[\s]at[\s]|[\s]be[\s]|[\s]by[\s]|[\s]for[\s]|[\s]from[\s]|[\s]how[\s]|[\s]in[\s]|[\s]is[\s]|[\s]it[\s]|[\s]of[\s]|[\s]on[\s]|[\s]or[\s]|[\s]that[\s]|[\s]the[\s]|[\s]this[\s]|[\s]to[\s]|[\s]was[\s]|[\s]what[\s]|[\s]when[\s]|[\s]where[\s]|[\s]who[\s]|[\s]will[\s]|[\s]with[\s]|[\s]the[\s]|[\s]www[\s]

# only allows valid cell phones from south african service providers. to date i havent seen a cell phone number starting 079 or 089 but i think the networks might support it...
# ID: 1571
(^0[87][23467]((\d{7})|( |-)((\d{3}))( |-)(\d{4})|( |-)(\d{7})))

# validates south african phone numbers
# ID: 1572
[0](\d{9})|([0](\d{2})( |-)((\d{3}))( |-)(\d{4}))|[0](\d{2})( |-)(\d{7})

# Validates South African ID Numbers
# ID: 1573
(((\d{2}((0[13578]|1[02])(0[1-9]|[12]\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\d|30)|02(0[1-9]|1\d|2[0-8])))|([02468][048]|[13579][26])0229))(( |-)(\d{4})( |-)(\d{3})|(\d{7}))

# allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912.
# ID: 3124
[0](\d{9})|([0](\d{2})( |-|)((\d{3}))( |-|)(\d{4}))|[0](\d{2})( |-|)(\d{7})|(\+|00|09)(\d{2}|\d{3})( |-|)(\d{2})( |-|)((\d{3}))( |-|)(\d{4})

# A recursive PRCE regular expression that matches a c funtion with any number of parameters including 0 parameters. I.E: return fuction(); is the minimum it matches.
# ID: 1576
/\w+?\s\w+?\(([\w\s=]+,*|[\w\s=]+|(?R))*\);/

# Matches a .Net Framework type name. This expression also matches non-strong named types such as:
# ID: 1819
^(([A-Za-z][A-Za-z0-9.+]*?){1,}?)(,\s?([^/\\:*?"<>|]*((,\s?(Version=(\d\.?){1,4}|Culture=(neutral|\w{2}-\w{2})|PublicKeyToken=[a-f0-9]{16})(,\s?)?){3}|))){0,1}$

# Matches a .Net assembly name and groups each part of the name using named groups (not supported by all regex engines).
# ID: 1826
^(?<Assembly>(?<AssemblyName>[^\W/\\:*?"<>|,]+)(?:(?:,\s?(?:(?<Version>Version=(?<VersionValue>(?:\d{1,2}\.?){1,4}))|(?<Culture>Culture=(?<CultureValue>neutral|\w{2}-\w{2}))|(?<PublicKeyToken>PublicKeyToken=(?<PublicKeyTokenValue>[A-Fa-f0-9]{16})))(?:,\s?)?){3}|))$

# Matches a full .Net type name and breaks all the parts of the type and assembly into named groups (not supported by all regex engines)
# ID: 1827
^(?<Namespace>(?:[\w][\w\d]*\.?)*)\.(?<Class>[\w][\w\d<>]*(?:(?:\+[\w][\w\d<>]*)+|))(?:|,\W?(?<Assembly>(?<AssemblyName>[^\W/\\:*?"<>|]+)(?:$|(?:,\W?(?:(?<Version>Version=(?<VersionValue>(?:\d{1,2}\.?){1,4}))|(?<Culture>Culture=(?<CultureValue>neutral|\w{2}-\w{2}))|(?<PublicKeyToken>PublicKeyToken=(?<PublicKeyTokenValue>[A-Fa-f0-9]{16})))(?:,\W?)?){3})))$

# Validates format of email addresses including q.com but not q.net
# ID: 2478
^([a-zA-Z0-9]+[._-])*[a-zA-Z0-9]+@(([a-zA-Z0-9]+|([a-zA-Z0-9]+[.-])+)[a-zA-Z0-9]+\.[a-zA-Z]{2,4}|([a-zA-Z]\.com))$

# Gulf Area and Middle East Phone Number, must include the country code which consists of 2 or 3 digits and prefixed with '+' or '00', Area code consists of 1 or 2 digits and finally phone number consists of 7 or 8 digits, you can separate between different section using space or '-'
# ID: 2300
^(\+{1}|00)\s{0,1}([0-9]{3}|[0-9]{2})\s{0,1}\-{0,1}\s{0,1}([0-9]{2}|[1-9]{1})\s{0,1}\-{0,1}\s{0,1}([0-9]{8}|[0-9]{7})

# Use /[^]*/m instead of /.*/ A dot matches everything, but newline characters.
# ID: 1806
/[^]/m

# A very simple regex to parse 10-digit US phone numbers.  Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4.
# ID: 2352
(1)?-?\(?\s*([0-9]{3})\s*\)?\s*-?([0-9]{3})\s*-?\s*([0-9]{4})\s*

# Very flexible phone number entry. -- There are many valid ways to enter a phone number, and often there is other data that a restrictive Regex pattern will not abide. -- This pattern accepts any number of letters, commas, pound signs, slashes, spaces, periods, parenthesis, hyphens, plus signs, and asterisks... but amongst it scans for a minimum of 7 digits (modify {7} to adjust the minimum number of required digits (i.e. 10 for area code + phone number, 18 for long international numbers). -- This pattern does not attempt to restrict the entered phone number format in any way, but instead just verfies that enough digits for one was entered. -- Data in excess of the 7 required digits is allowed. -- I've posted another submission that forces compliance for US phone numbers.
# ID: 1480
^([a-zA-Z,#/ \.\(\)\-\+\*]*[0-9]){7}[0-9a-zA-Z,#/ \.\(\)\-\+\*]*$

# Very flexible US phone number entry. -- There are many valid ways to enter a phone number, and often there is other data that a restrictive Regex pattern will not abide. -- This pattern accepts any number of letters, commas, pound signs, slashes, spaces, periods, parenthesis, hyphens, plus signs, and asterisks... but amongst it scans for a minimum of 10 digits, the first and fourth of which cannot be 0 or 1 (per US phone number standards in 2006). -- Data in excess of the 10 required digits is allowed.
# ID: 1481
^([a-zA-Z,#/ \.\(\)\-\+\*]*[2-9])([a-zA-Z,#/ \.\(\)\-\+\*]*[0-9]){2}([a-zA-Z,#/ \.\(\)\-\+\*]*[2-9])([a-zA-Z,#/ \.\(\)\-\+\*]*[0-9]){6}[0-9a-zA-Z,#/ \.\(\)\-\+\*]*$

# Regular expression to match valid UK postcodes.
# ID: 260
^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$

# This regular expression is used to validate only comma separated numbers.
# ID: 2122
^([0-9]*)+(,[0-9]+)+$

# I wrote this sweet little (well, not so little really) reg to extract links from an HTML source....  it is very robust, give it a try.
# ID: 258
<[aA][ ]{0,}([a-zA-Z0-9"'_,.:;!?@$&()%=/ ]|[-]|[	\f]){0,}>((<(([a-zA-Z0-9"'_,.:;!?@$&()%=/ ]|[-]|[	\f]){0,})>([a-zA-Z0-9"'_,.:;!?@$&()%=/ ]|[-]|[	\f]){0,})|(([a-zA-Z0-9"'_,.:;!?@$&()%=/ ]|[-]|[	\f]){0,})){0,}

# Check password containing at least x numbers and y alphabetic. Use look back expression (?= )
# ID: 2404
(?=(.*\d.*){2,})(?=(.*[a-zA-Z].*){6,})

# Multi-part host name validator, RFC-compliant but does not validate length of components or overall length
# ID: 2786
[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*

# HTTP(S) URL validator with embededded multi-part host name validator, RFC-compliant but does not validate length of components or overall length.  Path portion after host name is free-form and will need refinement if you want to validate it.
# ID: 2787
https?://[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*/\S*

# Email address validator with embededded multi-part host name validator, RFC-compliant but does not validate length of components or overall length.
# ID: 2788
[A-Za-z0-9!#$%&'*+\-/=?^_`{|}~]+(?:\.[A-Za-z0-9!#$%&'*+\-/=?^_`{|}~]+)*@[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*

# This regex match dates in the international standard date notation by ISO (IS0 8601). It can validate any dates between 1900-01-01 and 2099-12-31 ant take account of leap years. The format is mandatory and the hyphen is needed.  You could easily change it to accept other separators.  It has been tested with Regex Coach and PHP.
# ID: 1758
^(((19|20)(([0][48])|([2468][048])|([13579][26]))|2000)[\-](([0][13578]|[1][02])[\-]([012][0-9]|[3][01])|([0][469]|11)[\-]([012][0-9]|30)|02[\-]([012][0-9]))|((19|20)(([02468][1235679])|([13579][01345789]))|1900)[\-](([0][13578]|[1][02])[\-]([012][0-9]|[3][01])|([0][469]|11)[\-]([012][0-9]|30)|02[\-]([012][0-8])))$

# Matches all IPv6 text representations as defined within RFC 2373. Fairly verbose
# ID: 906
^(^(([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){5}::[0-9A-F]{1,4})|((:[0-9A-F]{1,4}){4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){3}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|(:[0-9A-F]{1,4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,5})|(:[0-9A-F]{1,4}){7}))$|^(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,6})$)|^::$)|^((([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){3}::([0-9A-F]{1,4}){1})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){1}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|((:[0-9A-F]{1,4}){0,5})))|([:]{2}[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})):|::)((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})\.){3}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})$$

# The OAGIS standard has a format for phone and fax as +###(###)#######. For details on standard see the open applications group.
# ID: 1429
^\+[0-9]{1,3}\([0-9]{3}\)[0-9]{7}$

# Finds sentences (assuming they end with a full stop, question mark or exclamation mark).
# ID: 952
([^\.\?\!]*)[\.\?\!]

# Validates time in MySQL time format.  24 hour time colon seperated hours:minutes:seconds
# ID: 248
(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])

# A regex for phone numbers in Portugal. For the three major operators (TMN, Optimus, Vodafone) and landline number. 1 number (2/9) + 1 number (1-9) + 7 others (0-9).
# ID: 3477
^(9|2{1})+([1-9]{1})+([0-9]{7})$

# Supported: +48 prefix (optional); separating elements with hyphen or spaces
# ID: 2354
^(\+48\s+)?\d{3}(\s*|\-)\d{3}(\s*|\-)\d{3}$

# Currency which cannot be less than $1000 and lower than a billion.
# ID: 1125
^\$?([1-9][0-9]{3,}(\.\d{2})?|(\d{1,3}\,\d{3}|\d{1,3}\,\d{3}(\.\d{2})?)|(\d{1,3}\,\d{3}|\d{1,3}\,\d{3}\,\d{3}(\.\d{2})?)*)?$

# RFC2822 compliant email matching regex that doesn't assume TLDs are set for all time. Clearly this means that someone could get a 2 letter country code wrong, but since no TLD is set in stone, I prefer to match future possibilities as well. This also conforms to what traditional DNS can do w/r/t hostnames and domain names.
# ID: 1756
^(([-\w$%&'*+\/=?^_`{|}~.]+)@(([-a-zA-Z0-9_]+\.)*)([-a-zA-Z0-9]+\.)([a-zA-Z0-9]{2,7}))?$

# MM-DD-20YY HH:MM AP
# ID: 241
^(([0]?[1-9]|[1][0-2])[\/|\-|\.]([0-2]\d|[3][0-1]|[1-9])[\/|\-|\.]([2][0])?\d{2}\s+((([0][0-9]|[1][0-2]|[0-9])[\:|\-|\.]([0-5]\d)\s*([aApP][mM])?)|(([0-1][0-9]|[2][0-3]|[0-9])[\:|\-|\.]([0-5]\d))))$

# Time off hours edit for quarter hour(s) less than eight.
# ID: 479
^(([8]))$|^((([0-7]))$|^((([0-7])).?((25)|(50)|(5)|(75)|(0)|(00))))$

# Manually derived this from the grammar in Appendix A of RFC3986 (Uniform Resource Identifier (URI): Generic Syntax).
# ID: 3003
^([a-zA-Z][a-zA-Z0-9+-.]*):((\/\/(((([a-zA-Z0-9\-._~!$&'()*+,;=':]|(%[0-9a-fA-F]{2}))*)@)?((\[((((([0-9a-fA-F]{1,4}:){6}|(::([0-9a-fA-F]{1,4}:){5})|(([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){4})|((([0-9a-fA-F]{1,4}:)?[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){3})|((([0-9a-fA-F]{1,4}:){0,2}[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){2})|((([0-9a-fA-F]{1,4}:){0,3}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4}:)|((([0-9a-fA-F]{1,4}:){0,4}[0-9a-fA-F]{1,4})?::))((([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}))|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))))|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4})|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::))|(v[0-9a-fA-F]+\.[a-zA-Z0-9\-._~!$&'()*+,;=':]+))\])|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))|(([a-zA-Z0-9\-._~!$&'()*+,;=']|(%[0-9a-fA-F]{2}))*))(:[0-9]*)?)((\/([a-zA-Z0-9\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))*)*))|(\/?(([a-zA-Z0-9\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))+(\/([a-zA-Z0-9\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))*)*)?))(\?(([a-zA-Z0-9\-._~!$&'()*+,;=':@\/?]|(%[0-9a-fA-F]{2}))*))?((#(([a-zA-Z0-9\-._~!$&'()*+,;=':@\/?]|(%[0-9a-fA-F]{2}))*)))?$

# Best For First Name or Middle Name or Last Name
# ID: 2279
[-'a-zA-Z]

# Parse the sentence to separated words and signs of preposition.
# ID: 2262
(?<word>([\w]*))(?<prep>([\,\.\!\?\-\:\;\""\(\)])?)

# Analises the complex address string
# ID: 2474
(?<street>((\d+\-)?[?-?\.]* )*)(?<IsStreet>((?????)|(????????)|(??-?)|(?-?)|(??-?)|(???????)|(???[ \.]?)|(???(?:\.)?)|(?(?:\.)?)|(??\.)|(???(?:\.)?)|(??(?:\.)?))) *(?<street2>[?-?]{2,} )?(?:?\.?)?(?<home>\d+[?-?]?)([ -/?]+(???)?(?<building>\d+)[ -/](?<flat>\d+))*([ -/](??\.? ?)?(?<flat>\d+))?

# Zero excluding money amount
# ID: 2037
((0)+(\.[1-9](\d)?))|((0)+(\.(\d)[1-9]+))|(([1-9]+(0)?)+(\.\d+)?)|(([1-9]+(0)?)+(\.\d+)?)

# pattern for processing phone (phones) numbers (Russia)
# ID: 1463
((8|\+7)-?)?\(?\d{3,5}\)?-?\d{1}-?\d{1}-?\d{1}-?\d{1}-?\d{1}((-?\d{1})?-?\d{1})?

# Search sentences with words ending by -???/-????
# ID: 3070
([^\.]*?(\w+(???|????))[^\.]*?\.+)\s+

# This Expression validates alfanumeric values. This was created to validate a range of values that could start with ?.
# ID: 3452
^([A-Z0-9?.+-])+([,]([A-Z0-9?.+-])+)*$

# Validates an German area dial code and telephone number.
# ID: 1994
^((00|\+)49)?(0?[2-9][0-9]{1,})$

# Validates all German area dial code and telephone numbers.
# ID: 1995
^((00|\+)49)?(0?1[5-7][0-9]{1,})$

# Validates the German Bank Code named "Bankleitzahl"
# ID: 2004
[1-8][0-9]{2}[0-9]{5}

# U. S. or Canadian telephone number regular expression. <BR>
# ID: 588
^[01]?[- .]?\(?[2-9]\d{2}\)?[- .]?\d{3}[- .]?\d{4}$

# Should match just about any real name, either first
# ID: 525
^[A-Za-zÀ-ÖØ-öø-ÿ '\-\.]{1,22}$

# Canadian Postal Code / Codes / Canada / Zip
# ID: 526
^[abceghjklmnprstvxyABCEGHJKLMNPRSTVXY][0-9][abceghjklmnprstvwxyzABCEGHJKLMNPRSTVWXYZ] {0,1}[0-9][abceghjklmnprstvwxyzABCEGHJKLMNPRSTVWXYZ][0-9]$

# This pattern is a extension of Jeremy Samuel's password pattens, I included a validation for the string not end with number
# ID: 1569
^((?=[^\d])(?=^*[^0-9]$)(?!.*')(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s))?(?=.*[^\d]$).{8,15}$

# A simple regex to check a version information string of the style 1.0.0.0
# ID: 2269
^(0\.|([1-9]([0-9]+)?)\.){3}(0|([1-9]([0-9]+)?)){1}$

# Matches valid Windows filenames using local, network and UNC formats.
# ID: 2106
(?i)^(((\\\\(\?\\(UNC\\)?)?)([A-Z]:\\|([^\\\/\:\*\?\"\<\>\|\.\s][^\\\/\:\*\?\"\<\>\|]+[^\\\/\:\*\?\"\<\>\|\.\s]\\){2}))|[A-Z]:\\)([^\\\/\:\*\?\"\<\>\|\s][^\\\/\:\*\?\"\<\>\|]+[^\\\/\:\*\?\"\<\>\|\s]\\)*([^\\\/\:\*\?\"\<\>\|\.\s][^\\\/\:\*\?\"\<\>\|\.]+[^\\\/\:\*\?\"\<\>\|\.\s])(\.[^\\\/\:\*\?\"\<\>\|\.\s]+)*?$

# Validate date with arabic numeral of the form dd/mm/yy or dd/mm/yy or dd-mm-yy or dd-mm-yyyy or dd.mm.yy or dd.mm.yyyy
# ID: 3574
^((((\u0660?[\u0661-\u0669]|[\u0661\u0662][\u0660-\u0669]|\u0663[\u0660\u0661])[\.\-\/](\u0660?[\u0661\u0663\u0665\u0667\u0668]|\u0661[\u0660\u0662])[\.\-\/]((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|((\u0660?[\u0661-\u0669]|[\u0661\u0662][\u0660-\u0669]|\u0663\u0660)[\.\-\/](\u0660?[\u0661\u0663\u0664\u0665\u0666\u0667\u0668\u0669]|\u0661[\u0660\u0661\u0662])[\.\-\/]((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|((\u0660?[\u0661-\u0669]|\u0661[\u0660-\u0669]|\u0662[\u0660-\u0668])[\.\-\/]\u0660?\u0662[\.\-\/]((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|(\u0662\u0669[\.\-\/]\u0660?\u0662[\.\-\/]((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?(\u0660[\u0664\u0668]|[\u0662\u0664\u0666\u0668][\u0660\u0664\u0668]|[\u0661\u0663\u0665\u0667\u0669][\u0662\u0666])|((\u0661\u0666|[\u0662\u0664\u0666\u0668][\u0660\u0664\u0668]|[\u0663\u0665\u0667\u0669][\u0662\u0666])\u0660\u0660)|\u0660\u0660)))|(((\u0660[\u0661-\u0669]|[\u0661\u0662][\u0660-\u0669]|\u0663[\u0660\u0661])(\u0660[\u0661\u0663\u0665\u0667\u0668]|\u0661[\u0660\u0662])((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|((\u0660[\u0661-\u0669]|[\u0661\u0662][\u0660-\u0669]|\u0663\u0660)(\u0660[\u0661\u0663\u0664\u0665\u0666\u0667\u0668\u0669]|\u0661[\u0660\u0661\u0662])((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|((\u0660[\u0661-\u0669]|\u0661[\u0660-\u0669]|\u0662[\u0660-\u0668])\u0660\u0662((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|(\u0662\u0669\u0660\u0662((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?(\u0660[\u0664\u0668]|[\u0662\u0664\u0666\u0668][\u0660\u0664\u0668]|[\u0661\u0663\u0665\u0667\u0669][\u0662\u0666])|((\u0661\u0666|[\u0662\u0664\u0666\u0668][\u0660\u0664\u0668]|[\u0663\u0665\u0667\u0669][\u0662\u0666])\u0660\u0660)|\u0660\u0660))))$

# Validate date of the form dd/mm/yy or dd/mm/yy or dd-mm-yy or dd-mm-yyyy or dd.mm.yy or dd.mm.yyyy in Arabic or English numerals
# ID: 3575
^((((\u0660?[\u0661-\u0669]|[\u0661\u0662][\u0660-\u0669]|\u0663[\u0660\u0661])[\.\-\/](\u0660?[\u0661\u0663\u0665\u0667\u0668]|\u0661[\u0660\u0662])[\.\-\/]((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|((\u0660?[\u0661-\u0669]|[\u0661\u0662][\u0660-\u0669]|\u0663\u0660)[\.\-\/](\u0660?[\u0661\u0663\u0664\u0665\u0666\u0667\u0668\u0669]|\u0661[\u0660\u0661\u0662])[\.\-\/]((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|((\u0660?[\u0661-\u0669]|\u0661[\u0660-\u0669]|\u0662[\u0660-\u0668])[\.\-\/]\u0660?\u0662[\.\-\/]((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|(\u0662\u0669[\.\-\/]\u0660?\u0662[\.\-\/]((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?(\u0660[\u0664\u0668]|[\u0662\u0664\u0666\u0668][\u0660\u0664\u0668]|[\u0661\u0663\u0665\u0667\u0669][\u0662\u0666])|((\u0661\u0666|[\u0662\u0664\u0666\u0668][\u0660\u0664\u0668]|[\u0663\u0665\u0667\u0669][\u0662\u0666])\u0660\u0660)|\u0660\u0660)))|(((\u0660[\u0661-\u0669]|[\u0661\u0662][\u0660-\u0669]|\u0663[\u0660\u0661])(\u0660[\u0661\u0663\u0665\u0667\u0668]|\u0661[\u0660\u0662])((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|((\u0660[\u0661-\u0669]|[\u0661\u0662][\u0660-\u0669]|\u0663\u0660)(\u0660[\u0661\u0663\u0664\u0665\u0666\u0667\u0668\u0669]|\u0661[\u0660\u0661\u0662])((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|((\u0660[\u0661-\u0669]|\u0661[\u0660-\u0669]|\u0662[\u0660-\u0668])\u0660\u0662((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?[\u0660-\u0669]{2}))|(\u0662\u0669\u0660\u0662((\u0661[\u0666-\u0669]|[\u0662-\u0669][\u0660-\u0669])?(\u0660[\u0664\u0668]|[\u0662\u0664\u0666\u0668][\u0660\u0664\u0668]|[\u0661\u0663\u0665\u0667\u0669][\u0662\u0666])|((\u0661\u0666|[\u0662\u0664\u0666\u0668][\u0660\u0664\u0668]|[\u0663\u0665\u0667\u0669][\u0662\u0666])\u0660\u0660)|\u0660\u0660)))|(((0?[1-9]|[12]\d|3[01])[\.\-\/](0?[13578]|1[02])[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|((0?[1-9]|[12]\d|30)[\.\-\/](0?[13456789]|1[012])[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|((0?[1-9]|1\d|2[0-8])[\.\-\/]0?2[\.\-\/]((1[6-9]|[2-9]\d)?\d{2}))|(29[\.\-\/]0?2[\.\-\/]((1[6-9]|[2-9]\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))|(((0[1-9]|[12]\d|3[01])(0[13578]|1[02])((1[6-9]|[2-9]\d)?\d{2}))|((0[1-9]|[12]\d|30)(0[13456789]|1[012])((1[6-9]|[2-9]\d)?\d{2}))|((0[1-9]|1\d|2[0-8])02((1[6-9]|[2-9]\d)?\d{2}))|(2902((1[6-9]|[2-9]\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00))))$

# This regex accepts decimal number with exactly 2 numbers after comma and  without point.
# ID: 2032
^[+-]?\d+(\,\d{2})? *?$

# This regex validates a persons first name. Acceptable names include compound names with a hyphen or a space in them.
# ID: 719
^[a-zA-Z]+((\s|\-)[a-zA-Z]+)?$

# This regex validates a persons last name. Acceptable names can include compound names seperated by a hyphen or a space.
# ID: 720
^[a-zA-Z]+((((\-)|(\s))[a-zA-Z]+)?(,(\s)?(((j|J)|(s|S))(r|R)(\.)?|II|III|IV))?)?$

# Password matching expression. Password must consists of at least 6 characters and not more than 20 characters. Password must contain only letters and digits. Password must contain at least 2 digits and at least 2 letters.
# ID: 1359
^(?=.*[a-zA-Z].*[a-zA-Z])(?=.*\d.*\d)[a-zA-Z0-9]{6,20}$

# validates after dot operator. matches atleast 2 char and max 3 char.www dot is rejected.
# ID: 1991
^[a-zA-Z0-9\-\.]+\.([a-zA-Z]{2,3})$

# Validates for string to be atleast 2 char and max 64 char
# ID: 1992
^([a-zA-Z0-9-\,\s]{2,64})$

# This Expression is used to Validate the US curreny.
# ID: 2614
\$(\d)*\d

# This regex is handy for matching *uncommented* COPY statements in COBOL programs, plus the name of the copy book member to be copied.  If you want to list out the COPY'ed source files contained in a COBOL program, this will do it.  Consider the text:
# ID: 1235
# Multiline
# The real regex is: 
# (?<=\n......\s*\b)COPY\b\s*\b(\w*(-)?\w*)*\b
\bCOPY\b\s*\b(\w*(-)?\w*)*\b

# Matches a semi-colon-delimited string of email addresses.  Delimiter can include a space after the semi-colon.  Based on/thanks to David Huyck's pattern, with the domain extension opened up and specific extensions removed.
# ID: 3055
^([_a-zA-Z0-9-]+(\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.(([0-9]{1,3})|([a-zA-Z]{2,})))(;[ ]?[_a-zA-Z0-9-]+(\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.(([0-9]{1,3})|([a-zA-Z]{2,})))*$

# matches uk postcodes according to specifications found at: http://www.govtalk.gov.uk/gdsc/html/noframes/PostCode-2-1-Release.htm
# ID: 1270
^((([A-PR-UWYZ](\d([A-HJKSTUW]|\d)?|[A-HK-Y]\d([ABEHMNPRVWXY]|\d)?))\s*(\d[ABD-HJLNP-UW-Z]{2})?)|GIR\s*0AA)$

# A stupid REGEXP that validate a binary number on more rows.
# ID: 3465
^(0|1)+$

# My first date validator.
# ID: 3466
^((0?[1-9])|(([1|2]\d)|(3[0|1])))(/|-)((0?[1-9])|(1[0|1|2]))(/|-)(((19|20)\d\d)|(\d\d))

# Matches parts of a name. Last name only; first and last names; first, middle, and last names; first, middle, and last names and suffix; first and last names and suffix. This is very permissive so it's good for isolating name parts but doesn't validate whether a string is a reasonable name.
# ID: 1433
(^\s*(?<firstname>(?!st\.?\s+)\w+\S*)\s+(?<middlename>(?!st\.?\s+)\w+\S*)\s+(?<lastname>(st\.?\s+)?\w+[^, ]*)(?:(,| ))*\s+(?<suffix>\w+\S*)\s*$)|(^\s*(?<firstname>(?!st\.?\s+)\w+\S*)\s+(?<lastname>(st\.?\s+)?\w+\S*)\s+(?<suffix>(jr)|(sr)|(ii)|(iii)||(iv)|(v)|(vi)|(vii)|(viii))\s*$)|(^\s*(?<firstname>(?!st\.?\s+)\w+\S*)\s+(?<middlename>(?!st\.?\s+)\w+\S*)\s+(?<lastname>(st\.?\s+)?\w+\S*)\s*$)|(^\s*(?<firstname>(?!st\.?\s+)\w+\S*)\s+(?<lastname>(st\.?\s+)?\w+\S*)\s*$)|(^\s*(?<lastname>(st\.?\s+)?\w+\S*)\s*$)

# Detects HTML tags open and/or closed with and without whitespace or characters in between. Good for stripping all tags from a string.
# ID: 339
>(?:(?<t>[^<]*))

# Matches a md5 hash, simple yet powerful
# ID: 698
^([a-z0-9]{32})$

# date and time. mm/dd/yyyy 00:00 format
# ID: 2503
/^(\d{1,2})(\/)(\d{1,2})(\/)(\d{4})(T|\s{1,2})(([0-1][0-9])|(2[0-3])):([0-5][0-9])+$/;

# VAT Numbers format verification (United Kingdom) with support for optional member state definition.
# ID: 1308
(GB-?)?([1-9][0-9]{2}\ ?[0-9]{4}\ ?[0-9]{2})|([1-9][0-9]{2}\ ?[0-9]{4}\ ?[0-9]{2}\ ?[0-9]{3})|((GD|HA)[0-9]{3})

# VAT Numbers format verification (Ireland) with support for optional member state definition.
# ID: 1309
(IE-?)?[0-9][0-9A-Z\+\*][0-9]{5}[A-Z]

# VAT Numbers format verification (Lithuania) with support for optional member state definition.
# ID: 1310
(LT-?)?([0-9]{9}|[0-9]{12})

# VAT Numbers format verification (The Netherlands) with support for optional member state definition.
# ID: 1311
(NL-?)?[0-9]{9}B[0-9]{2}

# Accurate IP address verification...
# ID: 1291
((0|1[0-9]{0,2}|2[0-9]?|2[0-4][0-9]|25[0-5]|[3-9][0-9]?)\.){3}(0|1[0-9]{0,2}|2[0-9]?|2[0-4][0-9]|25[0-5]|[3-9][0-9]?)

# Accurate Australian postal code verification.
# ID: 1292
(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})

# Accurate Canadian postal code format verification.
# ID: 1293
([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\ ?([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])

# Accurate German postal code verification.
# ID: 1294
((0[13-7]|1[1235789]|[257][0-9]|3[0-35-9]|4[0124-9]|6[013-79]|8[0124-9]|9[0-5789])[0-9]{3}|10([2-9][0-9]{2}|1([2-9][0-9]|11[5-9]))|14([01][0-9]{2}|715))

# Accurate UK postal code format verification.
# ID: 1295
(([A-Z]{1,2}[0-9][0-9A-Z]?)\ ([0-9][A-Z]{2}))|(GIR\ 0AA)

# VAT Numbers format verification (Estonia, Germany, Greece, Portugal) with support for optional member state definition.
# ID: 1296
((EE|EL|DE|PT)-?)?[0-9]{9}

# VAT Numbers format verification (Finland, Hungary, Luxemburg, Malta, Slovenia) with support for optional member state definition.
# ID: 1297
((FI|HU|LU|MT|SI)-?)?[0-9]{8}

# VAT Numbers format verification (Poland, Slovakia) with support for optional member state definition.
# ID: 1298
((PL|SK)-?)?[0-9]{10}

# VAT Numbers format verification (Italy, Latvia) with support for optional member state definition.
# ID: 1299
((IT|LV)-?)?[0-9]{11}

# VAT Numbers format verification (Sweden) with support for optional member state definition.
# ID: 1300
(SE-?)?[0-9]{12}

# VAT Numbers format verification (Belgium) with support for optional member state definition.
# ID: 1301
(BE-?)?0?[0-9]{9}

# VAT Numbers format verification (Cyprus) with support for optional member state definition.
# ID: 1302
(CY-?)?[0-9]{8}[A-Z]

# VAT Numbers format verification (Czech Republic) with support for optional member state definition.
# ID: 1303
(CZ-?)?[0-9]{8,10}

# VAT Numbers format verification (Denmark) with support for optional member state definition.
# ID: 1304
(DK-?)?([0-9]{2}\ ?){3}[0-9]{2}

# VAT Numbers format verification (Spain) with support for optional member state definition.
# ID: 1305
(ES-?)?([0-9A-Z][0-9]{7}[A-Z])|([A-Z][0-9]{7}[0-9A-Z])

# VAT Numbers format verification (France) with support for optional member state definition.
# ID: 1306
(FR-?)?[0-9A-Z]{2}\ ?[0-9]{9}

# The expression evaluates a Base64 string as a sequence of 4-byte blocks with a possible tail of 2 or 3-byte block with valid padding.
# ID: 3276
(([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?){1}

# Find all html encoded  characters as dec &#[0-9]{1,5}; or hex &#x[0-9a-fA-F]{1,4}; values. Remember to remove "amp;" which is used for making this post possible.
# ID: 3277
&#([0-9]{1,5}|x[0-9a-fA-F]{1,4});

# US and Canada phones in any usual variation (area code in parenthesis, spaces or dots) including the international notation +1
# ID: 3278
((\+?1)(\ \.-)?)?\([2-9][0-9]{2}|\([2-9][0-9]{2}\))(\ \.-)?[0-9]{3}(\ \.-)?[0-9]{4}

# The expression matches any month name (english) in short or full style. Use it with case insensitive mode in your date matching expressions.
# ID: 3279
(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Oct(ober)?|(Nov|Dec)(ember)?)

# The expression matches any weekday name (english) in short (2 or 3 characters) or full style. Use it with case insensitive mode in your date matching expressions.
# ID: 3280
(Mo(n(day)?)?|Tu(e(sday)?)?|We(d(nesday)?)?|Th(u(rsday)?)?|Fr(i(day)?)?|Sa(t(urday)?)?|Su(n(day)?)?)

# Match 5-digit or 9-digit US zip codes with grouped results. Remember to replace < with open tag char and > with close tag char
# ID: 3281
(?<group5>[0-9]{5})-?(?<group4>[0-9]{4})?

# USA Phone number with dash, periods, slashes, spaces, () and only last 7 digit is required but everything else is checked
# ID: 2542
^(1|1(\s|\s?-\s?|\s?\.\s?|\s?/\s?))?((\(?[2-9]{1}[\d]{2}\)?(\s|\s?-\s?|\s?\.\s?|\s?/\s?)?))?(\d{3})(\s|\s?-\s?|\s?\.\s?|\s?/\s?)?(\d{4})$

# For Email Inputs checks to RFC 5322 Standards (no IP address though Didn't Want them)
# ID: 2557
^[-\w'+*$^&%=~!?{}#|/`]{1}([-\w'+*$^&%=~!?{}#|`.]?[-\w'+*$^&%=~!?{}#|`]{1}){0,31}[-\w'+*$^&%=~!?{}#|`]?@(([a-zA-Z0-9]{1}([-a-zA-Z0-9]?[a-zA-Z0-9]{1}){0,31})\.{1})+([a-zA-Z]{2}|[a-zA-Z]{3}|[a-zA-Z]{4}|[a-zA-Z]{6}){1}$

# This is very similar to my other expression, except it only matches tags that a browser would read, so if you have an extra " in the tag, it will not count it, and move onto the next possibility.
# ID: 1728
</?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp)\b((\"[^\"]*\"|\'[^\']*\')*|[^\"\'>])*>

# This should match all valid HTML 4.01 tags as a browser would recognize. If you miss a 2nd " it will continue until it finds one to pair with, so if it doesn't find one, it continues until the end. This is how most browsers work I believe. It does have a few flaws, it will match </img> and </input> which is weird, but perhaps I'll fix that eventually.
# ID: 1717
<(/)?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp){1}(\s(\"[^\"]*\"*|[^>])*)*>

# Simplify US phone numbers
# ID: 3687
(\+1|\+|1)|([^0-9])

# This regular expression matches all interior vowels.
# ID: 1216
(?i:[aeiou]+)\B

# Matches number in format XX.XX Please note that this expression allows maximum of 8 digits before the dot and 2 (optional) digits after the dot.
# ID: 379
(^[0-9]{1,8}|(^[0-9]{1,8}\.{0,1}[0-9]{1,2}))$

# Matches month, requires that months 1-9 have a leading 0
# ID: 991
^((0[1-9])|(1[0-2]))$

# Matches numbers 0 through 99.9
# ID: 994
^([1-9]{0,1})([0-9]{1})(\.[0-9])?$

# This matches timezone offsets. Also matches non-hour offsets like India (+05:30) and Nepal (+5:45}. See for more timezone information: http://en.wikipedia.org/wiki/Time_zone
# ID: 985
[-+]((0[0-9]|1[0-3]):([03]0|45)|14:00)

# Returns ungrouped match on Canadian Province Code, new and old or full province name
# ID: 2377
\b(?:AB|ALB|Alta|alberta|BC|CB|British Columbia|LB|Labrador|MB|Man|Manitoba|N[BLTSU]|Nfld|NF|Newfoundland|NWT|Northwest Territories|Nova Scotia|New Brunswick|Nunavut|ON|ONT|Ontario|PE|PEI|IPE|Prince Edward Island|QC|PC|QUE|QU|Quebec|SK|Sask|Saskatchewan|YT|Yukon|Yukon Territories)\b

# We've come across the situation where we had to extract the IIS-Log entries without the header information. The data is far more complex than the sample given.
# ID: 358
^[^#]([^ ]+ ){6}[^ ]+$

# I needed an expression that would break down a written measurement, like 12' 2-15/16", into groups of feet, inches, fractional inches (num/dem). This is a modified expression based on Trevor Braun's orginal regex. Added the "ft" & "in" suffixes and the fraction's Numerator & Denominator groups.
# ID: 2127
(?:(?:(?<Feet>\d+)[ ]*(?:'|ft)){0,1}[ ]*(?<Inches>\d*(?![/\w])){0,1}(?:[ ,\-]){0,1}(?<Fraction>(?<FracNum>\d*)\/(?<FracDem>\d*)){0,1}(?<Decimal>\.\d*){0,1}(?:\x22| in))|(?:(?<Feet>\d+)[ ]*(?:'|ft)[ ]*){1}

# This will validate multiple email addresses that are comma delimited.  You can change it to use commas or semilcolons.  If you have to worry about a lot of special characters, you may have to edit it a little bit.  It allows white space before and after the comma.
# ID: 1922
^((\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*)\s*[,]{0,1}\s*)+$

# matches comments <!-- --> in string. Singleline option must be enabled. It works well also with multiple comment start tags such as: <!--this is comment <!--and this as well and end-- of comment
# ID: 3135
(\<!--\s*.*?((--\>)|$))

# Get code in between php tag <?php and ?> or until end of string if end of tag not found. Singleline option must be enabled!
# ID: 3136
(\<\?php\s+.*?((\?\>)|$))

# Just a try....
# ID: 1910
[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+(?:[A-Z]{2}|com|org|net|gov|biz|info|name|aero|biz|info|jobs|museum)\b

# Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations (RegularExpressionValidator - ASP.NET).
# ID: 1010
^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][aApP][mM]){1}$

# This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces.  The purpose is to force users to generate legitimate, readable file names that can be streamed from the web.
# ID: 507
^[a-zA-Z0-9_\s-]+$

# General phone number validation for Finland.
# ID: 2801
^((([\+][\s]{0,1})|([0]{2}[\s-]{0,1}))([358]{3})([\s-]{0,1})|([0]{1}))(([1-9]{1}[0-9]{0,1})([\s-]{0,1})([0-9]{2,4})([\s-]{0,1})([0-9]{2,4})([\s-]{0,1}))([0-9]{0,3}){1}$

# Validate Hijri Dates
# ID: 3252
^([1-9]|(0|1|2)[0-9]|30)(/|-)([1-9]|1[0-2]|0[1-9])(/|-)(14[0-9]{2})$

# Matches all valid Australian postcodes
# ID: 2151
^[2-7]{1}[0-9]{3}$

# Handles any kind of money entry. With $ sign or not, with commas or not. With bracket, negative sign or none. Max of 2 decimal points. It's perfect :)
# ID: 2857
^(-?\$?([1-9]\d{0,2}(,\d{3})*|[1-9]\d*|0|)(.\d{1,2})?|\(\$?([1-9]\d{0,2}(,\d{3})*|[1-9]\d*|0|)(.\d{1,2})?\))$

# Used Tim Cartwright example and added \s or - for separators.
# ID: 3233
^((?!000)(?!666)([0-6]\d{2}|7[0-2][0-9]|73[0-3]|7[5-6][0-9]|77[0-1]))(\s|\-)((?!00)\d{2})(\s|\-)((?!0000)\d{4})$

# Requires area code.  Allows extension.  Any common US format works.  If you prefer not to require area code, use this:   ^(\d)?[ ]*[\(\.\-]?(\d{3})?[\)\.\-]?[ ]*(\d{3})[\.\- ]?(\d{4})[ ]*(x|ext\.?)?[ ]*(\d{1,7})?$
# ID: 1456
^(\d)?[ ]*[\(\.\-]?(\d{3})[\)\.\-]?[ ]*(\d{3})[\.\- ]?(\d{4})[ ]*(x|ext\.?)?[ ]*(\d{1,7})?$

# regex to validate email address
# ID: 541
^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$

# This simple regexp should match any possible italian address entry and doesn't match NULL entries (good if address is required). Should work well for any other address (it's been verified against 250 addresses from most european countries, usa and australia. Please mail me if there's something missing
# ID: 384
^[a-zA-Z0-9ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïñòóôõöøùúûüýÿ\.\,\-\/\']+[a-zA-Z0-9ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïñòóôõöøùúûüýÿ\.\,\-\/\' ]+$

# Exchange Local code
# ID: 3576
^[A-Z0-9\\-\\&-]{5,12}$

# Allows both mobile and landline UK Telephone Numbers. Allows either Brackets or international prefix. Allows spaces after international prefix and regional code. No brackets for mobile numbers. Please report any problems. Thanks
# ID: 3066
^((\+44\s?\d{4}|\(?\d{5}\)?)\s?\d{6})|((\+44\s?|0)7\d{3}\s?\d{6})$

# For validate uri directions that must occur at the beginning of the string net.tcp|http|https|ftp|ftps://
# ID: 3302
^(net.tcp\://|(ht|f)tp(s?)\://)\S+

# Limited by proper dialing codes as per http://en.wikipedia.org/wiki/Telephone_numbers_in_South_Africa. It will match phone numbers in most common formats that users normally type their phone number.
# ID: 3105
^(?:(?:\(|)0|\+27|27)(?:1[12345678]|2[123478]|3[1234569]|4[\d]|5[134678])(?:\) | |-|)\d{3}(?: |-|)\d{4}$

# Regexp for czech telephone number format. Fix to bank account number
# ID: 2388
[^0-9]((\(?(\+420|00420)\)?( |-)?)?([0-9]{3} ?(([0-9]{3} ?[0-9]{3})|([0-9]{2} ?[0-9]{2} ?[0-9]{2})))|([0-9]{3}-(([0-9]{3}-[0-9]{3})|([0-9]{2}-[0-9]{2}-[0-9]{2}))))[^0-9|/]

# This will allow your app to check currency during events such as key down
# ID: 2439
^(([1-9]{1}[0-9]{0,5}([.]{1}[0-9]{0,2})?)|(([0]{1}))([.]{1}[0-9]{0,2})?)$

# Matches simple IP addresses. It's not too complex or long, but it does the job if you want something short/simple.
# ID: 321
^(([0-2]*[0-9]+[0-9]+)\.([0-2]*[0-9]+[0-9]+)\.([0-2]*[0-9]+[0-9]+)\.([0-2]*[0-9]+[0-9]+))$

# Matches "clan" nicks/names.
# ID: 305
^(\{|\[|\().+(\}|\]|\)).+$

# This should be the pattern described in the documentation for the .NET TimeSpan.Parse method - generally parses time spans.
# ID: 992
^\s*-?(\d*\.)?([0-2])?[0-9]:([0-5])?[0-9]:([0-5])?[0-9](\.[0-9]{1,7})?\s*$

# Tests the most common prefixes as used in The Netherlands and Germany . Commom abbreviations "v." and "v.d." are also covered.
# ID: 3107
(([a-z']?[a-z' ]*)|([a-z][\.])?([a-z][\.]))

# Check the Dutch postal code offical format of "9999 AA". Since it is often stored in a database without the space, this pattern allows 0 or 1 space.
# ID: 3011
^[0-9]{4} {0,1}[A-Z]{2}$

# Matches hours 0-12:minutes 0-59:seconds 0-59 AM|PM
# ID: 2433
((\d{0}[0-9]|\d{0}[1]\d{0}[0-2])(\:)\d{0}[0-5]\d{0}[0-9](\:)\d{0}[0-5]\d{0}[0-9]\s(AM|PM))

# A simple expression to brazilian phone number code modified expression of Rafael, beyond international code, simple DDI without "+" 99 plus simple DDD (99) plus simple and whitout parentheses em trace, local phone number 3 or 4 digits plus "-" plus 4 digits.
# ID: 718
^([0-9]{2})?((\([0-9]{2})\)|[0-9]{2})?([0-9]{3}|[0-9]{4})(\-)?[0-9]{4}$

# Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --> 2099. Is enough for my purposes. Incorectly validates 02-29-1900. I created this to validate dates on a web form where the likely range will be 2000-->2020. Seperators can be '.','/' or '-'
# ID: 1030
^(((((((0?[13578])|(1[02]))[\.\-/]?((0?[1-9])|([12]\d)|(3[01])))|(((0?[469])|(11))[\.\-/]?((0?[1-9])|([12]\d)|(30)))|((0?2)[\.\-/]?((0?[1-9])|(1\d)|(2[0-8]))))[\.\-/]?(((19)|(20))?([\d][\d]))))|((0?2)[\.\-/]?(29)[\.\-/]?(((19)|(20))?(([02468][048])|([13579][26])))))$

# This regex expression validates IP addresses when processed as a string.
# ID: 2650
\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b

# Manage negative double integer with four decimal
# ID: 2651
^[-]?[0-9]*\.?[0-9]?[0-9]?[0-9]?[0-9]?

# Query string parser matches and tokenizes each name/value pair for a valid query string.
# ID: 1206
[^(\&)](\w*)+(\=)[\w\d ]*

# It matches an IP address only in the correct format. There was a previous regex send which matches 192.168.01.2 but this code won't match preceeding 0's
# ID: 1462
/^(?:(?:1\d?\d|[1-9]?\d|2[0-4]\d|25[0-5])\.){3}(?:1\d?\d|[1-9]?\d|2[0-4]\d|25[0-5])$/

# www.irctc.co.in
# ID: 2144
BV_SessionID=@@@@0106700396.1206001747@@@@&BV_EngineID=ccckadedjddehggcefecehidfhfdflg.0

# Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm.  You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.
# ID: 390
^((\d{2}(([02468][048])|([13579][26]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|([1-2][0-9])))))|(\d{2}(([02468][1235679])|([13579][01345789]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\s(((0?[1-9])|(1[0-2]))\:([0-5][0-9])((\s)|(\:([0-5][0-9])\s))([AM|PM|am|pm]{2,2})))?$

# This regex will match SQL Server datetime values, allowing date only, allowing zero padded digits in month, day and hour, and will match leap years from 1901 up until 2099.
# ID: 376
^((((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|([1-2][0-9]))))[\-\/\s]?\d{2}(([02468][048])|([13579][26])))|(((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))[\-\/\s]?\d{2}(([02468][1235679])|([13579][01345789]))))(\s(((0?[1-9])|(1[0-2]))\:([0-5][0-9])((\s)|(\:([0-5][0-9])\s))([AM|PM|am|pm]{2,2})))?$

# Just a quick list of all the United States 50 States Full Names (Not Abbreviations)
# ID: 3007
qr/(Alabama|Alaska|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|Florida|Georgia|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New\sHampshire|New\sJersey|New\sMexico|New\sYork|North\sCarolina|North\sDakota|Ohio|Oklahoma|Oregon|Pennsylvania|Rhode\sIsland|South\sCarolina|South\sDakota|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West\sVirginia|Wisconsin|Wyoming)/

# This expression matches valid image URLs. The main use for this would be in UBBC tags.
# ID: 819
((ht|f)tp(s?))(:((\/\/)(?!\/)))(((w){3}\.)?)([a-zA-Z0-9\-_]+(\.(com|edu|gov|int|mil|net|org|biz|info|name|pro|museum|co\.uk)))(\/(?!\/))(([a-zA-Z0-9\-_\/]*)?)([a-zA-Z0-9])+\.((jpg|jpeg|gif|png)(?!(\w|\W)))

# capture labels having format yyyy.mm.dd.nn here nn is for number s from 00 to 99
# ID: 1524
^(\d{4})[.](0{0,1}[1-9]|1[012])[.](0{0,1}[1-9]|[12][0-9]|3[01])[.](\d{2})$

# Brazilian phone area code
# ID: 2431
^[1-9]\d$

# Brazilian salary format between 0 and ten thousand with two decimal places
# ID: 2422
^(\d{1}\.){0,1}\d{1,3}\,\d{2}$

# This is just a simple US states and territories in 2 character regex. Requires valid 2 letter abbreviations. It accepts the Lower and Upper Case Entries.
# ID: 3078
^([Aa][LKSZRAEPlkszraep]|[Cc][AOTaot]|[Dd][ECec]|[Ff][LMlm]|[Gg][AUau]|[Hh][Ii]|[Ii][ADLNadln]|[Kk][SYsy]|[Ll][Aa]|[Mm][ADEHINOPSTadehinopst]|[Nn][CDEHJMVYcdehjmvy]|[Oo][HKRhkr]|[Pp][ARWarw]|[Rr][Ii]|[Ss][CDcd]|[Tt][NXnx]|[Uu][Tt]|[Vv][AITait]|[Ww][AIVYaivy])$

# this is usefull for Series of Vehicle Number of Indian Transport
# ID: 2878
^([A-Z]{2}\s?(\d{2})?(-)?([A-Z]{1}|\d{1})?([A-Z]{1}|\d{1}))$

# Ex.- RJ21-CA 1232
# ID: 2879
^([A-Z]{2}\s?(\d{2})?(-)?([A-Z]{1}|\d{1})?([A-Z]{1}|\d{1})?( )?(\d{4}))$

# Let's say that you have a series of characters "abcde" and you want to match all strings that could be comprised of those characters with each character used exactly once.  This could loosely be termed an anagram matcher, although if the string contains duplicate letters it would require modification of this pattern.  In the example case we have a string "abcde" and we want to match any permutation of "abcde".  Note that the "5" used in the pattern indicates the number of characters specified in the character set "abcde", "5" would still be used if "abcde" would be replaced with "a-e" since there would still be 5 characters in the series.  If you are curious about how to require duplicates in the pattern (to match all permutations of "apple" for example) I would use (?=^.*p.*p$)(?!.*([ale]).*\1)^[aple]{5}$
# ID: 2006
(?!.*([abcde]).*\1)^[abcde]{5}$

# Given that you have a string that is comprised characters/words separated by spaces and you want to creates matches of those words/characters but you also have substring groups of words/characters/spaces enclosed in [] and "" that you want treated as a single match, this pattern is what worked for me.  Feel free to modify this regex to fit your needs if your string groups are not grouped by [] or "".  Please let me know if this doesn't test well for you. ********** Example Test String:
# ID: 1791
\S*?[\["].*?[\]"]|\S+

# It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. ***Importnat*** This pattern assumes that the input is a valid IP address. You many need to make sure the input is a valid IP address.
# ID: 1667
(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^127\.0\.0\.1)

# Usefull for SQL update and insert sentence..
# ID: 842
(((0[1-9]|[12][0-9]|3[01])([.])(0[13578]|10|12)([.])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([.])(0[469]|11)([.])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([.])(02)([.])([1-2][0,9][0-9][0-9]))|((29)(\.|-|\/)(02)([.])([02468][048]00))|((29)([.])(02)([.])([13579][26]00))|((29)([.])(02)([.])([0-9][0-9][0][48]))|((29)([.])(02)([.])([0-9][0-9][2468][048]))|((29)([.])(02)([.])([0-9][0-9][13579][26])))

# Exact match all the .ccTLD .gTLD and .gTLD.ccTLD names
# ID: 2152
^(http:\/\/)?(www\.)?[a-z0-9][a-z0-9-]{0,61}[a-z0-9](?<gTLD>\.(biz|com|edu|gov|info|int|mil|name|net|org|aero|asia|cat|coop|jobs|mobi|museum|pro|tel|travel|arpa|root))?(?(gTLD)(\.(a[c-gil-oq-uwxz]|b[abd-jmnorstvwyz]|c[acdf-ik-oruvxyz]|d[ejkmoz]|e[ceghrstu]|f[ijkmor]|g[abd-ilmnp-tuwy]|h[kmnrtu]|i[delmnoq-t]|j[emop]|k[eghimnprwyz]|l[abcikr-uvy]|m[acdeghk-z]|n[acefgilopruzc]|om|p[ae-hk-nrstwy]|qa|r[eosuw]|s[a-eg-ortuvyz]|t[cdfghj-prtvwz]|u[agksyz]|v[aceginu]|w[fs]|y[etu]|z[amw]))?|(\.(a[c-gil-oq-uwxz]|b[abd-jmnorstvwyz]|c[acdf-ik-oruvxyz]|d[ejkmoz]|e[ceghrstu]|f[ijkmor]|g[abd-ilmnp-tuwy]|h[kmnrtu]|i[delmnoq-t]|j[emop]|k[eghimnprwyz]|l[abcikr-uvy]|m[acdeghk-z]|n[acefgilopruzc]|om|p[ae-hk-nrstwy]|qa|r[eosuw]|s[a-eg-ortuvyz]|t[cdfghj-prtvwz]|u[agksyz]|v[aceginu]|w[fs]|y[etu]|z[amw])))$

# Validates WII Wifi friend codes
# ID: 2861
(?:[0-9]{4}-){3}[0-9]{4})

# This is used to validate a word count of input with an asp.net RegularExpressionValidator.
# ID: 1542
(((^\s*)*\S+\s+)|(\S+)){1,5}

# This expression can be used to parse Yahoo search results.
# ID: 2263
(<div\sclass="res(\sindent)?">.*?)(<a\s.*?href="(?<URL>.*?)".*?>)(?<Title>.*?</div>)((?<Abstract><div\sclass="abstr">.*?</div>)(?<greenURL><span\sclass=url>.*?</span>).*?</div>)

# Parse CSV.
# ID: 1251
((?<=,\s*\")([^\"]*|([^\"]*\"\"[^""]*\"\"[^\"]*)+)(?=\"\s*,))|((?<=,)[^,\"]*(?=,))

# Dutch zipcode. The non-matching code does not match because lettercombinations SS, SA and SD are not allowed. (historic reasons ?).
# ID: 1669
^[1-9][0-9]{3}[ ]?(([a-rt-zA-RT-Z]{2})|([sS][^dasDAS]))$

# Find http:// urls.
# ID: 3159
http://\([a-zA-Z0-9_\-]\+\(\.[a-zA-Z0-9_\-]\+\)\+\)\+:\?[0-9]\?\(/*[a-zA-Z0-9_\-#]*\.*\)*?\?\(&*[a-zA-Z0-9;_+/.\-%]*-*=*[a-zA-Z0-9;_+/.\-%]*-*\)*

# I needed an expression to allow only a 10 digit number to be entered. No () or dashes or spaces. Cisco IP phones only like the 10 digit number. So here's what I came up with. Very short and simple!
# ID: 3673
^\d{10}$

# Arabic Word only or Null String
# ID: 3437
^[\u0600-\u06ff\s]+$|[\u0750-\u077f\s]+$|[\ufb50-\ufc3f\s]+$|[\ufe70-\ufefc\s]+$|^$

# Number Begin Specfic Number 5 or 6 and Lenght 8 or Null string
# ID: 3438
^[5,6]\d{7}|^$

# This will match all LOWERCASE French Characters encoded in !!!UTF-8 ONLY!!!
# ID: 2663
[a-zà-ïò-öù-ü]+$

# This regex will match any price, what so ever, if it's uses a comma as a 1000 seperator, or a dot, and if it uses comma as a decimal seperator or a dot, or if it do not use any seperator what so ever.
# ID: 1545
\d[\d\,\.]+

# This expression is pretty simple. It validates for mobile phone numbers in mainland China. I needed phone numbers in a certain format for use with an SMS gateway. The formatting is rather strict.
# ID: 3313
^(\+86)(13[0-9]|145|147|15[0-3,5-9]|18[0,2,5-9])(\d{8})$

# Mathes all mobile and landline numbers in pakistan
# ID: 2894
^(\+)?([9]{1}[2]{1})?-? ?(\()?([0]{1})?[1-9]{2,4}(\))?-? ??(\()?[1-9]{4,7}(\))?$

# Matches the Canadian postal code with or without space between.
# ID: 2654
^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\d{1}[A-Za-z]{1}[ ]{0,1}\d{1}[A-Za-z]{1}\d{1}$

# It checks for Valid US Phone numbers.
# ID: 245
^([0-1]([\s-./\\])?)?(\(?[2-9]\d{2}\)?|[2-9]\d{3})([\s-./\\])?(\d{3}([\s-./\\])?\d{4}|[a-zA-Z0-9]{7})$

# USA Alhpanumeric Valid Phone numbers
# ID: 246
^([0-1]([\s-./\\])?)?(\(?[2-9]\d{2}\)?|[2-9]\d{3})([\s-./\\])?([0-9]{3}([\s-./\\])?[0-9]{4}|[a-zA-Z0-9]{7}|([0-9]{3}[-][a-zA-Z0-9]{4}))

# FAA Tail Numbers as described here: http://www.faa.gov/licenses_certificates/aircraft_certification/aircraft_registry/special_nnumbers/
# ID: 1789
^N[1-9][0-9]{0,4}$|^N[1-9][0-9]{0,3}[A-Z]$|^N[1-9][0-9]{0,2}[A-Z]{2}$

# Only matches a single format
# ID: 2410
^\([0-9]{3}\)[0-9]{3}(-)[0-9]{4}

# Validated date in the following format: MM/DD/YY from 1900 to 2999
# ID: 2175
((0[1-9])|(1[0-2]))\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))/\(([1][9][0-9][0-9])|([2][0-9][0-9][0-9])))

# This validates Man Hour values in projects
# ID: 2522
^\d*\.?(((5)|(0)|))?$

# Matches all positive decimal floating negative/non-negative numbers. Allows empty string.
# ID: 737
^(\-)?\d*(\.\d+)?$

# Quebra um endereço em TIPO LOGRADOURO, ENDERECO, NÚMERO e COMPLEMENTO.
# ID: 2993
^(?<tipo>.{1,3})\s+(?<endereco>.+),\s+(?<numero>\w{1,10})\s*(?<complemento>.*)$

# Matches MIME Media Types, often to be seen in HTTP
# ID: 807
# Multiline
^(?<toplevel>[a-z]+)/(?<subtype>[a-z]+)(\+(?<formattype>[a-z]+))?(; *?charset="?(?<charset>[a-z0-9\-]+)"?)?$

# Select File Accept Arabic and Englesh File name or Folder name
# ID: 2094
^[a-zA-Z]:\\(([\w]|[\u0621-\u064A\s])+\\)+([\w]|[\u0621-\u064A\s])+(.jpg|.JPG|.gif|.GIF|.BNG|.bng)$

# regex to validate unix device names (linux). useful for scripts using ifconfig or stuff
# ID: 995
^(eth[0-9]$)|(^eth[0-9]:[1-9]$)

# Url matching
# ID: 1042
\b([\d\w\.\/\+\-\?\:]*)((ht|f)tp(s|)\:\/\/|[\d\d\d|\d\d]\.[\d\d\d|\d\d]\.|www\.|\.tv|\.ac|\.com|\.edu|\.gov|\.int|\.mil|\.net|\.org|\.biz|\.info|\.name|\.pro|\.museum|\.co)([\d\w\.\/\%\+\-\=\&\?\:\\\"\'\,\|\~\;]*)\b

# Used for matching measurement expressions with or without scientific notation, with or without a list of known prefixes, and with an option component of a unit. Known limitations include that a measurement term cannot lack a prefix and also start with a letter that could be mistaken for a prefix. For instance, "5 m" is parsed as 5 with a prefix of m, not 5 with a base prefix and a unit of m.
# ID: 1402
(?<value>([\+-]?((\d*\.\d+)|\d+))(E[\+-]?\d+)?)( (?<prefix>[PTGMkmunpf])?(?<unit>[a-zA-Z]+)?)?

# A simple regex which should validate a domain name according to RFC 1035
# ID: 1021
^[a-z]+([a-z0-9-]*[a-z0-9]+)?(\.([a-z]+([a-z0-9-]*[a-z0-9]+)?)+)*$

# Matches Excel's A1 reference style.  Single Cell, absolute, reletive, mixed, whole row, whole column.  Validates it all.
# ID: 2780
^\$?(?(?=[0-9])[0-9]{1,5}:\$?[0-9]{1,5}|[A-Za-z]{1,2}(?(?=:):\$?[A-Za-z]{1,2}|(?(?!(\$?[0-9])):/$[A-Za-z]{1,2}|\$?[0-9]{1,5})(?(?=:):\$?[A-Za-z]{1,2}\$?[0-9]{1,5}|.)))

# Matches 99.99% of e-mail addresses (excludes IP e-mails, which are rarely used).  The {2,7} at the end leaves space for top level domains as short as .ca but leaves room for new ones like .museum, etc.  The ?: notation is a perl non-capturing notation, and can be removed safely for non-perl-compatible languages.  See also email.
# ID: 192
^[\w-]+(?:\.[\w-]+)*@(?:[\w-]+\.)+[a-zA-Z]{2,7}$

# 7 alphanumeric
# ID: 2075
(?=^.{7,51}$)([A-Za-z]{1})([A-Za-z0-9!@#$%_\^\&\*\-\.\?]{5,49})$

# Regex for valid folder name.
# ID: 3617
^[^\\/:*?""<>|.][^\\/:*?""<>|]*(?<!\.)(^[^\\/:*?""<>|]|$)|^$

# This regular expressions matches dates of the form dd/MMM/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long.
# ID: 1907
^(([0-9])|([0-2][0-9])|([3][0-1]))\/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\/\d{4}$

# Matches dates in the form of DD/MMM/YYYY.  It also handles leap years.  Days are 2 digits; months are case sensitive with first character upper-case and next 2 characters lower-case; year is 4 digits.
# ID: 1920
^(?:((31\/(Jan|Mar|May|Jul|Aug|Oct|Dec))|((([0-2]\d)|30)\/(Jan|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))|(([01]\d|2[0-8])\/Feb))|(29\/Feb(?=\/((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))\/((1[6-9]|[2-9]\d)\d{2})$

# WINDOWS ONLY
# ID: 1190
(?<=(?:\\))[a-zA-Z0-9\-\s_]*(?=(?:\.\w*$))

# Replace with:
# ID: 3337
/#([1-9]){2}([1-9]){2}([1-9]){2}/

# Very simple (but very useful!) regex to split CSV files.  It does not drop the commas - you have to do that manually.  Quotes are dealt with properly and escaped quotes are ignored.  Matches from sample:this is ;a;"line,\"in\"a";csv;file
# ID: 1197
((?:[^",]|(?:"(?:\\{2}|\\"|[^"])*?"))*)

# Used to replace lone ampersands in query strings with their &amp; counterparts.
# ID: 1198
&(?!amp;)

# This allows you to validate first names and last names in seperate fields.  Instead of validating a full name in one field.
# ID: 522
^[a-zA-Z]+(([\'\,\.\-][a-zA-Z])?[a-zA-Z]*)*$

# Validates on the following standards:
# ID: 530
^([\+][0-9]{1,3}[\.][0-9]{1,12})([x]?[0-9]{1,4}?)$

# valid values are du or gu or tu or ds or gs or da or ga or
# ID: 696
[du]{2}|[gu]{2}|[tu]{2}|[ds]{2}|[gs]{2}|[da]{2}|[ga]{2}|[ta]{2}|[dq]{2}|[gq]{2}|[tq]{2}|[DU]{2}|[GU]{2}|[TU]{2}|[DS]{2}|[GS]{2}|[DA]{2}|[GA]{2}|[TA]{2}|[DQ]{2}|[GQ]{2}|[TQ]{2}

# Multi-line mode.
# ID: 2471
$(\n|\r\n)

# It does not work in sentences with abbreviations.
# ID: 2472
\.\s|$(\n|\r\n)

# Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number
# ID: 3169
\b(1(?!27\.0\.0\.1)\d{1,2}|2[0-4][0-9]|25[0-4]|\d{1,2})\.(?:\d{1,3}\.){2}(25[0-5]|2[0-4][0-9]|1\d{2}|\d{2}|[1-9])\b

# This expression is ideal used for "identifying some plain application configuration files that contain any form of MSSQL database/instance reference in connection string". Dose not match .\sql. [\\""=/] can be removed on both ends to seach server/instance in text files, but with it, it has better accuracy
# ID: 3170
[\\""=:;,](([\w][\w\-\.]*)\.)?([\w][\w\-]+)(\.([\w][\w\.]*))?\\sql\d{1,3}[\\""=:;,]

# This expression is ideal used for "identifying some plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning".
# ID: 3167
[\\""=/>](25[0-4]|2[0-4][0-9]|1\d{2}|\d{2})\.((25[0-4]|2[0-4][0-9]|1\d{2}|\d{1,2})\.){2}(25[0-4]|2[0-4][0-9]|1\d{2}|\d{2}|[1-9])\b[\\""=:;,/<]

# Building on Joe Lynwood's Regex which makes use of a combination of Michael Ash's US Dollar amount and Bri Gipson's eliminating zero input, I've added support for values between 0 and 1. Being relatively new to regex, I hope someone would be able to spot any discrepancies with the code and its supposed function.
# ID: 1598
^(([1-9]\d{0,2}(\,\d{3})*|([1-9]\d*))(\.\d{2})?)|([0]\.(([0][1-9])|([1-9]\d)))$

# hhmmsscc hh=hours [00-24], mm = minutes[00-59], ss=seconds [00-59] where cc is a hundredth of a second [00-99]
# ID: 1318
^([01]\d|2[0123])([0-5]\d){2}([0-99]\d)$

# Matches against a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowed
# ID: 2923
^\d{8,8}$|^[SC]{2,2}\d{6,6}$

# It Accepts hyphen in the domain name
# ID: 2669
^\w*[-]*\w*\\\w*$

# Matches a string if it is a valid time in the format of HH:MM
# ID: 2514
^(([0-1]?[0-9])|([2][0-3])):([0-5][0-9])$

# Matches 24 hour time format.
# ID: 722
^(([1-9]{1})|([0-1][0-9])|([1-2][0-3])):([0-5][0-9])$

# Matches 12 hour time format
# ID: 723
^(([1-9]{1})|([0-1][1-2])|(0[1-9])|([1][0-2])):([0-5][0-9])(([aA])|([pP]))[mM]$

# Matches a file extention.
# ID: 781
\.txt$

# Matches against the two character country abbreviations (as of 2010).
# ID: 3195
^(?-i:A[DEFGILMNOQRSTUWZ]|B[ABDEFGHIJMNORSTVWYZ]|C[ACDFGHIKLMNORSUVXYZ]|D[EJKMOZ]|E[CEGHRST]|F[IJKMOR]|G[ABDEFHILMNPQRSTUWY]|H[KMNRTU]|I[DELNOQRST]|J[MOP]|K[EGHIMNPRWYZ]|L[ABCIKRSTUVY]|M[ACDGHKLMNOPQRSTUVWXYZ]|N[ACEFGILOPRUZ]|O[M]|P[AEFGHKLMNRSTWY]|QA|R[EOUW]|S[ABCDEGHIJKLMNORTVYZ]|T[CDFGHJKLMNORTVWZ]|U[AGMSYZ]|V[ACEGINU]|W[FS]|Y[ET]|Z[AMW])$

# Inspired by Dalibor Kalna's regexp, this one accepts numbers with the dot as required thousands separator, comma as decimal separator, and exactly digits after the comma. Minus as sign is optional.
# ID: 3158
^-?\d{1,3}\.(\d{3}\.)*\d{3},\d\d$|^-?\d{1,3},\d\d$

# An email that should work in accordance to the RFC standard (see http://en.wikipedia.org/wiki/Email_address#Syntax)
# ID: 3218
^(([A-Za-z0-9\!\#\$\%\&\'\*\+\-\/\=\?\^_\`\{\|\}\~]+\.*)*[A-Za-z0-9\!\#\$\%\&\'\*\+\-\/\=\?\^_\`\{\|\}\~]+@((\w+\-+)|(\w+\.))*\w{1,63}\.[a-zA-Z]{2,6})$

# Match the full names of the four main characters of The Flintstones.
# ID: 1006
^((Fred|Wilma)\s+Flintstone|(Barney|Betty)\s+Rubble)$

# match all script blocks in html file or aspx file.
# ID: 2828
\<script[^>]*>[\w|\t|\r\|\W]*?</script>

# For who use a space as thousands separator like french, deutsch ....
# ID: 745
(^(((\d)|(\d\d)|(\d\d\d))(\xA0|\x20))*((\d)|(\d\d)|(\d\d\d))([,.]\d*)?$)

# It is an expression to valide a french numéro de sécurité social (social security number translate is not sure) with or without the key.
# ID: 846
^((\d(\x20)\d{2}(\x20)\d{2}(\x20)\d{2}(\x20)\d{3}(\x20)\d{3}((\x20)\d{2}|))|(\d\d{2}\d{2}\d{2}\d{3}\d{3}(\d{2}|)))$

# [Default]
# ID: 1194
^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)+$

# finds the url and url description for all links in a given text.
# ID: 1037
href\s*=\s*(?:(?:\"(?<url>[^\"]*)\")|(?<url>[^\s*] ))>(?<title>[^<]+)</\w>

# Match the content of any regular tag/s
# ID: 415
<(?<tag>.*).*>(?<text>.*)</\k<tag>>

# This expression bypasses an infinite-backtracking bug by looking ahead in the current line for any non-whitespace, then matching to the end of the line if the lookahead was positive. Without the lookahead, you'll end up with an infinine backtracking expression and a bad day.
# ID: 1519
(^(?=.*\S).*\n)*

# Matches a string representation of a Guid, regardless of case, and does the correct brace matching
# ID: 3112
^(?<BRACE>\{)?[a-fA-F\d]{8}-(?:[a-fA-F\d]{4}-){3}[a-fA-F\d]{12}(?<-BRACE>\})?(?(BRACE)^.)$

# According to NANPA (North American Numbering Plan Administration): The format of an area code is NXX, where N is any digit 2 through 9 and X is any digit 0 through 9.  N11 are ERCs, called service codes, and are not used as area codes.  This regex checks for these conditions.  However, this regex does not check for N9X which are reserved for expansion in the future nor 37X or 96X which are also reserved for potential expansion in the future.
# ID: 1492
^[2-9]{1}[0-9]{1}((?<!1)[1]|[0]|[2-9]){1}\b

# Regular expression to validate Persian(Jalali) date, that supports days in month except isfand(espand) in leap years
# ID: 3262
^[1-4]\d{3}\/((0?[1-6]\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\/(30|([1-2][0-9])|(0?[1-9]))))$

# Time, which reg express is very simple to use :)
# ID: 2399
^((0[1-9]|1[0-9]|2[0-4])([0-5]\d){2})$

# International phone number check - optional country code followed by area code surrounded with '-' or '(' and ')', or just an area code optionally starting with 0, followed by phone numder. The number itself may contain spaces and '-'
# ID: 296
^(\+[1-9][0-9]*(\([0-9]*\)|-[0-9]*-))?[0]?[1-9][0-9\- ]*$

# Most RegExpr for dutch zip codes are too simple. For historic reasons, the two-letter combinations SS, SA and SD are not allowed.
# ID: 3255
[1-9][0-9]{3}[ ]?(([a-rt-zA-RT-Z][a-zA-Z])|([sS][bce-rt-xBCE-RT-X]))

# This pattern returns the font section from an RTF document. The first parenthetical subexpression captures the font number, the second returns the actual font enumeration. Lame-o, but fun! :-)
# ID: 219
(\{\\f\d*)\\([^;]+;)

# Street Address. While far from perfect it validates street addresses reasonably. Created with absolutely no experience using a cool tool downloaded from http://www.codeproject.com/dotnet/expresso.asp?target=e%20xpresso
# ID: 430
\d{1,3}.?\d{0,3}\s[a-zA-Z]{2,30}\s[a-zA-Z]{2,15}

# Matches class ids (CLSID) including the pre & post curly brackets.
# ID: 3118
^\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\}$

# This regex validates time strings to ensure they're in the format HH:MM:SS. It accepts from 1:00:00-12:59:59
# ID: 3165
^(0?[1-9]|1[0-2])(\:)([0-5][0-9])(\:)([0-5][0-9]) (AM|PM)$

# Accepts dates in the format MM/DD/YYYY. Month and day can have preceeding 0 if less than 10, year is 1900-9999 and months accept 30/31 days appropriately. February accepts 29 (leap year not factored in).
# ID: 3166
^((0?[2])/(0?[1-9]|[1-2][0-9])|(0?[469]|11)/(0?[1-9]|[1-2][0-9]|30)|(0?[13578]|1[02])/(0?[1-9]|[1-2][0-9]|3[0-1]))/([1][9][0-9]{2}|[2-9][0-9]{3})$

# Matches U.S. and Canadian phone numbers, without punctuation, that follow the NANP numbering scheme.
# ID: 3133
^[2-9][0-8]\d[2-9]\d{6}$

# Matches U.S. and Canadian postal codes that follow the proper numbering schemes.
# ID: 3134
^((\d{5})|(\d{5}-\d{4})|([A-CEGHJ-NPR-TV-Z]\d[A-CEGHJ-NPR-TV-Z]\s\d[A-CEGHJ-NPR-TV-Z]\d))$

# This regex accepts date and time values, taking into account 29/30/31 day months. 00 hours (midnight) must have both zeros, but hours 01-09 can leave 0 off, months 1-9 can also leave 0 off.
# ID: 3173
^((0?[2])/(0?[1-9]|[1-2][0-9])|(0?[469]|11)/(0?[1-9]|[1-2][0-9]|30)|(0?[13578]|1[02])/(0?[1-9]|[1-2][0-9]|3[0-1]))/([1][9][0-9]{2}|[2-9][0-9]{3}) (00|0?[1-9]|1[0-9]|2[0-3])\:([0-5][0-9])\:([0-5][0-9])$

# This regex accepts time in 24-hour format (00:00:00 - 23:59:59). Hours 01-09 can leave the 0 off, but 00 has to have both zeros.
# ID: 3174
^(00|0?[1-9]|1[0-9]|2[0-3])\:([0-5][0-9])\:([0-5][0-9])$

# This works good for account names where u don't want your users to create ugly account names. 3 rules apllied in it:
# ID: 844
^([A-Z]|[a-z]|[0-9])([A-Z]|[a-z]|[0-9]|([A-Z]|[a-z]|[0-9]|(%|&|'|\+|\-|@|_|\.|\ )[^%&'\+\-@_\.\ ]|\.$|([%&'\+\-@_\.]\ [^\ ]|\ [%&'\+\-@_\.][^%&'\+\-@_\.])))+$

# Simple 12 hour time, no am pm added, no 24 hour clock, 1 or 2 digits for hour.
# ID: 1469
^([1-9]|0[1-9]|1[0-2]):([0-5][0-9])$

# The Panamanian "cedula" is the equivalent of the USA's Social Security Number or the Dutch SOFI number. It is composed of three groups. The 2nd and 3rd groups are digits only. The first group  typically has a number between 1-10 only. But in some cases it has N (naturalized) or E (foreigner) or PE (panamanian born abroad). And in some ocassions a number followed by AV meaning the person was born before the "cedula" system came into existence..
# ID: 1712
^(?<prov>10)(?<tipo>(AV))?-(?<tomo>\d{1,4})-(?<folio>\d{1,5})|^(?<prov>[1-9])(?<tipo>(AV))?-(?<tomo>\d{1,4})-(?<folio>\d{1,5})|^(?<tipo>(E|N|PE))-(?<tomo>\d{1,4})-(?<folio>\d{1,5})

# Regular expression to limit types of files accepted. This example matches .jpg and .gif files only.
# ID: 1075
^([a-zA-Z].*|[1-9].*)\.(((j|J)(p|P)(g|G))|((g|G)(i|I)(f|F)))$

# checks all valid email id's
# ID: 1568
^[a-zA-Z][\w\.-]*[a-zA-Z0-9]@[a-zA-Z0-9][\w\.-]*[a-zA-Z0-9]\.[a-zA-Z][a-zA-Z\.]*[a-zA-Z]$

# phone
# ID: 3146
\\(?(\\d{4})\\)?[- ]?(\\d{5})[- ]?(\\d{6})

# I needed to have a way where users could type in any date format like the following:  mm/dd/yyyy, mm/dd/yy, mmddyy, mmddyyyy with the ability to use "/" and "." and "-" or nothing as separation characters.  I use this in a RegularExpression Validator control in ASP.NET
# ID: 2635
\b(((0[13578]|1[02])[\/\.-]?(0[1-9]|[12]\d|3[01])[\/\.-]?(19|20)?(\d{2}))|(0[13456789]|1[012])[\/\.-]?(0[1-9]|[12]\d|30)[\/\.-]?(19|20)?(\d{2}))|(02[\/\.-]?(0[1-9]|1\d|2[0-8])[\/\.-]?(19|20)?(\d{2}))|(02[\/\.-]?29[\/\.-]?(19|20)?((0[48]|[2468][048]|[13579][26])|(00)))\b

# This is used to match the values that are multiples of 0.5 upto single digit decimal number.
# ID: 1823
(^\d{1,3}$)|(\d{1,3})\.?(\d{0,0}[0,5])

# to get the text betwwen double quotes
# ID: 2661
"([^\\"]|\\.)*"

# count the space and new line character also .. pass first parameter for minimun and next for maximum character
# ID: 2553
(.|[\r\n]){1,5}

# This expression can be use to define the maximum length to a textBox.
# ID: 2358
^(.|\r|\n){1,10}$

# You can use this to check the valid file type you have given to the last in the expression
# ID: 2334
^(([a-zA-Z]:)|(\\{2}\w+)\$?)(\\(\w[\w].*))+(.pdf)$

# This expression will only allow the .jpg and .gif file to get uploaded.
# ID: 3294
\.(?i:)(?:jpg|gif)$

# To accept only charactes only for both the cases i.e the Upper Case and the Lower Case
# ID: 3296
/[a-zA-Z]/

# To find a match pattern in a string not matter where the position of the pattern in the string and even no matter what is the suffix and what will be the prefix.
# ID: 3636
([Cc][Hh][Aa][Nn][Dd][Aa][Nn].*?)

# To check a valid IP Address. It will check the valid IP address on the logic of three dots max three digits in each section
# ID: 3645
\b(?:\d{1,3}\.){3}\d{1,3}\b

# This will validate a match for a number having no zero
# ID: 3648
[0-9]*\.?[0-9]*[1-9]

# For a WHOLE number in a text box greater than ZERO. Can start with a Zero, contain Zero in between and end with zero
# ID: 3649
^\d*[1-9]\d*$

# This Regular Expression Pattern can be used to replace any special character in a string by any other specific character or string.
# ID: 3467
['`~!@#&$%^&*()-_=+{}|?><,.:;{}\"\\/\\[\\]]

# SqlServer seems to throw an error when using higher than e308 for e-309 it just makes the value = 0. Either way, this regexp seems to work for me. and allows for empty string as well. To negate the empty string pass through in asp.net just add a required field validator--if your already program asp.net you probably already know that though : ) .
# ID: 1706
^(([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?([12]?\d\d?|30[0-8])))?)?$

# This regular expression matches on postive whole numbers and 0.  Whole numbers that are left padded with 0's are not a match.
# ID: 496
^(0)$|^([1-9][0-9]*)$

# Integer with or without commas.  Signed or unsigned.
# ID: 2265
^[-|\+]?[0-9]{1,3}(\,[0-9]{3})*$|^[-|\+]?[0-9]+$

# This phone pattern matches all New Zealand phone numbers with formatting and returns a single formatted string as the first return in the array. Does not take into account all specific exclusions, though, in case of changes (like 025 to 027 in 2007). Based off of  CGRdevelopment's New Zealand regex.
# ID: 2188
^(((\+?64\s*[-\.]?[3-9]|\(?0[3-9]\)?)\s*[-\.]?\d{3}\s*[-\.]?\d{4})|((\+?64\s*[-\.\(]?2\d{1}[-\.\)]?|\(?02\d{1}\)?)\s*[-\.]?\d{3}\s*[-\.]?\d{3,5})|((\+?64\s*[-\.]?[-\.\(]?800[-\.\)]?|[-\.\(]?0800[-\.\)]?)\s*[-\.]?\d{3}\s*[-\.]?(\d{2}|\d{5})))$

# CSS Length Unit Regex for cm, mm, in, pt (not px, ex, em)
# ID: 756
# Multiline
^\s*(?<signedNumber>(\+|\-){0,1}((\d*(\.\d+))|(\d*)){1})(?<unit>((in)|(cm)|(mm)|(pt)){0,1})\s*$

# Capture the information from a SQL Server connection string
# ID: 2364
Password=(?<Password>.*);.*=(?<Info>.*);.*=(?<User>.*);.*=(?<Catalog>.*);.*=(?<Data>.*)

# This expression filters all variations of Post Office Box or PO Box.
# ID: 704
# Multiline
(^(p[\s|\.|,]*|^post[\s|\.]*)(o[\s|\.|,]*|office[\s|\.]*))|(^box[.|\s]*\d+)

# This regex enable the user to enter all valid email addresses apart from when the user input 'co.uk' immediately after the '@' without stating a domain before it (e.g. 'freeserve.co.uk')
# ID: 2218
^[_a-zA-Z0-9-]+(\.[_a-zA-Z0-9-]+)*@(?!co.uk)[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|coop|info|museum|name))$

# Validate a date according to the ISO 8601 standard (no time part) considering long-short months to allow 31st day of month and leap years to allow 29th February. I took Ted Cambron's implementation, simplified and added support for leap years and long-short months.
# ID: 3344
^(?:(?=[02468][048]00|[13579][26]00|[0-9][0-9]0[48]|[0-9][0-9][2468][048]|[0-9][0-9][13579][26])\d{4}(?:(-|)(?:(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])|(?:01|03|05|07|08|10|12)(?:\1(?:0[1-9]|[12][0-9]|3[01]))?|(?:04|06|09|11)(?:\1(?:0[1-9]|[12][0-9]|30))?|02(?:\1(?:0[1-9]|[12][0-9]))?|W(?:0[1-9]|[1-4][0-9]|5[0-3])(?:\1[1-7])?))?)$|^(?:(?![02468][048]00|[13579][26]00|[0-9][0-9]0[48]|[0-9][0-9][2468][048]|[0-9][0-9][13579][26])\d{4}(?:(-|)(?:(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-5])|(?:01|03|05|07|08|10|12)(?:\2(?:0[1-9]|[12][0-9]|3[01]))?|(?:04|06|09|11)(?:\2(?:0[1-9]|[12][0-9]|30))?|(?:02)(?:\2(?:0[1-9]|1[0-9]|2[0-8]))?|W(?:0[1-9]|[1-4][0-9]|5[0-3])(?:\2[1-7])?))?)$

# This is a regular expression for parsing the Easily Parsed LIST Format (EPLF) for the FTP protocol's LIST command. It is based on the description of the format by D. J. Bernstein on http://cr.yp.to/ftp/list/eplf.html ... Remember to set Explicit Capture and Multiline options for this expression. The regex captures the following groups: "id": unique identifier for file/directory, "modified": when the file was last modified, specified in number of seconds, real time, since the UNIX epoch at the beginning of 1970 GMT, "retr": if not empty, a RETR command can be performed on this file, "size": size of file in bytes, "cwd": if not empty, a CWD command can be performed on this directory, "up": if specified, the client may use SITE CHMOD command to change the UNIX permission bits of this file (current permission bits are captured in this group), "name": The name of the file/directory
# ID: 1369
^\+(((i(?'id'.*?))|(m(?'modified'\d+))|(?'retr'r)|(s(?'size'\d+))|(?'cwd'\/)|(up(?'up'\d{3}))),)*\t(?'name'.*?)$

# Allows most formats for entering valid South African mobile / cellular phone numbers.
# ID: 2634
^(\+27|27)?(\()?0?[87][23467](\))?( |-|\.|_)?(\d{3})( |-|\.|_)?(\d{4})

# for validate a email, but with this regex it 's possible : a._-z@a_.....____---.com
# ID: 388
^[a-z0-9][a-z0-9_\.-]{0,}[a-z0-9]@[a-z0-9][a-z0-9_\.-]{0,}[a-z0-9][\.][a-z0-9]{2,4}$

# Regular Expression matches any internet URLs. Used with the replace method it comes in very handy.
# ID: 37
((mailto\:|(news|(ht|f)tp(s?))\://){1}\S+)

# Matches any positive integer (and blank) between 1 and 100 useful for validating input of a percentage, or nothing.
# ID: 1167
^((100)|(\d{0,2}))$

# Finds all local links, but doesnt match on external links.
# ID: 1024
<a\s*.*?href\s*=\s*['"](?!http:\/\/).*?>(.*?)<\/a>

# Expression to validate a date with or without time in standard or 24 hour format with optional milliseconds (01/12/08 23:31:05 or 5/12/1974 11:59 PM).
# ID: 2146
(^0?[1-9]|^1[0-2])\/(0?[1-9]|[1-2][0-9]|3[0-1])\/(19|20)?[0-9][0-9](\s(((0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?)|((0?[0-9]|1[0-2]):[0-5][0-9](:[0-5][0-9])?\s(AM|PM))))?$

# I needed an expression to extract measurements from text to extract steel sizes from product descriptions, and I came up with this.  It will only match on measurements that have complete dimensions (i.e. measurements with foot and inch marks in the positions you'd expect them).  My personal experience required that I also be a little lax and allow measurements such as: .125 (for wall thicknesses and sheet metal thicknesses) with no inch marks.  You can accomplish this by including:
# ID: 1274
(?:(?:(?<Feet>\d+)[ ]*\'){0,1}[ ]*(?<WholeInches>\d*(?![/\w])){0,1}(?:[ ,\-]){0,1}(?<Fraction>\d*\/\d*){0,1}(?<Decimal>\.\d*){0,1}\")|(?:(?<Feet>\d+)[ ]*\'[ ]*){1}

# Regular expression :Finite automata rule
# ID: 2205
^[a-zA-Z]+(\.[a-zA-Z]+)+$

# Validates IP addresses and subnet masks
# ID: 2744
^((2[0-5][0-5]|1[\d][\d]|[\d][\d]|[\d])\.){3}(2[0-5][0-5]|1[\d][\d]|[\d][\d]|[\d])$

# Validates email address
# ID: 2745
^([\w\._-]){3,}\@([\w\-_.]){3,}\.(\w){2,4}$

# validates HTML tags
# ID: 2746
^\<(\w){1,}\>(.){0,}([\</]|[\<])(\w){1,}\>$

# validates jpg/jpeg picture extension
# ID: 2750
^(.)+\.(jpg|jpeg|JPG|JPEG)$

# validate comma separated key/value pair
# ID: 1268
^(\w+=[^\s,=]+,)*(\w+=[^\s,=]+,?)?$

# Finds all *bolded* _underlined_ or *_bolded and underlined_* bits of text in a string.
# ID: 3503
(?:(?:(?<=[\s^,(])\*(?=\S)(?!_)(?<bold>.+?)(?<!_)(?<=\S)\*(?=[\s$,.?!]))|(?:(?<=[\s^,(])_(?=\S)(?!\*)(?<underline>.+?)(?<!\*)(?<=\S)_(?=[\s$,.?!]))|(?:(?<=[\s^,(])(?:\*_|_\*)(?=\S)(?<boldunderline>.+?)(?<=\S)(?:\*_|_\*)(?=[\s$,.?!])))

# Matches California Drivers License Numbers. A Letter followed by 7 Numbers. I have not been able to find a site that shows only the number/letters CA uses, so this will have to do for now.
# ID: 2872
^[A-Z]{1}\d{7}$

# This will accept any 6 digit street address only, with min of two and up to four street names.
# ID: 2873
^\d{1,6}\040([A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,})$|^\d{1,6}\040([A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,})$|^\d{1,6}\040([A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,})$

# Phone Number in (###) ###-#### Format Only
# ID: 2874
\(\d{3}\)\040\d{3}-\d{4}

# Phone Numbers Format (###) ###-#### with only SoCal Area Codes. Use or replace with Area Codes You need.
# ID: 2875
\(714|760|949|619|909|951|818|310|323|213|323|562|626\)\040\d{3}-\d{4}

# Phone Number in ###-###-#### Format Only with Southern California Area Codes. Use or Replace Area Codes
# ID: 2876
714|760|949|619|909|951|818|310|323|213|323|562|626-\d{3}-\d{4}

# Simple 6 digit CA contractors License #
# ID: 2877
\d{6}

# validate a number 5 digits and 2 decimal places allowing zero
# ID: 410
^\d{1,5}(\.\d{1,2})?$

# validates  to 5 digits and 2 decimal places but not allowing zero
# ID: 411
(?!^0*$)(?!^0*\.0*$)^\d{1,5}(\.\d{1,2})?$

# Telephone and Mobile number for the Maltese islands including an optional 00356 for country code
# ID: 3044
/(00356)?(99|79|77|21|27|22|25)[0-9]{6}/g

# Regex to determine query string parameters without an = proceeding it.
# ID: 3379
(?<=[\?&])[^=&]+(?=[&]|$)

# SUMMARY: Very selective email address Regex
# ID: 3022
[a-z0-9]+([-+._][a-z0-9]+){0,2}@.*?(\.(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])\b){1,2}

# Matches HTML image leaf filenames.
# ID: 259
^[0-9A-Za-z_ ]+(.[jJ][pP][gG]|.[gG][iI][fF])$

# To evaluate an amount with or without a dollar sign where the cents are optional.
# ID: 131
^\$?\d+(\.(\d{2}))?$

# This pattern is intended to remove all javascript blocks from a chunk of code.  EDIT: a bug is cutting off additional matches.
# ID: 1210
<script[\s\S]*?</script([\s\S]*?)>

# Matches decimal latitude notation (like that used by Google maps)  Matches -90.000000 through +90.000000 with maximum of 6 decimal places, minimum of 1 decimal place.
# ID: 2736
^(\+|-)?(\d\.\d{1,6}|[1-8]\d\.\d{1,6}|90\.0{1,6})$

# Matches decimal longitude format like that returned by Google maps.  Matches from -180.000000 to +180.000000 with between one and six decimal places.
# ID: 2737
^(\+|-)?(\d\.\d{1,6}|[1-9]\d\.\d{1,6}|1[1-7]\d\.\d{1,6}|180\.0{1,6})$

# This expression mathes all email header items and their values from email source
# ID: 2077
((^(?<property>\S+):)|(\s(?<property>)))(?<value>.*)\n

# GUID Tester. It tests SQL Server GUIDs, which are alphanumeric characters grouped 8-4-4-4-12 (with the dashes). Make sure they don't have the brackets around them before you check them and have fun!
# ID: 55
^[A-Z0-9]{8}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{12}$

# I needed a regex for validating URLs, couldn't find a suitable one, so wrote this, with comments! It matches any valid web URL (Address or IP, with or without protocol), including optional port number, directory path, filname.extension and any paramater pairs.  Hope it helps, even if just to understand expressions easier!
# ID: 1363
(((http|https):\/\/)?(([a-zA-Z0-9]+\.[a-zA-Z0-9\-]+(\.[a-zA-Z]+){1,2})|((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])))+(:[1-9][0-9]*)?)+((\/([a-zA-Z0-9_\-\%\~\+]+)?)*)?(\.([a-zA-Z0-9_]+))?(\?([a-zA-Z0-9_\-]+\=[a-z-A-Z0-9_\-\%\~\+]+)?(\&([a-zA-Z0-9_\-]+\=[a-z-A-Z0-9_\-\%\~\+]+)?)*)?

# Written to test the .NET System.Environment.CommandLine string for the existance of arguments. If a match is found, the command arguments can be extracted by retrieving a MatchCollection and retriving the index "commandstring". Works with local and UNC filepaths.
# ID: 810
"{0,2}(?:(?:\\\\(?:\w+)\\(?:\w+\$?)|(?:[A-Z]):)(?:\\(?:[^\\:*?"'<>|\r\n]+))+|(?:[^\\:*?"'<>|\r\n]+))\.exe"?\ (?<commandstring>(?:[^\r\n]*(?=")|[^\r\n]*))

# I use "preg_match" function on PHP with this expression.
# ID: 2477
^v=spf1[ \t]+[+?~-]?(?:(?:all)|(?:ip4(?:[:][0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})?(?:/[0-9]{1,2})?)|(?:ip6(?:[:]([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})?(?:/[0-9]{1,2})?)|(?:a(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+)?(?:/[0-9]{1,2})?)|(?:mx(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+)?(?:/[0-9]{1,2})?)|(?:ptr(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:exists(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:include(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:redirect(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:exp(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|)(?:(?:[ \t]+[+?~-]?(?:(?:all)|(?:ip4(?:[:][0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})?(?:/[0-9]{1,2})?)|(?:ip6(?:[:]([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})?(?:/[0-9]{1,2})?)|(?:a(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+)?(?:/[0-9]{1,2})?)|(?:mx(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+)?(?:/[0-9]{1,2})?)|(?:ptr(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:exists(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:include(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:redirect(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:exp(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|))*)?$

# This regex matches UK phone numbers in multiple formats, including those that begin with the international dial code and optionally bracket the leading zero of the area code. To match a number must begin with either +44 or 0 and have 9-12 following digits.
# ID: 1430
(((\+44)? ?(\(0\))? ?)|(0))( ?[0-9]{3,4}){3}

# This extracts all the properties from a C#.NET file.
# ID: 820
# Multiline
^public\b\s+?\w+?\s+?(?<propertyname>\w+)[^{]+?{[\s\S]*?get\s*?{[\s\S]*?}[\s\S]*?(?:set??[\s\S]*?{[\s\S]*?})?[\s\S]*?}$

# ASP.NET required field validator control.
# ID: 814
<asp:requiredfieldvalidator(\s*\w+\s*=\s*\"?\s*\w+\s*\"?\s*)+\s*>\s*<\/asp:requiredfieldvalidator>

# Focused on scraping English sentences from HTML/Java (without having to parse).
# ID: 894
\b(((["'/,&%\:\(\)\$\+\-\*\w\000-\032])|(-*\d+\.\d+[%]*))+[\s]+)+\b[\w"',%\(\)]+[.!?](['"\s]|$)

# Validates US phone numbers. Phone number can be delimited with dashes or spaces. Area code can optionally include parentheses. To optionally validate area codes, try this expression.
# ID: 314
^([\(]{1}[0-9]{3}[\)]{1}[ |\-]{0,1}|^[0-9]{3}[\-| ])?[0-9]{3}(\-| ){1}[0-9]{4}$

# DD/MM/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format. Allows MM and DD to be 1 or 2 digits, eg. D/M/YYYY, D/MM/YYYY or DD/M/YYYY
# ID: 3260
^(((0?[1-9]|1\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(0?[1-9]|1[012])/(19|[2-9]\d)\d{2}|0?29/0?2/((19|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$

# Expresion para tipo Money ó Cantidad
# ID: 811
^([1-9]{1}[\d]{0,2}(\,[\d]{3})*(\.[\d]{0,2})?|[1-9]{1}[\d]{0,}(\.[\d]{0,2})?|0(\.[\d]{0,2})?|(\.[\d]{1,2})?)$

# Matches a percentage between 1 and 100. Accepts up to 2 decimal places. No decimal places accepted.
# ID: 3131
^([1-9][0-9]?|100)%$

# More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations.
# ID: 413
^([\(]{1}[0-9]{3}[\)]{1}[\.| |\-]{0,1}|^[0-9]{3}[\.|\-| ]?)?[0-9]{3}(\.|\-| )?[0-9]{4}$

# This will match numbers between 0 and 12.  The 0? at the beginning will allow "01" as a valid match.  This is useful for validation the month only component of a date part.
# ID: 1252
^(0?[1-9]|1[012])$

# This will match numbers in the range 1-31.  This is useful for matching the day component of a datetime part.
# ID: 1253
^([12]?[0-9]|3[01])$

# Will check to ensure the data is between 1850 and 2100.
# ID: 1254
^((18[5-9][0-9])|((19|20)[0-9]{2})|(2100))$

# Parses a decimal number. returns two match groups <sign> and <abs_value>. Accepts empty string.
# ID: 2964
^\s*(?<sign>[+-]?)(?:0*?)(?<abs_value>(?:(?:[1-9]\d*)|0)?(?:(?<=\d)\.|\.(?=\d))(?:(?:(?:\d*[1-9])|0)?)?|(?:(?:[1-9]\d*)|0)?)(?:0*)\s*$

# Validates an email address
# ID: 56
(\w+?@\w+?\x2E.+)

# Plucks the last quote of a Stock from the MSN MoneyCentral WebQuote page for any given stock symbol. The URL of the web page where this RegEx should be applied is:
# ID: 57
Last.*?(\d+.?\d*)

# Password expresion that requires one lower case letter, one upper case letter, one digit, 6-13 length, and no spaces. This is merely an extension of a previously posted expression by Steven Smith (ssmith@aspalliance.com) . The no spaces is new.
# ID: 157
^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s).{4,8}$

# This regex matches all valid, current UK Postcodes, including Girobank and non-geographic postcodes, irrespective of whether they contain a space.  It does not include overseas territories.
# ID: 2268
^(GIR ?0AA|(?:[A-PR-UWYZ](?:\d|\d{2}|[A-HK-Y]\d|[A-HK-Y]\d\d|\d[A-HJKSTUW]|[A-HK-Y]\d[ABEHMNPRV-Y])) ?\d[ABD-HJLNP-UW-Z]{2})$

# Matches a Julian date in the format YYDDD.  Two digit year followed by a number from 1 - 366 indicating the day of the year.
# ID: 534
^([0-9]{2})(00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$

# Its a very flexible time entry regular expression. It can accept all valid combination of time entry
# ID: 1451
^([0-1]?\d|2[0-3])([:]?[0-5]\d)?([:]?|[0-5]\d)?\s?(A|AM|P|p|a|PM|am|pm|pM|aM|Am|Pm)?$

# Allows Canadian, American and UK postal/zip codes. Allowing hyphens, periods, or spaces to separate.
# ID: 342
^(\d{5}((|-)-\d{4})?)|([A-Za-z]\d[A-Za-z][\s\.\-]?(|-)\d[A-Za-z]\d)|[A-Za-z]{1,2}\d{1,2}[A-Za-z]? \d[A-Za-z]{2}$

# Accepts all integers between 0-100
# ID: 2098
^0?[0-9]?[0-9]$|^(100)$

# It is not very strong and I am still working on that. Would like to put it up so that people can help to complete it.
# ID: 2911
^((unit|u|)\s*)?(?<unit>\d*\w?)?(\s+|/)?(?<streetNo>\d+(\-\d+)?)\s+(?<streetName>\w+)\s+(?<streetType>\w+)\s+(?<suburb>\w+(\s+\w+)?)\s+(?<state>\w+)\s+(?<postcode>\d{4})$

# validate both IP V4 and IP V6
# ID: 2623
^\d{1,3}((\.\d{1,3}){3}|(\.\d{1,3}){5})$

# This regular expressions matches dates of the form YYYY/XX/ZZ ,where YYYY is always 4 digits long, XX can be 01 to 12 and ZZ can be 01 to 31
# ID: 1846
^\d{4}(\/|-)([0][1-9]|[1][0-2])(\/|-)([0][1-9]|[1-2][0-9]|[3][0-1])$

# A regular expression that validates the any format of fixed telephone numbers inside Lima - Peru, including an optional extension of at least one number up to four numbers.
# ID: 602
^([2-9])(\d{2})(-?|\040?)(\d{4})( ?|\040?)(\d{1,4}?|\040?)$

# A regular expression that validates the any of the new formats of cellular phones numbers in Peru, allows an optional dash in the middle of the number.
# ID: 603
^([8-9])([1-9])(\d{2})(-?|\040?)(\d{4})$

# Pattern to verify Codice Fiscale Italiano (TIN, Tax Identification Number).
# ID: 3121
^([A-Za-z]{6}[0-9lmnpqrstuvLMNPQRSTUV]{2}[abcdehlmprstABCDEHLMPRST]{1}[0-9lmnpqrstuvLMNPQRSTUV]{2}[A-Za-z]{1}[0-9lmnpqrstuvLMNPQRSTUV]{3}[A-Za-z]{1})|([0-9]{11})$

# Pattern to verify email addresses. Take a look at match / not match. It works very well. E-mail, email, mail, e-mail address, email address, mail address.
# ID: 3122
^[0-9a-zA-Z]+([0-9a-zA-Z]*[-._+])*[0-9a-zA-Z]+@[0-9a-zA-Z]+([-.][0-9a-zA-Z]+)*([0-9a-zA-Z]*[.])[a-zA-Z]{2,6}$

# Dni-nie validator
# ID: 2425
^[A-z]?\d{8}[A-z]$

# This will parse a command line for the command and parameter
# ID: 3425
(?<cmd>^"[^"]*"|\S*) *(?<prm>.*)?

# match the date pattren start with year and seprated by (-).
# ID: 1671
(?<Year>(?:\d{4}|\d{2}))-(?<Month>\d{1,2})-(?<Day>\d{1,2})

# Find out Canadian Postal Code in the text or html file or xml file
# ID: 1676
\b[A-Z-[DFIOQUWZ]]\d[A-Z-[DFIOQU]]\ +\d[A-Z-[DFIOQU]]\d\b

# matches numeric value with optional +/- , optional decimal point, and optional commas
# ID: 2015
^[-+]?([0-9]{1,3}[,]?)?([0-9]{3}[,]?)*[.]?[0-9]*$

# US Zip Code + 4 digit extension Postal Code
# ID: 459
^[0-9]{5}([- /]?[0-9]{4})?$

# Validates hours and minutes. Allows for entry in the form of hours:minutes with optional minutes and optional hours indicator (H or h).
# ID: 574
^(\d{1,2})(\s?(H|h)?)(:([0-5]\d))?$

# This regex will eliminate all diacritics characters. To make it clear, if this is embedded in a javascript or any other coding it will not accept diacritics
# ID: 2526
([A-Z]|[a-z])|\/|\?|\-|\+|\=|\&|\%|\$|\#|\@|\!|\||\\|\}|\]|\[|\{|\;|\:|\'|\"|\,|\.|\>|\<|\*|([0-9])|\(|\)|\s

# This will identify all the characters in between html tags irrespective of the length of the character or intiger. If scenario emerges to extract content between tags a replacement string  can be used: $3
# ID: 2527
(\<(.*?)\>)(.*?)(\<\/(.*?)\>)

# This regex is really helpful if you are trying to find out executive moves. For instance you have 100 docs with company details but you need to find out the newly joined executives and resigned executives, you can do it with this.
# ID: 2528
\b ?(a|A)ppoint(s|ing|ment(s)?|ed)?| ?(J|j)oin(s|ed|ing)| ?(R)?recruit(s|ed|ing(s)?)?| (H|h)(is|er)(on)? dut(y|ies)?| ?(R)?replace(s|d|ment)?| (H)?hire(s|d)?| ?(P|p)romot(ed|es|e|ing)?| ?(D|d)esignate(s|d)| (N)?names(d)?| (his|her)? (P|p)osition(ed|s)?| re(-)?join(ed|s)|(M|m)anagement Changes|(E|e)xecutive (C|c)hanges| reassumes position| has appointed| appointment of| was promoted to| has announced changes to| will be headed| will succeed| has succeeded| to name| has named| was promoted to| has hired| bec(a|o)me(s)?| (to|will) become| reassumes position| has been elevated| assumes the additional (role|responsibilit(ies|y))| has been elected| transferred| has been given the additional| in a short while| stepp(ed|ing) down| left the company| (has)? moved| (has)? retired| (has|he|she)? resign(s|ing|ed)| (D|d)eceased| ?(T|t)erminat(ed|s|ing)| ?(F|f)ire(s|d|ing)| left abruptly| stopped working| indict(ed|s)| in a short while| (has)? notified| will leave| left the| agreed to leave| (has been|has)? elected| resignation(s)?

# This RE will be useful in identifying emails.
# ID: 2529
\b([A-Za-z0-9]+)(-|_|\.)?(\w+)?@\w+\.(\w+)?(\.)?(\w+)?(\.)?(\w+)?\b

# Replaces the space character with an underscore, this regex replacement will be useful if you have change the naming convention for DB field names. The replacement string will be: $1_$3 (you can opt anything instead of "_" in the replacement string  for instance, $1-$2
# ID: 2530
\b([A-Za-z0-9]+)( )([A-Za-z0-9]+)\b

# This RE will find doubled words/characters in a sentence. This will give a helping hand in content QC where you need to  identify and remove unnecessary repetitive words/characters.
# ID: 2531
\b([A-Za-z]+) +\1\b

# Repetition of two numeric sets can be identified with this RE.
# ID: 2532
\b([0-9]+) +\1\b

# Repeated word/character/number/number with alpha character can be identified with this RE
# ID: 2533
\b([A-Za-z0-9]+) +\1\b

# The above RE will identify doubled alphanum/num/alpha and replaces with a single occurance.
# ID: 2534
\b([A-Za-z0-9]+) +\1\b   replacement string--->$1

# (\n\r) removes single or multiple blank\empty lines. The replacement string will be \n
# ID: 2535
(\n\r)   replacement string---->\n

# This RE will identify leading and trailing spaces. To trim this just replace with nothing.
# ID: 2536
^[ \t]+|[ \t]+$

# This RE recognizes unformatted US phone numbers. The replacement string is $2-$4-$6. Helps when you want to normalize the phone numbers in a DB field.This also identifies a single space given before are after the part of first, second 3 digits and before the last 4 digits. The replaced format will be "123-456-7890"
# ID: 2537
^([\.\"\'-/ \(/)\s\[\]\\\,\<\>\;\:\{\}]?)([0-9]{3})([\.\"\'-/\(/)\s\[\]\\\,\<\>\;\:\{\}]?)([0-9]{3})([\,\.\"\'-/\(/)\s\[\]\\\<\>\;\:\{\}]?)([0-9]{4})$

# This RE will be very useful if you want to eliminate non-alpha\numeric containing lines. For example, you have 10000 records in a DB field and you need to identify and eliminate fully unwanted character containing lines, this will help you.
# ID: 2538
^[^a-zA-Z0-9]+$

# This RE will identify URLS only starting with http or https. Please test this before using.
# ID: 2539
^(http(s)?\:\/\/\S+)\s

# This RE will identify any diacritics. Pretty useful to validate fields wherein you do not want any junk characters to get in.
# ID: 2540
[\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x1C\x1D\x1E\x1F\x60\x80\x8A\x8C\x8E\x9A\x9C\x9E\x9F\xA7\xAE\xB1\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\u0060\u00A2\u00A3\u00A4\u00A5\u00A6\u00A7\u00A8\u00A9\u00AA\u00AB\u00AC\u00AE\u00AF\u00B0\u00B1\u00B2\u00B3\u00B4\u00B5\u00B7\u00B9\u00BA\u00BB\u00BC\u00BD\u00BE\u00BF\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5\u00C6\u00C7\u00C8\u00C9\u00CA\u00CB\u00CC\u00CD\u00CE\u00CF\u00D0\u00D1\u00D2\u00D3\u00D4\u00D5\u00D6\u00D8\u00D9\u00DA\u00DB\u00DC\u00DD\u00DE\u00DF\u00E0\u00E1\u00E2\u00E3\u00E4\u00E5\u00E6\u00E7\u00E8\u00E9\u00EA\u00EB\u00EC\u00ED\u00EE\u00EF\u00F0\u00F1\u00F2\u00F3\u00F4\u00F5\u00F6\u00F8\u00F9\u00FA\u00FB\u00FC\u00FD\u00FE\u00FF\u0100\u0101\u0102\u0103\u0104\u0105\u0106\u0107\u0108\u0109\u010A\u010B\u010C\u010D\u010E\u010F\u0110\u0111\u0112\u0113\u0114\u0115\u0116\u0117\u0118\u0119\u011A\u011B\u011C\u011D\u011E\u011F\u0120\u0121\u0122\u0123\u0124\u0125\u0126\u0127\u0128\u0129\u012A\u012B\u012C\u012D\u012E\u012F\u0130\u0131\u0132\u0133\u0134\u0135\u0136\u0137\u0138\u0139\u013A\u013B\u013C\u013D\u013E\u013F\u0140\u0141\u0142\u0143\u0144\u0145\u0146\u0147\u0148\u0149\u014A\u014B\u014C\u014D\u014E\u014F\u0150\u0151\u0152\u0153\u0154\u0155\u0156\u0157\u0158\u0159\u015A\u015B\u015C\u015D\u015E\u015F\u0160\u0161\u0162\u0163\u0164\u0165\u0166\u0167\u0168\u0169\u016A\u016B\u016C\u016D\u016E\u016F\u0170\u0171\u0172\u0173\u0174\u0175\u0176\u0177\u0178\u0179\u017A\u017B\u017C\u017D\u017E\u017F\u0180\u0181\u0182\u0183\u0184\u0185\u0186\u0187\u0188\u0189\u018A\u018B\u018C\u018D\u018E\u018F\u0190\u0191\u0192\u0193\u0194\u0195\u0196\u0197\u0198\u0199\u019A\u019B\u019C\u019D\u019E\u019F\u01A0\u01A1\u01A2\u01A3\u01A4\u01A5\u01A6\u01A7\u01A8\u01A9\u01AA\u01AB\u01AC\u01AD\u01AE\u01AF\u01B0\u01B1\u01B2\u01B3\u01B4\u01B5\u01B6\u01B7\u01B8\u01B9\u01BA\u01BB\u01BC\u01BD\u01BE\u01BF\u01C0\u01C1\u01C2\u01C4\u01C5\u01C6\u01C7\u01C8\u01C9\u01CA\u01CB\u01CC\u01CD\u01CE\u01CF\u01D0\u01D2\u01D3\u01D4\u01D5\u01D6\u01D7\u01D8\u01D9\u01DA\u01DB\u01DC\u01DD\u01DE\u01DF\u01E0\u01E1\u01E2\u01E3\u01E4\u01E5\u01E6\u01E7\u01E8\u01E9\u01EA\u01EB\u01EC\u01ED\u01EE\u01EF\u01F0\u01F1\u01F2\u01F3\u01F4\u01F5\u01FA\u01FB\u01FC\u01FD\u01FE\u01FF\u0200\u0201\u0202\u0203\u0204\u0205\u0206\u0207\u0208\u0209\u020A\u020B\u020C\u020D\u020E\u020F\u0210\u0211\u0212\u0213\u0214\u0215\u0216\u0217\u021E\u0250\u0252\u0259\u025A\u025B\u025C\u025D\u025E\u025F\u0260\u0263\u0264\u0265\u0266\u0267\u0268\u0269\u026B\u026C\u026D\u026E\u026F\u0270\u0271\u0272\u0273\u0276\u0277\u0278\u0279\u027A\u027B\u027C\u027D\u027E\u027F\u0281\u0282\u0283\u0284\u0285\u0286\u0287\u0288\u0289\u028A\u028B\u028C\u028D\u028E\u028F\u0290\u0291\u0292\u0293\u0294\u0295\u0296\u0297\u0298\u0299\u029A\u029B\u029C\u029D\u029E\u02A0\u02A1\u02A2\u02A3\u02A4\u02A5\u02A6\u02A7\u02A8\u033D\u033E\u0342\u0343\u0344\u0345\u0386\u0388\u0389\u038A\u038C\u038E\u038F\u0390\u0393\u0394\u0398\u039E\u039F\u03A0\u03A3\u03A6\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\u03D0\u03D1\u03D2\u03D3\u03D4\u03D5\u03D6\u03E0\u03E2\u03E3\u03E4\u03E5\u03E6\u03E7\u03EE\u03EF\u03F0\u03F1\u0403\u0404\u0407\u0409\u040A\u040B\u040C\u040E\u040F\u0411\u0414\u0416\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0424\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043F\u0444\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0451\u0452\u0453\u0454\u0457\u0459\u045A\u045B\u045C\u045E\u045F\u0460\u0461\u0462\u0463\u0464\u0465\u0466\u0467\u0468\u0469\u046A\u046B\u046C\u046D\u046E\u046F\u0470\u0471\u0472\u0473\u0476\u0477\u0478\u047

# This regex will remove the HTML tags with content
# ID: 2624
<(.|\n)*?>

# "one one" can be replaced with "one". This RE will help you in removing the duplicated successor with single word or character. The replacement string will be $1
# ID: 2627
\b([A-Za-z]+) +(\1\b)

# This RE will identify all the special characters(non alpha/numeric).
# ID: 2732
[^a-zA-Z0-9]+

# This Regex (can be used e.g. in PHP with eregi) will match any valid URL. Unlike the other exapmles here, it will NOT match a valid URL ending with a dot or bracket. This is important if you use this regex to find and "activate" Links in an Text
# ID: 153
^(http|https|ftp)\://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\-\._\?\,\'/\\\+&%\$#\=~])*[^\.\,\)\(\s]$

# I had a need to validate 7 digit part numbers consisting of 2 characters followed by 1 to 5 numbers. This expression tests for both the characters and at least on non-zero number. Spaces are not allowed. It should be easy to modify to different length numbers
# ID: 1860
\b[A-Za-z]{2}(?=([0-9]*[1-9]){1,})\d{1,5}\b

# If you need to extract or remove any /* */ sytle comments from any Java, JavaScript, C, C++, CSS, etc code you have this regular expression can help.
# ID: 40
/\*[\d\D]*?\*/

# Tests for valid HTML hexadecimal color codes. The # symbol is optional. And it will except either the 3 digit form for the 216 Web safe colors, or the full 6 digit form. I am use it on my site to allow users to customize the site's colors.
# ID: 36
^#?([a-f]|[A-F]|[0-9]){3}(([a-f]|[A-F]|[0-9]){3})?$

# "Be careful when opening or creating files by using Scripting File System Object. If the filename is based on the user's input, the user might attempt to open a serial port or printer."
# ID: 43
(AUX|PRN|NUL|COM\d|LPT\d)+\s*$

# This pattern will address almost most of the country phone patterns like UK, US, eurpoe, india etc.
# ID: 2693
/^(([^\.\-\,a-wy-z]([\(]?(\+|[x])?\d+[\)]?)?[\s\.\-\,]?([\(]?\d+[\)]?)?[\s\.\-\,]?(\d+[\s\.\-\,]?)+[^\.\-\,a-z])|((\+|[x])?\d+))$/i

# Pattern that evaluetes a number between 0 and 360
# ID: 2819
^(3(([0-5][0-9]{0,2})|60))|([1-2][0-9]{2})|(^[1-9]$)|(^[1-9]{2}$)$

# Well it pretty much accepts all kinds of users, about the domain i didn't write it special for any TLD so there's no length defined, ohh and it accepts some IDN stuff
# ID: 989
^[\.\wæøå-]+@([a-zæøå0-9]+([\.-]{0,1}[a-zæøå0-9]+|[a-zæøå0-9]?))+\.[a-z]{2,6}$

# easy when you want to allow your users to post images, but in a controlled way. I used it like this (in php):
# ID: 255
(\[[Ii][Mm][Gg]\])(\S+?)(\[\/[Ii][Mm][Gg]\])

# This expression matches IP Addresses between 192.168.0.17 - 192.168.0.32 which is a block range of 16 addresses. I created this expression for Google Analytics to filter out hits from our companies office.
# ID: 1900
^((192\.168\.0\.)(1[7-9]|2[0-9]|3[0-2]))$

# Useful for grabbing pipe delimited text from a string.
# ID: 942
(\S*)+(\u007C)+(\S*)

# This will accept SSN in the form of 123-45-6789 OR 123456789.
# ID: 2293
^(\d{3}-\d{2}-\d{4})|(\d{3}\d{2}\d{4})$

# For MySQL Date Time Format
# ID: 1993
^(\d{4})-((0[1-9])|(1[0-2]))-(0[1-9]|[12][0-9]|3[01])$

# This will test to see if a date is formatted in the military style of 'dd MMM yy'
# ID: 2450
^[0-3]{1}[0-9]{1}[ ]{1}(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec){1}[ ]{1}[0-9]{2}$

# This expression can be used to validate any date entered in correct DD-MM-YYYY format. Takes care of Leap Years too..
# ID: 2469
^((29-02-(19|20)(([02468][048])|([13579][26])))|(31-((0[13578])|(1[02]))|(30-((0[13456789])|(1[0-2])))|(29-((0[13456789])|(1[0-2])))|(((0[1-9]|)|(1[0-9])|(2[0-8]))-((0[1-9])|(1[0-2])))-((19|20)[0-9][0-9])))$

# This pattern will extract the "src" attribute of an EMBED tag.  I created it for extracting the URI of an Adobe Flash animation from some HTML, but of course it would work for more general purposes.  Don't forget to turn on case insensitivity.
# ID: 1465
(?<=<embed\s[^<>]*?src\s*?=\s*?\x22)[^<>]*?(?=\x22[^<>]*?>)

# This pattern will extract the "value" attribute of a PARAM tag where name="movie".  I created it for extracting the URI of an Adobe Flash animation from some HTML, but of course it would work for more general purposes.  Don't forget to turn on case insensitivity.  Code tidied up with help from Sergei Z. in the forums.  Here's an older version, without the nested lookarounds: (?<=<param\s[^>]*?name\s*?=\s*?\x22\s*?movie\s*?\x22[^>]*?value\s*?=\s*?\x22)[^>]*?(?=\x22[^>]*?>)|(?<=<param\s[^>]*?value\s*?=\s*?\x22)[^>]*?(?=\x22[^>]*?name\s*?=\s*?\x22\s*?movie\s*?\x22[^>]*?>)
# ID: 1466
(?<=<param(?=[^<>]*?name\s*=\s*\x22movie\x22)[^<>]*?value\s*=\s*\x22)[^<>]*?(?=\x22[^<>]*?>)

# Matches a literal string which conforms to the XML Schema Part 2 'Time' format, which is to say on of:
# ID: 1345
\A((?:[01]{0,1}\d)|(?:[2][0123])):([012345]\d):([012345]\d)(.\d{1,3})?([Z]|(?:[+-]?(?:[01]{0,1}\d)|(?:[2][0123])):([012345]\d))\Z

# Matches a literal XML Date string: See http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#date
# ID: 1346
\A-?(\d{4,})-(\d{2})-(\d{2})([Z]|(?:[+-]?(?:[01]\d)|(?:[2][0123])):(?:[012345]\d))\Z

# Simple Email check, ideal for a quick mail check.
# ID: 1653
^[a-zA-Z0-9\_\-]+[a-zA-Z0-9\.\_\-]*@([a-zA-Z0-9\_\-]+\.)+([a-zA-Z]{2,4}|travel|museum)$

# This regular expression matches "c" format strings for printf/scanf functions.
# ID: 569
%[\-\+0\s\#]{0,1}(\d+){0,1}(\.\d+){0,1}[hlI]{0,1}[cCdiouxXeEfgGnpsS]{1}

# Dutch postal codes are ranged from "1000 AA" to "9999 ZZ".
# ID: 2361
\b[1-9]\d{3}\ +[A-Z]{2}\b

# evaluates dates in the format of DD/MM/YY or DD/MM/YYYY
# ID: 690
(?<Day>[0-3][0-9]|[1-9])/(?<Month>[1-9]|1[0-2]|0[1-9])/(?<Year>[12]\d{3}|\d{2})

# DD/MM/YY
# ID: 670
(?<Day>[1-9]|[0-3][0-9])/(?<Month>[01][012]|[1-9]|0[1-9])/(?<Year>[12]\d{3}|\d{2})

# Check if the number is a valid italian mobile number. Note: even though 35X is non given yet, this regular expression consider it a valid number just in case it will be!
# ID: 2947
^(([+]|00)39)?((3[1-6][0-9]))(\d{7})$

# nothing
# ID: 1473
^[a-zA-Z0-9][\w-]*@[a-zA-Z0-9][\w-\.]*\.[a-zA-Z0-9][\w-]*$

# Matches a latitude in the range of -90 to 90 degrees, with between 1 and 6 trailing decimal places.
# ID: 2728
^-?([1-8]?[0-9]\.{1}\d{1,6}$|90\.{1}0{1,6}$)

# Matches a longitude in the range of -180 to 180 degrees, with between 1 and 6 trailing decimal places.
# ID: 2729
^-?((([1]?[0-7][0-9]|[1-9]?[0-9])\.{1}\d{1,6}$)|[1]?[1-8][0]\.{1}0{1,6}$)

# This regular expression is very useful, when it's required to validate a database column name, for example CUSTOMER_NAME, ORDER_ID or even ITEM2
# ID: 2636
^[A-Z]+[A-Z0-9,\x5F]*$

# Validates currency, must have two leading and two digits following a decimal point. Does not accept leading zero's.
# ID: 861
^(?!0,?\d)([0-9]{2}[0-9]{0,}(\.[0-9]{2}))$

# Can be used to find SQL Server parmeters in a SQL string.  Does not attempt to weed-out "@" characters in embedded string values.
# ID: 2639
@([_a-zA-Z]+)

# This checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\://) it only does the latter check. Replace http by (http|https|ftp) for other protocols. Still not happy about this: http://www.www.passshouldfail.com
# ID: 2501
^(http\://){1}(((www\.){1}([a-zA-Z0-9\-]*\.){1,}){1}|([a-zA-Z0-9\-]*\.){1,10}){1}([a-zA-Z]{2,6}\.){1}([a-zA-Z0-9\-\._\?\,\'/\\\+&%\$#\=~])*

# Modified version of Brian Bothwell's valid url submission. Eliminates a couple of the user discovered bugs, expands protocol recognition and considers trailing /
# ID: 1263
((file|gopher|news|nntp|telnet|http|ftp|https|ftps|sftp)\:\/\/([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&%\$\-]+)*@){0,1}((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]{2,5}[^:]){0,1}(\/(\s+|$|[a-zA-Z0-9\.\,\?\'\\\+&%\$#\=~_\-]+)){0,1})

# Validates a semi colon delimited list of email addresses.  Appropriate for use with .NET Web.Mail.MailMessage fields (To, BCC, CC)
# ID: 1368
^([\w]+@([\w]+\.)+[a-zA-Z]{2,9}(\s*;\s*[\w]+@([\w]+\.)+[a-zA-Z]{2,9})*)$

# This is User Name & Password validation expression. It does not allow blank spaces as well as special characters like $#%@&*(){}+
# ID: 1023
\w{5,255}

# Validates dates in the following format: MM/DD/YY
# ID: 2174
((0[1-9])|(1[0-2]))\/(([0-9])|([0-2][0-9])|(3[0-1]))/\d{2}

# Matches standard NMEA sentences
# ID: 3435
\$?GP[a-z]{3,},([a-z0-9\.]*,)+([a-z0-9]{1,2}\*[a-z0-9]{1,2})

# Matches simple root website URLs.
# ID: 2184
^(http(s?):\/\/)(www.)?(\w|-)+(\.(\w|-)+)*((\.[a-zA-Z]{2,3})|\.(aero|coop|info|museum|name))+(\/)?$

# This expression will validate user name with the following rules
# ID: 3089
^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,8}[a-zA-Z0-9]$

# Regular expression to match South African Mobile network ( Range allocated to SPs until Dec'2011 ).
# ID: 3400
^(\+27|27)?(\()?0?([7][1-9]|[8][2-4])(\))?( |-|\.|_)?(\d{3})( |-|\.|_)?(\d{4})

# It will allow exact 14 numbers and two decimal position with positive or negative numbers
# ID: 1539
(^-?\d{0,14})+(\.\d{0,18})?)

# Allow only 3 charcters or number without any special characters
# ID: 1540
"[A-Za-z0-9]{3}"

# US Telephone Number where this is regular expression excludes the first number, after the area code,from being 0 or 1; it also allows an extension
# ID: 116
^[\\(]{0,1}([0-9]){3}[\\)]{0,1}[ ]?([^0-1]){1}([0-9]){2}[ ]?[-]?[ ]?([0-9]){4}[ ]*((x){0,1}([0-9]){1,5}){0,1}$

# @ Before you can have underlined, connection, point character, @there are three points after the characters are not allowed
# ID: 3062
^[\w]+[-\.\w]*@[-\w]+\.[a-z]{2,6}(\.[a-z]{2,6})?$

# Optional host header that contains as many query strings
# ID: 3063
[a-z]{3,4}s?:\/\/[-\w.]+(\/[-.\w%&=?]+)*

# I was looking for a long time for a simple regex to strip the domain name from a long url or to Get rid of directories and pages. I found a simple one that I wanted to share. If you have http://www.google.com/products/bob?gmail.ckj it will return only http://www.google.com getting rid of all the other parts of the url
# ID: 1464
http://[^/]*/

# It checks for the domain name validity. A domain name can't start with a dot(.). It can't have consecutive dots. If there are moe than one dot then there can be only 2 to 6 characters after the final dot. e.g. nitin.athena.com is valid.
# ID: 1954
(([A-Za-z0-9_\\-]+\\.?)*)[A-Za-z0-9_\\-]+\\.[A-Za-z0-9_\\-]{2,6}

# to allow the only small letters.
# ID: 2386
name.matches("a-z")

# Letter Grade scores A-F + and -
# ID: 660
(^[a-fA-F]+[+-]?$)

# regex for IPCodeSectionSeriesRim.
# ID: 1501
\d{5,12}|\d{1,10}\.\d{1,10}\.\d{1,10}|\d{1,10}\.\d{1,10}

# Match for dutch zipcodes.
# ID: 705
[0-9]{4}[A-Z]{2}

# Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>
# ID: 1865
(?:\([2-9][0-8]\d\)\ ?|[2-9][0-8]\d[\-\ \.\/]?)[2-9]\d{2}[- \.\/]?\d{4}\b

# Matches the 24 clock
# ID: 1156
^(?([0-1])[0-1][0-9]|2[0-3])\:[0-5][0-9]$

# Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS.
# ID: 2473
^([0-9a-f]{4}\.[0-9a-f]{4}\.[0-9a-f]{4})$

# Extracts the querystring from a link tag
# ID: 1903
<a.*? href=["|'].*\?(?<query>.*?)["|'].*?>

# This is a pattern that matches the time format as recomended by the w3c for XML formats
# ID: 1963
^([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\.[0-9]{4}|[-|\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$

# This regular expression checks dates from 1600 to 9999 in the form of YYYY-MM-DD also takes into account leap years
# ID: 1965
^((1[6789]|[2-9][0-9])[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))$|^((1[6789]|[2-9][0-9])[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30))$|^((16|[248][048]|[3579][26])00)|(1[6789]|[2-9][0-9])(0[48]|[13579][26]|[2468][048])-02-(0[1-9]|1[0-9]|2[0-9])$|^(1[6789]|[2-9][0-9])[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])$

# This pattern matches valid w3c compatible datetime values  from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.
# ID: 1966
^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\.[0-9]{4}|[-|\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\.[0-9]{4}|[-|\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((16|[248][048]|[3579][26])00)|(1[6789]|[2-9][0-9])(0[48]|[13579][26]|[2468][048])-02-(0[1-9]|1[0-9]|2[0-9])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\.[0-9]{4}|[-|\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?(1[6789]|[2-9][0-9])[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\.[0-9]{4}|[-|\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$

# Extracts Day, Monthname, Year, Hour and Minute into 5 Groups. This Regex is useful for E-Mail Apps.
# ID: 2014
(?:[a-z]{3},\s+)?(\d{1,2})\s+([a-z]{3})\s+(\d{4})\s+([01][0-9]|2[0-3])\:([0-5][0-9])

# A quick and dirty expression for splitting up a generic street address
# ID: 2420
^(\d{3,})\s?(\w{0,5})\s([a-zA-Z]{2,30})\s([a-zA-Z]{2,15})\.?\s?(\w{0,5})$

# With this expresion you ll be able to extract all the urls of a given text or HTML page.
# ID: 2881
'`.*?((http|ftp|https)://[\w#$&+,\/:;=?@.-]+)[^\w#$&+,\/:;=?@.-]*?`i'

# dd/mm/yyyy HH:MM
# ID: 3094
^((((31\/(0?[13578]|1[02]))|((29|30)\/(0?[1,3-9]|1[0-2])))\/(1[6-9]|[2-9]\d)?\d{2})|(29\/0?2\/(((1[6-9]|[2-9]\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))|(0?[1-9]|1\d|2[0-8])\/((0?[1-9])|(1[0-2]))\/((1[6-9]|[2-9]\d)?\d{2})) (20|21|22|23|[0-1]?\d):([0-5]?)\d$

# pattern match for U.S. social security number
# ID: 2297
(\d{3}\-\d{2}\-\d{4})

# Allows only a positive whole number greater than 4.  Obviously it can be easily changed to be greater than any number desired.
# ID: 2190
((?!^[0-4])^(\d+))$

# This is my first attempt at creating a regex.  For a street number only field, allows 7 digit number, 6 digit number with one preceding letter (the letter can have a hyphen, space, or nothing between it and the numbers), two 7 digit numbers divided by a "/","\", or "-", variations of P.O. Box we allow, Rural Route, and Highway Contract acoording to U.S. Postal rules.
# ID: 2129
((\d{1,6}\-\d{1,6})|(\d{1,6}\\\d{1,6})|(\d{1,6})(\/)(\d{1,6})|(\w{1}\-?\d{1,6})|(\w{1}\s\d{1,6})|((P\.?O\.?\s)((BOX)|(Box))(\s\d{1,6}))|((([R]{2})|([H][C]))(\s\d{1,6}\s)((BOX)|(Box))(\s\d{1,6}))?)$

# A simple regex for validating a Google link.
# ID: 2751
^http://\\.?video\\.google+\\.\\w{2,3}/videoplay\\?docid=[\\w-]{19}

# Powerful href extractor for HTML Element A.
# ID: 984
(?<HTML><a[^>]*href\s*=\s*[\"\']?(?<HRef>[^"'>\s]*)[\"\']?[^>]*>(?<Title>[^<]+|.*?)?</a\s*>)

# Matches any opening or closing script tags, inline javascript: tags, inline on<function> (ex: onClick) tags.
# ID: 1496
<script.*/*>|</script>|<[a-zA-Z][^>]*=['"]+javascript:\w+.*['"]+>|<\w+[^>]*\son\w+=.*[ /]*>

# This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.
# ID: 1392
<\?xml.*</note>

# Matches BFPO
# ID: 2510
^(b|B)(f|F)(p|P)(o|O)(\s*||\s*C(/|)O\s*)[0-9]{1,4}

# Matches all coorrectly spaced BFPO's
# ID: 2511
^(b|B)(f|F)(p|P)(o|O)(\s|\sC/O\s)[0-9]{1,4}

# This regular expression can be used to validate UK postcodes. Especially useful if want to provide a client side validation on a web site.
# ID: 91
^[A-Za-z]{1,2}[0-9A-Za-z]{1,2}[ ]?[0-9]{0,1}[A-Za-z]{2}$

# UK National Insurance Number validation. Especially useful to validate through clientside/server side script on a website.
# ID: 92
^[A-Za-z]{2}[0-9]{6}[A-Za-z]{1}$

# Accepts a list of 4 digits separated by commas. Used to validate a list of years. Can be easily customized to change the number of digits.
# ID: 2105
^(\d{4},?)+$

# Accepts integer and decimal numbers, the decimal delimiter beeing either a point or a comma, prefixed or not by a plus or minus sign.
# ID: 1484
^[\+\-]?[0-9]+([\,\.][0-9]+)?$

# Dutch zip code expression
# ID: 65
[0-9]{4}\s*[a-zA-Z]{2}

# Matches words in PascalCase. Only alphas, no spaces or other special characters, the first character must be upper case. Matches up to 12 PascalCase words.
# ID: 1601
^([A-Z]{1,}[a-z]{1,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,})$

# A regular expression that matches numbers. Integers or decimal numbers with or without the exponential form.
# ID: 185
^[+-]?([0-9]*\.?[0-9]+|[0-9]+\.?[0-9]*)([eE][+-]?[0-9]+)?$

# allows a username of any length a-z 0-9 including one of ._- between each letter or number but not at the start or end of the name
# ID: 3321
^[^\~\`\!\@\#\$\%\^\&\*\(\)\-\_\=\+\\\|\[\]\{\}\;\:\"\'\,\<\./\>\?\s](([a-zA-Z0-9]*[-_\./]?[a-zA-Z0-9]{1,})*)$

# This is useful to find single quoted strings in mysql dumps.
# ID: 2432
('(?:(?:\\'|[^'])*)'|NULL)

# Tries to match the format of phone numbers within South Africa. Does not try to validate phone numbers based on actual numbers (e.g. cell networks or other landline prefixes)
# ID: 3311
(\(0\d\d\)\s\d{3}[\s-]+\d{4})|(0\d\d[\s-]+\d{3}[\s-]+\d{4})|(0\d{9})|(\+\d\d\s?[\(\s]\d\d[\)\s]\s?\d{3}[\s-]?\d{4})

# This RE strips HTML open and close tags from text with any attributes provided, including not properly formatted tags.
# ID: 3558
<(\s*/?\s*)\w+?(\s*(([\w-]+="[^"]*?")|([\w-]+='[^']*?')|([\w-]+=[^'"<>\s]+)))*(\s*/?\s*)>

# Find proper names in the form John Doe
# ID: 3556
[A-Z][a-zA-Z]+ [A-Z][a-zA-Z]+

# Looks for a number which can be optionally comma separated at thousands and may or may not have two decimal places. Tweaking: 1. Replace the \$ symbol with your currency. 2. Toggle , and . as separators (Some European countries follow this convention) 3. Mandate comma separation by removing the ? after ,
# ID: 1802
^\$\d{1,3}(,?\d{3})*(\.\d{2})?$

# Validates SSN for INTEGERS ONLY. This does not allow spaces or dashes.
# ID: 3148
(?!000)(?!666)^([0-8]\d{2})(\d{2})(\d{4})$

# This expression will return the first letter of each word in a string. Best used if you need to get initials from a name.
# ID: 630
(^[A-Za-z])|(\s)([A-Za-z])

# Created for input validation of major part of zip code.  Normal Canadian entry has an optional space between the first group of three and the second group.  Original pattern taken from Steven Smith and modified for our entries.
# ID: 1810
^(\d{5})$|^([a-zA-Z]\d[a-zA-Z]( )?\d[a-zA-Z]\d)$

# I searched for a smiley expression but couldn't find one. This one should find all the usual ways of writing the sad emotion icon.
# ID: 725
[:;]{1}[-~+o]?[(<\[]+

# This ist the Expression for a happy smiley. It should find all the usual writings of the emotion icon :)
# ID: 726
[:]{1}[-~+o]?[)>]+

# Matches number with optional commas and decimal places. Allows only max 7 digits before decimal and max 2 digits after decimal. Does not allow numbers beginning with 0 e.g., $0,234,567 but allows $0.05
# ID: 1511
^\$([0]|([1-9]\d{1,2})|([1-9]\d{0,1},\d{3,3})|([1-9]\d{2,2},\d{3,3})|([1-9],\d{3,3},\d{3,3}))([.]\d{1,2})?$|^\(\$([0]|([1-9]\d{1,2})|([1-9]\d{0,1},\d{3,3})|([1-9]\d{2,2},\d{3,3})|([1-9],\d{3,3},\d{3,3}))([.]\d{1,2})?\)$|^(\$)?(-)?([0]|([1-9]\d{0,6}))([.]\d{1,2})?$

# Validates age range 18 - 99
# ID: 3258
^(1[89]|[2-9]\d)$

# A simple expression for validate in .net RegularExpressionValidator.
# ID: 715
^[\+\-]?\d+(,\d+)?$

# In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Sadly, it doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).
# ID: 2743
^(0?[1-9]|1[012])/([012][0-9]|[1-9]|3[01])/([12][0-9]{3})$

# Used as a username validation script requires:
# ID: 149
[^A-Za-z0-9_@\.]|@{2,}|\.{5,}

# Updated, changed [\w]* to [\w]+ because pattern should not match Sub (), there would be no function name which would be incorrect.
# ID: 476
^(Function|Sub)(\s+[\w]+)\([^\(\)]*\)

# Validates numbers with commas.
# ID: 2313
^(\d{1,3},)?(\d{3},)+\d{3}(\.\d*)?$|^(\d*)(\.\d*)?$

# Additional checks for <> and " characters
# ID: 273
^(?!^(PRN|AUX|CLOCK\$|NUL|CON|COM\d|LPT\d|\..*)(\..+)?$)[^\x00-\x1f\\?*<>:\;|\"/]+$

# This (while not perfect) locates c++ function declarations.  Useful for working with large source files
# ID: 2292
^.*[_A-Za-z0-9]+[\t ]+[\*&]?[\t ]*[_A-Za-z0-9](::)?[_A-Za-z0-9:]+[\t ]*\(( *[ \[\]\*&A-Za-z0-9_]+ *,? *)*\).*$

# Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups
# ID: 1204
^((67\d{2})|(4\d{3})|(5[1-5]\d{2})|(6011))-?\s?\d{4}-?\s?\d{4}-?\s?\d{4}|3[4,7]\d{13}$

# Credit Card Validation. Matches Switch/Solo, Visa, MasterCard and Discover in 4-4-4-4/4 4 4 4/4444 format and Amex in 4-6-5/4 6 5/465 format.
# ID: 1205
^((67\d{2})|(4\d{3})|(5[1-5]\d{2})|(6011))(-?\s?\d{4}){3}|(3[4,7])\d{2}-?\s?\d{6}-?\s?\d{5}$

# Matches Names - written for credit card matching.
# ID: 1207
^[a-z\.]*\s?([a-z\-\']+\s)+[a-z\-\']+$

# will break out a valid CSS stylesheet into it's components.  Groups on each style, all selectors, each selector within a comma delimited list of selectors, all properties, each property set, each property and each value.  In other words, it breaks it all down for you :)
# ID: 916
((\s*([^,{]+)\s*,?\s*)*?){((\s*([^:]+)\s*:\s*([^;]+?)\s*;\s*)*?)}

# Use in a .net Regex.Split() to pull the protocol out of a url into the first array entry.
# ID: 624
(^[a-zA-Z0-9]+://)

# Return all comment lines (starts with //) and regions (serounded by /* */) as well as compiler arguments (#) in C# code
# ID: 1286
(?:/\*[\w\W]*?\*/|//[^\n]*?$|\#[^\n]*?$)

# Will match the following date formats: Preceded by a Space, Left-parentheses, or at the beginning of a line.  Followed by a Space, Right-parentheses, or Colon(:), word boundary or End of line.  Can have / or - as separator.  Accepts 2 digit year 00-99 or 4 digit years 1900-2099 (can modify to accept any range)
# ID: 77
(^|\s|\()((([1-9]){1}|([0][1-9]){1}|([1][012]){1}){1}[\/-]((2[0-9]){1}|(3[01]){1}|([01][1-9]){1}|([1-9]){1}){1}[\/-](((19|20)([0-9][0-9]){1}|([0-9][0-9]){1})){1}(([\s|\)|:])|(^|\s|\()((([0-9]){1}|([0][1-9]){1}|([1][012]){1}){1}[\/-](([11-31]){1}|([01][1-9]){1}|([1-9]){1}){1}[\/-](((19|20)([0-9][0-9]){1}|([0-9][0-9]){1})){1}(([\s|\)|:|$|\>])){1}){1}){1}){1}

# Used to verify that the string consists of only A-z, 0 - 9 and underscore. Several words allowed, only one space between them. No spaces up front. Hey, I know it's easy, but it was not in the library! Plus, the test option here is not working well all the time.
# ID: 474
(\w(\s)?)+

# valida una cedula venezolana:
# ID: 3628
^([V|E|J|G|v|e|j|g])([0-9]{5,8})$

# numeros telefonicos de venezuela
# ID: 3629
^0[0-9]{3}-[0-9]{7}$

# This regex is designed to fail fast (using possessive quantifiers) while still matching a floating decimal number all the time. Won't match scientific notation or fractions. Can be combined with other patterns.
# ID: 1822
[+-]?+(?>\d++\.?+\d*+|\d*+\.?+\d++)

# Captures numbers like found in legal contracts e.g.:
# ID: 3518
((?:\d+\.){1,5})

# Used with the Regex.Split() function in .NET, this will easily split a camelCase word on the upper case letters, while not dropping any characters.  (That makes it different from most split() functions -- it does not drop any characters.)  More details in my blog - http://blogs.lotterypost.com/speednet/2007/08/simple-function-to-split-camelcase-words.htm
# ID: 1897
(?<!^)(?=[A-Z])

# This expression validates most legal dates for a SQL Server 2005 datetime format. It includes checking for leap years. (Written for a default U.S. install, not sure what results would be on versions for different regions)
# ID: 2182
^((((((((jan(uary)?)|(mar(ch)?)|(may)|(july?)|(aug(ust)?)|(oct(ober)?)|(dec(ember)?)) ((3[01])|29))|(((apr(il)?)|(june?)|(sep(tember)?)|(nov(ember)?)) ((30)|(29)))|(((jan(uary)?)|(feb(ruary)?|(mar(ch)?)|(apr(il)?)|(may)|(june?)|(july?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?))) (2[0-8]|(1\d)|(0?[1-9])))),? )|(((((1[02])|(0?[13578]))[\.\-/]((3[01])|29))|(((11)|(0?[469]))[\.\-/]((30)|(29)))|(((1[0-2])|(0?[1-9]))[\.\-/](2[0-8]|(1\d)|(0?[1-9]))))[\.\-/])|(((((3[01])|29)[ \-\./]((jan(uary)?)|(mar(ch)?)|(may)|(july?)|(aug(ust)?)|(oct(ober)?)|(dec(ember)?)))|(((30)|(29))[ \.\-/]((apr(il)?)|(june?)|(sep(tember)?)|(nov(ember)?)))|((2[0-8]|(1\d)|(0?[1-9]))[ \.\-/]((jan(uary)?)|(feb(ruary)?|(mar(ch)?)|(apr(il)?)|(may)|(june?)|(july?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?)))))[ \-\./])|((((3[01])|29)((jan)|(mar)|(may)|(jul)|(aug)|(oct)|(dec)))|(((30)|(29))((apr)|(jun)|(sep)|(nov)))|((2[0-8]|(1\d)|(0[1-9]))((jan)|(feb)|(mar)|(apr)|(may)|(jun)|(jul)|(aug)|(sep)|(oct)|(nov)|(dec)))))(((175[3-9])|(17[6-9]\d)|(1[89]\d{2})|[2-9]\d{3})|\d{2}))|((((175[3-9])|(17[6-9]\d)|(1[89]\d{2})|[2-9]\d{3})|\d{2})((((1[02])|(0[13578]))((3[01])|29))|(((11)|(0[469]))((30)|(29)))|(((1[0-2])|(0[1-9]))(2[0-8]|(1\d)|(0[1-9])))))|(((29feb)|(29[ \.\-/]feb(ruary)?[ \.\-/])|(feb(ruary)? 29,? ?)|(0?2[\.\-/]29[\.\-/]))((((([2468][048])|([3579][26]))00)|(17((56)|([68][048])|([79][26])))|(((1[89])|([2-9]\d))(([2468][048])|([13579][26])|(0[48]))))|(([02468][048])|([13579][26]))))|(((((([2468][048])|([3579][26]))00)|(17((56)|([68][048])|([79][26])))|(((1[89])|([2-9]\d))(([2468][048])|([13579][26])|(0[48]))))|(([02468][048])|([13579][26])))(0229)))$

# "Starts with but does not end with."
# ID: 466
^((Bob)|(John)|(Mary)).*$(?<!White)

# Dutch postalcode expression. 4 digits followed by max. two spaces end ending on two letters.
# ID: 311
^[0-9]{4}\s{0,2}[a-zA-z]{2}$

# RFC2822 compliant. Includes all special characters, except for allowance of quoted local-part. Also disallows '.' (period) to be at the front or end of local-part, or occurr more than once consecutively. It does allow for optional infinite number of sub-domains.
# ID: 1977
^(?i:(?<local_part>[a-z0-9!#$%^&*{}'`+=-_|/?]+(?:\.[a-z0-9!#$%^&*{}'`+=-_|/?]+)*)@(?<labels>[a-z0-9]+\z?.*[a-z0-9-_]+)*(?<tld>\.[a-z0-9]{2,}))$

# RFC compliant. Disallows '.' (period) to be at the front or end, or occurr more than once consecutively. It does allow for optional infinite number of sub-domains. However, the total length of the URI has not been enforced: each label must be between 1 and 63 characters long, while the total length of the domain name may not exceed 255 characters.
# ID: 1978
^([A-Za-z0-9]+[A-Za-z0-9-_]*\.)*(([A-Za-z0-9]+[A-Za-z0-9-_]*){3,}\.)+([A-Za-z0-9]{2,4}\.?)+)$

# Matches whole numbers with the two most common thousands-separators (comma and period). Will not handle decimals.
# ID: 1979
^[1-9]{1}[0-9]{0,2}([\.\,]?[0-9]{3})*$

# Validates a Italian mobile phone number with (or without) the International code
# ID: 587
^([+]39)?((38[{8,9}|0])|(34[{7-9}|0])|(36[6|8|0])|(33[{3-9}|0])|(32[{8,9}]))([\d]{7})$

# LDAP path of Microsoft Active Directory entries (Organizational Units, Users, Computers and Groups). Requires LDAP protocol especification and allows a server name at the beginning.
# ID: 913
^(LDAP://([\w]+/)?(CN=['\w\s\-\&]+,)*(OU=['\w\s\-\&]+,)*(DC=['\w\s\-\&]+[,]*)+)$

# Allows:
# ID: 2506
^(([A-Z]{1}[a-z]+([\-][A-Z]{1}[a-z]+)?)([ ]([A-Z]\.)){0,2}[ ](([A-Z]{1}[a-z]*)|([O]{1}[\']{1}[A-Z][a-z]{2,}))([ ](Jr\.|Sr\.|IV|III|II))?)$

# function isValidURL($url) {
# ID: 2329
if(!isValidURL($_POST['url']){ echo "do something"; }

# Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12).
# ID: 1768
^1?[1-2]$|^[1-9]$|^[1]0$

# Matches 1-1500 characters including carriage returns ("\r\n")
# ID: 1700
^[\w\W]{1,1500}$

# Separa <Apellidos>, <Nombres>
# ID: 2686
^(?n:(?<Apellidos>(?-i:[A-Z]\'?(\w+?|\.)\ ??){1,4})?[\s,\s]*(?<Nombres>(?-i:[A-Z]\'?(\w+?|\.)\ ??){1,4})?)$

# This expression was originally developed for user names.  Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:
# ID: 1145
(?=^.{6,51}$)([A-Za-z]{1})([A-Za-z0-9!@#$%_\^\&\*\-\.\?]{5,49})$

# Brazilian Postal Box RegExp validation
# ID: 623
\d{5}\-\d{3}

# Matches only numbers, in any length. No characters or punctuation will be matched.
# ID: 834
^[0-9]*$

# When you require "," after every two digits
# ID: 2699
^([0-9]{1,2},([0-9]{2},)*[0-9]{3}|[0-9]+)$

# This Regex is usefull to validate if the text typed will still lead to a valid number for a international input.
# ID: 2260
[+-]*[0-9]+[,]*[0-9]*|[+-]*[0-9]*[,]+[0-9]*

# Matches LDAP path (AdsPath) in Active Directory. Modified version of regex which has been found in library.
# ID: 1238
^((CN=(['\w\d\s\-\&\.]+(\\/)*(\\,)*)+,\s*)*(OU=(['\w\d\s\-\&\.]+(\\/)*(\\,)*)+,\s*)*(DC=['\w\d\s\-\&]+[,]*\s*){1,}(DC=['\w\d\s\-\&]+\s*){1})$

# Validates your average email, it will not allow two periods to be placed adjacent to one another.
# ID: 2353
^[a-z0-9_.-]*@[a-z0-9-]+(.[a-z]{2,4})+$

# matches simple time 12 hours 59 minutes (am or pm) format
# ID: 1422
^\s*(?i:)((1[0-2])|(0[1-9])|([123456789])):(([0-5][0-9])|([123456789]))\s(am|pm)\s*$

# This pattern matches the New Zealand mobile phone number. Only 021 025 027 029 number are matched.
# ID: 1689
(^[0][2][1579]{1})(\d{6,7}$)

# This pattern matches on Integer values.  Handles leading positive or negative signs.  Supports commas where only the leading group can have less than three digits.
# ID: 1467
^[-+]?(\d?\d?\d?,?)?(\d{3}\,?)*$

# This pattern matches decimal values.  It supports option leading positive or negative symbols.  Supports commas where only the leading group can have less than three numbers.
# ID: 1468
^[-+]?(\d?\d?\d?,?)?(\d{3}\,?)*(\.?\d+)$

# Matches the most common urls in the web
# ID: 3301
^((https|http)://)?(www.)?(([a-zA-Z0-9\-]{2,})\.)+([a-zA-Z0-9\-]{2,4})(/[\w\.]{0,})*((\?)(([\w\%]{0,}=[\w\%]{0,}&?)|[\w]{0,})*)?$

# Will locate an URL in a webpage.
# ID: 222
(("|')[a-z0-9\/\.\?\=\&]*(\.htm|\.asp|\.php|\.jsp)[a-z0-9\/\.\?\=\&]*("|'))|(href=*?[a-z0-9\/\.\?\=\&"']*)

# A SIP regex.
# ID: 2041
^(sip|sips):.*\@((\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3})|([a-zA-Z\-\.]+\.[a-zA-Z]{2,5}))(:[\d]{1,5})?([\w\-?\@?\;?\,?\=\%\&]+)?

# A string of even zeros and any number of ones anywhere.
# ID: 3257
(01*0|1)*

# Accepts words or quoted phrases for search strings. Stops SQL injection.
# ID: 1567
^["a-zA-Z0-9\040]+$

# This validates against the RFC 2821 (SMTP) syntax unit 'Mailbox' [equiv. to addr-spec - not address - element of RFC 2822] (the one a certain critic keeps linking to validates the RFC822 'address' element which includes support for stuff like "Group:User <address>,User <address>;", obsolete smtp routing syntax like <@host1,@host2:user@host>, etc)
# ID: 2525
^\s*(([/-9!#-'*+=?A-~-]+(?:\.[/-9!#-'*+=?A-~-]+)*|"(?:[^"\r\n\\]|\\.)*")@([A-Za-z][0-9A-Za-z-]*[0-9A-Za-z]?(?:\.[A-Za-z][0-9A-Za-z-]*[0-9A-Za-z]?)*|\[(?:[^\[\]\r\n\\]|\\.)*\]))\s*$

# This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09.
# ID: 867
^\(0[1-9]{1}\)[0-9]{8}$

# I started out looking for a way to propertly parse delimited CSV text.  Everything that I tried on my own was not doing what I wanted it to do, so I borrowed one from someone here and customized it a bit to get pretty close to what I wanted (see ORIGIONAL MESSAGE below).  Ultimately though, I still needed more functionality, so I started over, and came up with this.  It actually does a very good job of actually parsing columns from the CSV text.  I use Regex Replace( csvText, "[$1$2]" ) to actually see the column content, but there are many other ways (obviously).
# ID: 1527
# Multiline
((?:(?:"[^"]*")|('[^\r]*)(\r\n)?)*)([\s]*[,]|$) {CHANGED TO)(?<![\"\w\d\s])[\s]*(?:"((?:[^\"]|[\"]{2})*)"|([\w\d\s]+))[\s]*(?=[\,]|[\r\n]+|$)

# This RE matches the height in feet and inches with decimals and without decimals in it
# ID: 826
^\d?\d'(\d|1[01])?.?(\d|1[01])"$

# This regex only matches clean domain names. No path after. Ends in a forward slash. Starts with http://www. It is pretty slack on the TLD requiring a 2 or 3 letter ending. This part could be tightened up if you wanted to be restrict it to specific TLDs.
# ID: 2672
^http\://www.[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}/$

# Allows dashes or spaces to separate.
# ID: 2678
^[\d]{4}[-\s]{1}[\d]{3}[-\s]{1}[\d]{4}$

# Allows dashes or spaces to separate.
# ID: 2679
^[\d]{5}[-\s]{1}[\d]{3}[-\s]{1}[\d]{3}$

# Allows dashes or spaces to separate.
# ID: 2680
^[\d]{5}[-\s]{1}[\d]{2}[-\s]{1}[\d]{2}[-\s]{1}[\d]{2}$

# Allows dashes or spaces to separate.
# ID: 2681
^[\d]{5}[-\s]{1}[\d]{4}[-\s]{1}[\d]{2}$

# Allows dashes or spaces to separate.
# ID: 2682
^[\d]{5}[-\s]{1}[\d]{2}[-\s]{1}[\d]{4}$

# This might seem like a contrived example but it was written to answer a question on a forum. For regex newbies you can just change the numbers in {} to change the number of required digits to suit your requirements
# ID: 2739
^[0-9]{1,15}(\.([0-9]{1,2}))?$

# Validates the format of a UK bank sort code.
# ID: 2705
^(\d){2}-(\d){2}-(\d){2}$

# UK Bank account numbers are 8 digits. One bank uses 7 digits so in the validation error message you should instruct the user to prefix with a zero of their code is too short. If you want to allow the 7 digit codes as well use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2707
# ID: 2706
^(\d){8}$

# UK Bank Account. One bank account issues 7 digit bank codes and you should prefix a 0 yourself after input. If you want strict validation of 8 characters use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2706
# ID: 2707
^(\d){7,8}$

# No whitespace is allowed in a string
# ID: 2708
^[^\s]+$

# Matches the first part of a UK Postcode (known as a postcode district).
# ID: 2356
([A-PR-UWYZa-pr-uwyz]([0-9]{1,2}|([A-HK-Ya-hk-y][0-9]|[A-HK-Ya-hk-y][0-9]([0-9]|[ABEHMNPRV-Yabehmnprv-y]))|[0-9][A-HJKS-UWa-hjks-uw]))

# Validating a Facebook page can be a little bit tricky. This is because there are two valid formats. The first is facebook.com/pages/USERNAME/numbers/, the second is designed for big business which grants them a clean url such as facebook.com/coca-cola/.  I see this regex being used in a user profile admin page and I think it does a good enough job for this purpose. The problem is bad urls could slip through which meet the criteria for the clean facebook page url but aren't in valid pages on the site.
# ID: 3270
http[s]?://(www|[a-zA-Z]{2}-[a-zA-Z]{2})\.facebook\.com/(pages/[a-zA-Z0-9-]+/[0-9]+|[a-zA-Z0-9-]+)[/]?$

# This will match a youtube url and pull the video id out into a named capture group called VideoID. It is intentionally loose on the length and content of the video id so that it doesn't break in the future if YouTube change the format.
# ID: 3267
http://www\.youtube\.com.*v=(?'VideoID'[^&]*)

# Allows http and https, bans www prefix, username portion is clamped to the rules it gives you at signup and also allows an optional trailing slash. [UPDATED] optionally includes the #! notation that twitter now uses.
# ID: 3268
^http[s]?://twitter\.com/(#!/)?[a-zA-Z0-9]{1,15}[/]?$

# Because a regular expression only deals with a single character at a time it can be a challenge to work with numbers as they often contain multiple digits. This regex allows any number except the numbers in the list. It does this by using a negative look ahead to fail the regex if it finds an excluded number.
# ID: 3293
^(?!^(5|15|18|30)$)\d+$

# Add this on to the end of your url rewriting regex to allow an optional querystring to be appended to whatever you are matching. Useful for example when you set up a Google PPC campaign and all of your urls break. Note: doesn't handle #fragments.
# ID: 3444
(?:\?=.*)?$

# Designed for asp.net default document matching. It allows either a plain url (~/) or a default document url (~/default.aspx) both with an optional querystring. Cassini and IIS7 handle default document matching differently. The user could type it either way. The breadcrumb / sitemap system is funny about omitting default.aspx. Note: Doesn't handle #fragements
# ID: 3445
^~/(?:default\.aspx)?(?:\?=.*)?$

# This is an intentionally loose implementation. The number in the middle (account num) is constantly increasing as new accounts are made. The number on the end represents the profile number which shouldn't go over 50 but I haven't locked this down so that both elements are future proofed.
# ID: 3407
^UA-\d+-\d+$

# This is a simple regular expression which allows 1 to 99 in .5 increments which I originally developed for a forum post
# ID: 2784
^[1-9]{1,2}(.5)?$

# Based on ip regex listed in source. Expanded to require udp:// or norm:// protocol at the start and :12345 port number at the end (1-5 digits).
# ID: 2813
^(udp|norm)://(?:(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d)(?(?=\.?\d)\.)){4}:\d{1,6}$

# This was based on the regex in the source but it was buggy so I fixed it and then optimized it.
# ID: 2814
:(6553[0-5]|655[0-2][0-9]\d|65[0-4](\d){2}|6[0-4](\d){3}|[1-5](\d){4}|[1-9](\d){0,3})

# This is the same as my regex listed in the source except that it is wrapped in (regex)? which makes it optional. The intended use for this regex is to be combined with buggy url/ip regex's to strengthen the port matching. It matches port numbers in the form of :1 to :65535 and also allows no port to be entered. I noticed that a lot of url/ip regexs either didn't match the port or matched it badly (allowing the port number to start with a 0 or be higher than 65535) This regex solves those two problems.
# ID: 2815
(:(6553[0-5]|655[0-2][0-9]\d|65[0-4](\d){2}|6[0-4](\d){3}|[1-5](\d){4}|[1-9](\d){0,3}))?

# Based on the source listed below. I have added in the 05 prefix for allowing UK voip landlines. I dont know if the spacings are all ofcom approved like the original regex but the patterns it supports are:
# ID: 2805
^(02\d\s?\d{4}\s?\d{4})|((01|05)\d{2}\s?\d{3}\s?\d{4})|((01|05)\d{3}\s?\d{5,6})|((01|05)\d{4}\s?\d{4,5})$

# This uses named groups to extract the user and domain portions of an Active Directory user in user@domain format.
# ID: 2938
^(?<user>.+)@(?<domain>.+)$

# Identifies scheme, path, query, and fragment in any URI, putting them into named groups. All groups are optional except path.
# ID: 1795
(?m)^(?<scheme>\w+?://)?(?<path>(?:[\w.%$\-_+!*'(),=@]+\/|\b)+(?:[\w.%$\-_+!*'(),=@]*))(?<query>\?(?:[\w.%$\-_+!*'(),=@]+=[\w.%$\-_+!*'(),=@]*&?)*)?(?<fragment>#[\w\.%$\-_+!*'(),=@]*)?

# Matches complete table rows (<tr>...</tr>) and puts everything between the tr tags into a group named "content".
# ID: 1796
(?s)<tr[^>]*>(?<content>.*?)</tr>

# Matches name/value pairs in HTTP Query Strings, placing name into group named "name" and value into group named "value"
# ID: 1797
[\?&](?<name>[^&=]+)=(?<value>[^&=]+)

# Matches any legitimate METAR (Meterological Weather Report) string, and places parts into named groups, "ICAO", "DateUTC", "DayOfMonth", "Hour", "Minutes"
# ID: 1798
(?i)^(?:(?:METAR|SPECI)\s*)*(?<ICAO>[\w]{4})\s*?(?<DateUTC>(?<DayOfMonth>\d{0,2})(?<Hour>\d{2})(?<Minutes>\d{2}))Z{1}\s*(?:[^\r\n])*

# Matches a complete HTML href tag, placing the URL into a group named "url" and the innerHTML into a group named "innerHtml"
# ID: 1799
(?i)(?s)<a[^>]+?href="?(?<url>[^"]+)"?>(?<innerHtml>.+?)</a\s*>

# Captures all attributes in HTML anchor tags, putting them into groups named "name" and "value"
# ID: 1800
(?s)(?<=<a[^>]+?)(?<name>\w+)=(?:["']?(?<value>[^"'>]*)["']?)(?=.+?>)

# As I could understand the HTML standard, this is the valid reg.exp. for comments.
# ID: 793
<!--[\s\S]*?--[ \t\n\r]*>

# Follows http://en.wikipedia.org/wiki/Telephone_numbers_in_the_United_Kingdom
# ID: 3630
^0(((1[0-9]{2}[ -]?[0-9]{3}[ -]?[0-9]{4})|(1[0-9]{3}[ -]?[0-9]{6})|(1[0-9]{4}[ -]?[0-9]{4,5}))|((1[0-9]1)|(11[0-9]))[ -]?[0-9]{3}[ -]?[0-9]{4}|(2[0-9][ -]?[0-9]{4}[ -]?[0-9]{4})|((20[ -]?[0-9]{4})|(23[ -]?[8,9][0-9]{3})|(24[ -]?7[0-9]{3})|(28[ -]?(25|28|37|71|82|90|92|95)[0-9]{2})|(29[ -]?2[0-9]))[ -]?[0-9]{4}|(7[4-9][0-9]{2}[ -]?[0-9]{6})|((3[0,3,4,7][0-9])[ -]?[0-9]{3}[ -]?[0-9]{4})|((5[5,6][ -]?[0-9]{4}[ -]?[0-9]{4})|(500[ -]?[0-9]{3}[ -]?[0-9]{4}))|(8[0247][0-9]{1}[ -]?[0-9]{3}[ -]?[0-9]{4})|(9[0-9]{2}[ -]?[0-9]{3}[ -]?[0-9]{4}))$

# Use this expression to check that a valid web address is used without any protocol.
# ID: 2189
^([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$

# This expression will validates most of the email formats.
# ID: 2158
/^([a-zA-Z0-9])(([\-.]|[_]+)?([a-zA-Z0-9]+))*(@){1}([a-z0-9]|([a-z0-9][\-]))+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$/

# This expresssion will validate all possible formats except if web site URL contains hyphen characters like aa@a-b-c.com. I will include this feature also in next version.
# ID: 1757
/^([a-zA-Z0-9])(([\-.]|[_]+)?([a-zA-Z0-9]+))*(@){1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$/

# An URL validation pattern with respect for TLD domains. It also validates ip urls, but it doesn't check for ip single parts range (1-255). It supports port specification.
# ID: 1885
(http|https)\:\/\/(([\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}\.[\d]{1,3})|([\w\-]+\.)+(((af|ax|al|dz|as|ad|ao|ai|aq|ag|am|aw|au|at|az|bs|bh|bd|bb|by|be|bz|bj|bm|bt|bo|ba|bw|bv|br|io|bn|bg|bf|kh|cm|ca|cv|ky|cf|td|cl|cn|cx|cc|km|cg|cd|ck|cr|ci|hr|cu|cy|cz|dk|dj|dm|do|ec|eg|sv|gq|er|ee|et|fk|fo|fj|fi|fr|gf|pf|tf|ga|gm|ge|de|gh|gi|gr|gl|gd|gp|gu|gt| gg|gn|gw|gy|ht|hm|va|hn|hk|hu|is|id|ir|iq|ie|im|il|it|jm|jp|je|jo|kz|ke|ki|kp|kr|kw|kg|la|lv|lb|ls|lr|ly|li|lt|lu|mo|mk|mg|mw|my|mv|ml|mt|mh|mq|mr|yt|mx|fm|md|mc|mn|ms|ma|mz|mm|nr|np|nl|an|nc|nz|ni|ng|nu|nf|mp|no|om|pk|pw|ps|pa|pg|py|pe|ph|pn|pl|pt|qa|re|ro|ru|rw|sh|kn|lc|pm|vc|ws|sm|st|sa|sn|cs|sc|sl|sg|sk|si|sb|so|za|gs|es|lk|sd|sr|sj|sz|se|ch|sy|tw|tj|tz|th|tl|tg|tk|to|tt|tn|tr|tm|tc|tv|ug|ua|gb|us|um|uy|uz|vu|ve|vn|vg|vi|wf|eh|ye|zm|zw|uk|com|edu|gov|int|mil|net|org|biz|info|name|pro|aero|coop|museum|arpa|co|in|ne|bi|na|pr|ae|mu|ar))))(:[\d]{1,4})?($|(\/([a-zA-Z0-9\.\?=/#%&\+-])*)*|\/)

# Email validation regular expression. It checks for TLD domain correctness and supports for IP addresses. It doesn't check for ip single parts range validity (1-255).
# ID: 1886
([\w\-\.]*)@(([\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}\.[\d]{1,3})|([\w\-]+\.)+(((af|ax|al|dz|as|ad|ao|ai|aq|ag|am|aw|au|at|az|bs|bh|bd|bb|by|be|bz|bj|bm|bt|bo|ba|bw|bv|br|io|bn|bg|bf|kh|cm|ca|cv|ky|cf|td|cl|cn|cx|cc|km|cg|cd|ck|cr|ci|hr|cu|cy|cz|dk|dj|dm|do|ec|eg|sv|gq|er|ee|et|fk|fo|fj|fi|fr|gf|pf|tf|ga|gm|ge|de|gh|gi|gr|gl|gd|gp|gu|gt| gg|gn|gw|gy|ht|hm|va|hn|hk|hu|is|id|ir|iq|ie|im|il|it|jm|jp|je|jo|kz|ke|ki|kp|kr|kw|kg|la|lv|lb|ls|lr|ly|li|lt|lu|mo|mk|mg|mw|my|mv|ml|mt|mh|mq|mr|yt|mx|fm|md|mc|mn|ms|ma|mz|mm|nr|np|nl|an|nc|nz|ni|ng|nu|nf|mp|no|om|pk|pw|ps|pa|pg|py|pe|ph|pn|pl|pt|qa|re|ro|ru|rw|sh|kn|lc|pm|vc|ws|sm|st|sa|sn|cs|sc|sl|sg|sk|si|sb|so|za|gs|es|lk|sd|sr|sj|sz|se|ch|sy|tw|tj|tz|th|tl|tg|tk|to|tt|tn|tr|tm|tc|tv|ug|ua|gb|us|um|uy|uz|vu|ve|vn|vg|vi|wf|eh|ye|zm|zw|uk|com|edu|gov|int|mil|net|org|biz|info|name|pro|aero|coop|museum|arpa|co|in|ne|bi|na|pr|ae|mu|ar)))?)

# Password length must be between 7 and 20 characters, include at least one alphabetic and one numeric character, and may include some special characters.
# ID: 2551
(?=^.{7,20}$)(?=.*\d)(?=.*[a-zA-Z])(?!.*\s)[0-9a-zA-Z*$-+?_&=!%{}/'.]*$

# This regular expression provides a way to get the value associated to the specified key in the specified section: replace with $1.
# ID: 3573
[^]*\[section\][^\[]*\nkey=(.+)[^]*

# This pattern matches italian mobile phone numbers:
# ID: 2998
^([+]39)?\s?((313)|(32[03789])|(33[013456789])|(34[0256789])|(36[0368])|(37[037])|(38[0389])|(39[0123]))[\s-]?([\d]{7})$

# Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document.  Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters.  Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).
# ID: 1086
&\#x0*(0|1|2|3|4|5|6|7|8|B|C|E|F|10|11|12|13|14|15|16|17|18|19|1A|1B|1C|1D|1E|1F);

# RAR file extensions.
# ID: 996
^\.([rR]([aA][rR]|\d{2})|(\d{3})?)$

# Match a start/end XML tag
# ID: 2762
(?<STag><)[/\?\s]*(?<Prefix>\w*:)*(?<TagName>\w*)\s*(?<Attributes>(?<Attribute>((?<AttributePrefix>\w*)\s*:\s*)*(?<AttributeName>\w*)\s*=\s*(?<AttributeValue>"[^"]*"|'[^']*'|[^>\s]*)\s*)*)\s*/?(?<ETag>>)

# Validates Austrian Cellular Phone Numbers. Works with ONE, T-Mobile, A1, Telering and new Provider "Drei". WITHOUT Country Code Verification.
# ID: 362
^0(6[045679][0469]){1}(\-)?(1)?[^0\D]{1}\d{6}$

# This is a little goofy regex to allow punctuation. I was reluctant to post it but what the heck. If it puts a smile on somebody's face then it was worth it. It sort of works. :)
# ID: 2103
^((\'|\")?[a-zA-Z]+(?:\-[a-zA-Z]+)?(?:s\'|\'[a-zA-Z]{1,2})?(?:(?:(?:\,|\.|\!|\?)?(?:\2)?)|(?:(?:\2)?(?:\,|\.|\!|\?)?))(?: (\'|\")?[a-zA-Z]+(?:\-[a-zA-Z]+)?(?:s\'|\'[a-zA-Z]{1,2})?(?:(?:(?:\,|\.|\!|\?)?(?:\2|\3)?)|(?:(?:\2|\3)?(?:\,|\.|\!|\?)?)))*)$

# A simple regex to validate an embedded YouTube video.
# ID: 2107
(\"http:\/\/www\.youtube\.com\/v\/\w{11}\&rel\=1\")

# A simple regex for validating an embedded Google video.
# ID: 2108
(\"http:\/\/video\.google\.com\/googleplayer\.swf\?docId=\d{19}\&hl=[a-z]{2}\")

# Here's a regex for a person's name. Simple but effective.
# ID: 2114
^([a-zA-Z]+(?:\.)?(?: [a-zA-Z]+(?:\.)?)*)$

# Here's a regex for a title. The title may contain basic punctuation and may not have leading or trailing spaces or underscores but that's about it.
# ID: 2115
^([^_][\w\d\@\-]+(?:s\'|\'[a-zA-Z]{1,2})?(?:\,)?(?: [\w\d\@\-]+(?:s\'|\'[a-zA-Z]{1,2})?(?:\,)?)*(?:\.|\!|\?){0,3}[^\s_])$

# Here's another one for numbers. Any kind of number. Money, percentage, ect. Commas are optional and must be properly formatted.
# ID: 2116
^((?:\+|\-|\$)?(?:\d+|\d{1,3}(?:\,\d{3})*)(?:\.\d+)?(?:[a-zA-Z]{2}|\%)?)$

# A URL to a domain name. Only for http but that can be changed easily to accept more. the dashes and undescores can only be used between text and/or digits. The slash on the end is optional
# ID: 2117
^(http\:\/\/(?:www\.)?[a-zA-Z0-9]+(?:(?:\-|_)[a-zA-Z0-9]+)*(?:\.[a-zA-Z0-9]+(?:(?:\-|_)[a-zA-Z0-9]+)*)*\.[a-zA-Z]{2,4}(?:\/)?)$

# My simple but effective password regex. The password can only contain letters and/or digits and must be at least 6 characters long and no more than 20. I know it says {4,18} but it just works out that way. The question mark was added for optimization. Also, the password can not begin or end with a space or underscore.
# ID: 2112
^([a-zA-Z0-9]{4,18}?)$

# An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice.
# ID: 2068
^((?:\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\-[a-zA-Z0-9]+)*)+)$

# This is a very basic regex for a simple name or title. It must begin and end with a word character and may contain spaces. No punctuation :(
# ID: 2069
^([a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*)$

# The IANA resrved 24-bit block of IP address space for private internets. It's just a single class A network number. This is also RFC 1918 compliant.
# ID: 2095
^(10\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5]\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5]\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5])$

# This is a set of 16 contiguous class B network numbers or a 16-bit block of ip address space as reserved by the IANA. RFC 1918 compliant.
# ID: 2096
^(172\.1[6-9]|2[0-9]|3[0-1|\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5]\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5])$

# This is the 16-bit block of the IP address space for private internets reserved by the IANA. A set of 256 contiguous class C network numbers per RFC 1918.
# ID: 2097
^(192\.168\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5]\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5])$

# After reading RFC2396 and researching it a little more I put together this regex rather than update my non-compliant, overly simple one. More specificaly an absolute path.
# ID: 2088
^(/(?:(?:(?:(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]+|(?:%[a-fA-F0-9][a-fA-F0-9]))*)(?:;(?:(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]+|(?:%[a-fA-F0-9][a-fA-F0-9]))*))*)(?:/(?:(?:(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]+|(?:%[a-fA-F0-9][a-fA-F0-9]))*)(?:;(?:(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]+|(?:%[a-fA-F0-9][a-fA-F0-9]))*))*))*))$

# This is my simple phone number regex. There are many like it but this is mine. It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.) or a space. Putting the area code in parenthesis is also an option. That's about it.
# ID: 2089
^(1?(?: |\-|\.)?(?:\(\d{3}\)|\d{3})(?: |\-|\.)?\d{3}(?: |\-|\.)?\d{4})$

# Just for UZ zip codes. The post office number is optional.
# ID: 2090
^(\d{5}(?:\-\d{4})?)$

# A properly formatted US social security number. first three digits must be 001 - 772.
# ID: 2091
^(00[1-9]|0[1-9][0-9]|[1-6][0-9][0-9]|7[0-6][0-9]|77[0-2]\-\d{2}\-\d{4})$

# This is a regular expression to check for a properly formatted date according to the international date and time notation ISO 8601. See ISO 8601 specification for more information.
# ID: 2092
^(\d{4}(?:(?:(?:\-)?(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6]))?|(?:(?:\-)?(?:1[0-2]|0[1-9]))?|(?:(?:\-)?(?:1[0-2]|0[1-9])(?:\-)?(?:0[1-9]|[12][0-9]|3[01]))?|(?:(?:\-)?W(?:0[1-9]|[1-4][0-9]5[0-3]))?|(?:(?:\-)?W(?:0[1-9]|[1-4][0-9]5[0-3])(?:\-)?[1-7])?)?)$

# This is a regular expression to check for a properly formatted time according to the international date and time notation ISO 8601. See ISO 8601 specification for more information.
# ID: 2093
^([0-2][0-4](?:(?:(?::)?[0-5][0-9])?|(?:(?::)?[0-5][0-9](?::)?[0-5][0-9](?:\.[0-9]+)?)?)?)$

# This regex looks for Randal.
# ID: 2241
^(Randal (?:L\.)? Schwartz|merlyn)$

# This is a very simple regex that check the query part of a string. That is to say anything after the "?" at the end of an URL.
# ID: 1882
^((?:\?[a-zA-Z0-9_]+\=[a-zA-Z0-9_]+)?(?:\&[a-zA-Z0-9_]+\=[a-zA-Z0-9_]+)*)$

# A simple but powerful URL validating regex. Accepts multiple subdomains and subdirectories. Even accept query strings.
# ID: 1854
^(http(?:s)?\:\/\/[a-zA-Z0-9\-]+(?:\.[a-zA-Z0-9\-]+)*\.[a-zA-Z]{2,6}(?:\/?|(?:\/[\w\-]+)*)(?:\/?|\/\w+\.[a-zA-Z]{2,4}(?:\?[\w]+\=[\w\-]+)?)?(?:\&[\w]+\=[\w\-]+)*)$

# After reading RFC2822 (then taking two asprin) I've come to the conclusion that I will not allow all RFC compliant email addresses to be entered at the forms on my site and will never have an issue with it. I re-enabled this regex, with a little user suggested edit, because I demand a stricter tolerance for my website than RFC allows. If you're like me and only want to allow minimal characters, then use this regex. Also, I've never met anyone who would submit an email address taking full advantage of RFC2822's allowances nor would I care to accomodate one who would.
# ID: 1855
^([a-zA-Z0-9]+[a-zA-Z0-9._%-]*@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,4})$

# A nice little regex to verify a URL pointing towards an image. Can be useful.
# ID: 1856
^(http\:\/\/[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(?:\/\S*)?(?:[a-zA-Z0-9_])+\.(?:jpg|jpeg|gif|png))$

# This is an expression I sometimes use to verify segments in a URL or directory path. It must begin and end with a word character and may contain "_" "-" and "." one at a time. It's non-capturing as it sits. More restrictive than RFC2396 and used to prevent directory transversal holes.
# ID: 3236
(?:[a-zA-Z0-9]+(?:(?:_|\-|\.)[a-zA-Z0-9]+)*)

# This is a little regex to verify domain style names per RFC952. This is also found in RFC1034 and both use the terms domain name and host name interchangeably even though I believe there may be a difference. Only alpha, digit, and dashes allowed with a dot as delimiter. Must begin with alpha and not end with a dash or dot. No spaces.
# ID: 3237
(?:[^0-9][a-zA-Z0-9]+(?:(?:\-|\.)[a-zA-Z0-9]+)*)

# Here's my relaxed version of an URL regex. This one accepts just about anything but a double dot but still must resemble an URL to pass. Also doesn't accept out of place meta characters.
# ID: 3238
^(\w{3,6}\:\/\/[\w\-]+(?:\.[\w\-]+)+(?:\:\d{2,4})*(?:\/?|(?:\/[\w\-]+)*)(?:\/?|\/\w+\.\w{2,4}(?:\?[\w]+\=[\w\-]+)?)?(?:\&[\w]+\=[\w\-]+)*)$

# This expression check the input of simple text string from a-z,A-Z and number from 0 to 9 and the dot(.).
# ID: 2061
^[a-zA-Z0-9\.\s]{3,}$

# This was written for quick entry on a timecard system.  It allows you to create a number with an option of 2 decimal places.  I have the digits left of the decimal unrestricted for this example, but in the real world of time keeping, you wouldn't surpass 3 digits on the left of the decimal.
# ID: 866
^(\d+|(\d*\.{1}\d{1,2}){1})$

# This expression pulls the Culture name out of a .resx file name.
# ID: 1068
# Multiline
(?i:)(?<=\.)\D\D(?:-\D{2,3}?(?:-\D\D\D\D)?)?(?=.resx)

# US Phone number with optional leading 1, optional area code, and optional delimiters (hyphen, space or period)
# ID: 1458
^1?[-\. ]?(\(\d{3}\)?[-\. ]?|\d{3}?[-\. ]?)?\d{3}?[-\. ]?\d{4}$

# Regular Expression for Egypt Mobile Network [ Last update 11 numbers ]
# ID: 3385
^01[0-2]{1}[0-9]{8}

# This simple regular expression comes handy when we need to validate a version number of a document. The version numbers can have decimals upto two decimal places
# ID: 1423
^((\d)?(\d{1})(\.{1})(\d)?(\d{1})){1}$

# this expression is one of the best username regular expressions
# ID: 3048
[A-Za-z](\.[A-Za-z0-9]|\-[A-Za-z0-9]|_[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9])(\.[A-Za-z0-9]|\-[A-Za-z0-9]|_[A-Za-z0-9]|[A-Za-z0-9])*

# All emails listed below are to be created and You can try all of them on the domain name listed!
# ID: 3041
^[A-Za-z0-9](\.[\w\-]|[\w\-][\w\-])(\.[\w\-]|[\w\-]?[\w\-]){0,30}[\w\-]?@[A-Za-z0-9\-]{3,63}\.[a-zA-Z]{2,6}$

# [Default]
# ID: 383
<!--.*?-->

# validates private ip addresses
# ID: 2822
^(1(0|7|9)2?)\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$

# Heres my sql clause parser regexp for recordset filtering. Does recursive query parsing all by its self. Only problem I cant figure is how to match comma separated lists of quoted strings. Tell me if you figure out how!
# ID: 347
(NOT)?(\s*\(*)\s*(\w+)\s*(=|<>|<|>|LIKE|IN)\s*(\(([^\)]*)\)|'([^']*)'|(-?\d*\.?\d+))(\s*\)*\s*)(AND|OR)?

# Simple expression that accepts only values between 1 and 1.5
# ID: 854
(^[1]$)|(^[1]+\d*\.+\d*[1-5]$)

# Matches HTML Color strings. Like #FFFFFF is white and #000000 is black and #FF0000 is red and so on...
# ID: 372
^(#){1}([a-fA-F0-9]){6}$

# Zip Code (Zip or Zip-Plus4 format).  Accepts a hyphen, a space, or nothing between Zip and Plus4 segments.  Named segments <zip> and <plus4> may be used to reformat users input to desired format using Regex replace function (re.replace).
# ID: 931
(?<zip5>^\d{5})([\- ]?(?<plus4>\d{4})?$)

# Single field zip code validator, useful for Web Forms.  Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits.
# ID: 924
^\d{5}((-|\s)?\d{4})?$

# Single field zip code validator useful for web forms, where user may enter 5 digit or 9 digit zip code, and may use hyphen, space, or no space between the first 5 digits and last 4 digits.
# ID: 925
^\d{5}((\-|\s)?\d{4})?$

# Telephone validator allowing user to enter 10 digit telephone number with segments of number separated by hyphens, periods or spaces.  Also braces allowed around area code.
# ID: 926
^(\([2-9]|[2-9])(\d{2}|\d{2}\))(-|.|\s)?\d{3}(-|.|\s)?\d{4}$

# US telephone number with area code.  Validates and also captures AreaCode, Prefix and Suffix for reformatting.
# ID: 929
^\(?(?<AreaCode>[2-9]\d{2})(\)?)(-|.|\s)?(?<Prefix>[1-9]\d{2})(-|.|\s)?(?<Suffix>\d{4})$

# This will extract the Video Id From Video URL which the number sequence and will check url.. make sure its a valid link - expression is in PHP format
# ID: 2794
/http:\\/\/(?:www.)?clipser\.com\/watch_video\/([0-9a-z-_]+)/i

# extract video id from blip.tv url - expression is in PHP format
# ID: 2795
/http:\/\/(?:www\.)?blip\.tv\/file\/(\d+).*/

# Needed this to Detect onClick javascript in href tags and strip put with PHP scraping html source
# ID: 2796
/\\(?<\w+[^>]*\son\w+=.*[ \/].?>(?:\))?/i

# This will extract the Video Id From Google Video URL which the number sequence after docid= and will check url.. make sure its a valid google link
# ID: 2785
/http:\\/\/\.?video.google.\w{2,3}\/videoplay\?docid=([a-z0-9-_]+)/i

# This regular expression matches 10 digit US Phone numbers in different formats. Some examples are
# ID: 283
^\(?[\d]{3}\)?[\s-]?[\d]{3}[\s-]?[\d]{4}$

# Updated to exclude 127/8
# ID: 148
^(((25[0-5]|2[0-4][0-9]|19[0-1]|19[3-9]|18[0-9]|17[0-1]|17[3-9]|1[3-6][0-9]|12[8-9]|12[0-6]|1[0-1][0-9]|1[1-9]|[2-9][0-9]|[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]))|(192\.(25[0-5]|2[0-4][0-9]|16[0-7]|169|1[0-5][0-9]|1[7-9][0-9]|[1-9][0-9]|[0-9]))|(172\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|1[0-5]|3[2-9]|[4-9][0-9]|[0-9])))\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$

# This expression is not working for this +91-020-41056767. If i enter +91555-020555-41056767 still its working. Please help me. Send me the correct expression on my email id cgadgilwar@gmail.com
# ID: 2808
/((\d){2})?(\s|-)?((\d){2,4})?(\s|-){1}((\d){8})$/

# validate percentage value passed as a string. Uses posix syntax only so it can be safely used in oracle 10g+ REGEX_SUBSTR and the likes...
# ID: 3264
^(-|\+)?(((100|((0|[1-9]{1,2})(\.[0-9]+)?)))|(\.[0-9]+))%?$

# IP v6 regular expression that matches non-collapsed address in hexadecimal representation
# ID: 3672
^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$

# Will verify if the text is is in a valid user name format like: is alphanumeric, starts with an alphabet and contains no special characters other than underscore or dash.
# ID: 2298
^([a-zA-Z])[a-zA-Z_-]*[\w_-]*[\S]$|^([a-zA-Z])[0-9_-]*[\S]$|^[a-zA-Z]*[\S]$

# Verifies if it is a 12 digit phone number or a list of comma separated 12 digit phone numbers.
# ID: 2299
^([0-9]{12},)+[0-9]{12}$|^([0-9]{12})$

# Validates a file path on your local drive or a network drive. A similar one was written by Vinod Kumar but it does not reject asterisks in the path. Moreover, his did not work with RegularExpressionValidators. This one does.
# ID: 191
^([a-zA-Z]\:|\\)\\([^\\]+\\)*[^\/:*?"<>|]+\.htm(l)?$

# More flexible date validator. Allows either spaces, / or - as dividers, also allows for fully uppercase months, year as 4 digit.
# ID: 400
^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\s{1}|\/|-](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\s{1}|\/|-]\d{4}$

# This Regular Expression matches all valid ip-patterns.
# ID: 1237
^((25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]\.){3}(25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]))$

# This particular expression tests an integer value to see if it's equal to or greater than 250.
# ID: 2926
^\d{4,}$|^[3-9]\d{2}$|^2[5-9]\d$

# I have worked on this regular expression to get valid numbers from users. Its really simple, but yes required alot of my time and attention to make it work perfectly. It was my very first creation of regular expression.
# ID: 1726
(?!^([0-9]+[-]?[0-9]+)$)(?!^([0-9]+[[\\s]*]?[0-9]+)$)^([0-9]+\.?[0-9]+$|(^[-]?[0-9]+([[\\s]*]?)$)|^([-]?)[0-9]+\.?[0-9]+([[\\s]*]?)|([0-9]+))$

# This regular expression validates for a user id. The expression was built by keeping the rules of defining a variable in c++.
# ID: 1727
(?!^([0-9]+)([[\\s]*]?)$)(?!^([0-9]+)[[a-zA-Z]*]?([[\\s]*]?)$)^([_]?([a-zA-Z0-9]+)([[\\s]*]?))$

# Latitude and Longitude in Degrees Minutes Seconds (DMS) zero padded, separated by spaces or : or (d, m, s) or (°, ', ") or run together and followed by cardinal direction initial (N,S,E,W)
# ID: 3554
(-?(90[ :°d]*00[ :\'\'m]*00(\.0+)?|[0-8][0-9][ :°d]*[0-5][0-9][ :\'\'m]*[0-5][0-9](\.\d+)?)[ :\?\"s]*(N|n|S|s)?)[ ,]*(-?(180[ :°d]*00[ :\'\'m]*00(\.0+)?|(1[0-7][0-9]|0[0-9][0-9])[ :°d]*[0-5][0-9][ :\'\'m]*[0-5][0-9](\.\d+)?)[ :\?\"s]*(E|e|W|w)?)

# Latitude and Longitude in Decimal Degrees useful for X (longitude), Y (latitude) coordinate systems such as WGS84.
# ID: 3555
((X|x):-?(180(\.0+)?|[0-1]?[0-7]?[0-9](\.\d+)?))([ ]|,)*((Y|y):-?(90(\.0+)?|[0-8]?[0-9](\.\d+)?))

# Validate an hour entry to be between 00:00 and 23:59
# ID: 176
([0-1][0-9]|2[0-3]):[0-5][0-9]

# This pattern matches numbers separated by comma
# ID: 1714
^([0-9][,]?)*([0-9][0-9])$

# This expression matches string started with " or ' and ended with " or '
# ID: 3214
/^"|'+(.*)+"$|'$/

# This matches an IP address, putting each number in its own group that can be retrieved by number. If you do not care about capturing the numbers, then you can make this shorter by putting everything after ^ until immediately after the first \. in a group ( ) with a {3} after it. Then put the number matching regex in once more.
# ID: 194
^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$

# This regular expression is intended to limit numeric entries by allowed places before and after the decimal point.  It also recognizes whole numbers.  In this example the value cannot exceed 99999.999.  To change the range, simply edit the numbers in curly braces.  For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}.  This can be useful for numeric fields in SQL.  This example was made to accommodate a numeric(8,3) field definition.
# ID: 1879
^([0-9]{0,5}|[0-9]{0,5}\.[0-9]{0,3})$

# This will check if a number is an integer.  Positive integers are all the whole numbers greater than zero: 1, 2, 3, 4, 5, ... . Negative integers are all the opposites of whole numbers: -1, -2, -3,-4, -5, ... .  Zero is not a whole number with either a positive or negative value, and is not an interger.  Null or Empty values are not intergers.
# ID: 268
^[-+]?[1-9]\d*\.?[0]*$

# This is regular expression that check for a particular date match in the following format respectively: DD-MM-YYYY and is only valid for the years between 1900 - 1999
# ID: 2060
^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|11|12|10)-(19[0-9]{2})$

# Allows positive(non-negative) decimal values with 2 floating point values and less than or equal to 24.
# ID: 2804
^([0-2]{0,1})([0-3]{1})(\.[0-9]{1,2})?$|^([0-1]{0,1})([0-9]{1})(\.[0-9]{1,2})?$|^-?(24)(\.[0]{1,2})?$|^([0-9]{1})(\.[0-9]{1,2})?$

# For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.
# ID: 875
^((\s|[0])\.(\d{0,2}\s{0,2}))?$|^(\.(\d\s){0,2})?$|^(\s{0,4}[1]{0,1}\.[0]{0,2}\s{0,4})?$|^(\s{0,4}[1]{0,1}\s{0,4})?$|^(\s{0,4}[0]{0,4}[1]{0,1}\s{0,4})?$|^([0]{0,4}\s{0,4})?$|^(\s{0,3}[0]{0,3}\.{1}\d{0,2}\s{0,2})?$

# Broad URL Validator
# ID: 3449
^(?:http|https):\/\/[\w.\-]+(?:\.[\w\-]+)+[\w\-.,@?^=%&:;/~\\+#]+$

# improved date validation M/D/YY or M/D/YYYY or MM/DD/YYYY or MM/DD/YY: 1/1/1920 through 12/31/2019; Feb 29 and 30 always allowed, deal with it
# ID: 235
^((0?[13578]|10|12)(-|\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[01]?))(-|\/)((19)([2-9])(\d{1})|(20)([01])(\d{1})|([8901])(\d{1}))|(0?[2469]|11)(-|\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[0]?))(-|\/)((19)([2-9])(\d{1})|(20)([01])(\d{1})|([8901])(\d{1})))$

# Chemical Abstract Service Registry Number (CAS Nr). Identify chemical substance or mixture.
# ID: 1221
^\d{2,6}-\d{2}-\d$

# International Bank Account Number (IBAN) Czech. Identify Bank account in Czech Republic.
# ID: 1222
CZ\d{2}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}|CZ\d{22}

# International Bank Account Number (IBAN) Slovak. Identify Bank account in Slovak Republic.
# ID: 1223
SK\d{2}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}|SK\d{22}

# International Bank Account Number (IBAN) Andorra. Identify Bank account in Andorra.
# ID: 1224
AD\d{2}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}|AD\d{22}

# International Bank Account Number (IBAN) Spain. Identify Bank account in Spain.
# ID: 1225
ES\d{2}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}|ES\d{22}

# International Bank Account Number (IBAN) Sweden. Identify Bank account in Sweden.
# ID: 1226
SE\d{2}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}|SE\d{22}

# International Bank Account Number (IBAN) Switzerland. Identify Bank account in Switzerland.
# ID: 1227
CH\d{2}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{1}|CH\d{19}

# International Bank Account Number (IBAN) Germany. Identify Bank account in Germany.
# ID: 1228
DE\d{2}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{2}|DE\d{20}

# International Bank Account Number (IBAN) Poland. Identify Bank account in Poland.
# ID: 1229
PL\d{2}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}[ ]\d{4}|PL\d{26}

# This regex attempts to "linkify" a url that isn't already part of an <a> tag.
# ID: 1888
\b(ht|f)tp[s]?://[^\s\n\r\t\<\>]+(?=[\b\s\n\r\t\<])

# This expression allow controling to formatted numeric values.
# ID: 3212
^(\d{1.3}(\.\d{3})*|(\d+))(\,\d{1})|(\d{1.3}(\.\d{3})*|(\d+))(\,\d{2})?$

# You can change \. separator with which you need as a separator like \, (en-US numbers separator) or \. (tr-TR numbers separator) etc.
# ID: 3213
^(\d{1}|\d{2}|\d{3})(\.\d{3})*?$

# This regular expression will match the all type of credit card patterns, like AMEX,VISA,MASTER, Dinnerclub, JCB, enRoute ,Discover
# ID: 1815
(4\d{12})|(((4|3)\d{3})|(5[1-5]\d{2})|(6011))(-?|\040?)(\d{4}(-?|\040?)){3}|((3[4,7]\d{2})((-?|\040?)\d{6}(-?|\040?)\d{5}))|(3[4,7]\d{2})((-?|\040?)\d{4}(-?|\040?)\d{4}(-?|\040?)\d{3})|(3[4,7]\d{1})(-?|\040?)(\d{4}(-?|\040?)){3}|(30[0-5]\d{1}|(36|38)\d(2))((-?|\040?)\d{4}(-?|\040?)\d{4}(-?|\040?)\d{2})|((2131|1800)|(2014|2149))((-?|\040?)\d{4}(-?|\040?)\d{4}(-?|\040?)\d{3})

# Validates time that's formatted by the ajax MaskedEditEditor (typically in 00:00 AM/PM). Validates 12/24 hour times.
# ID: 2903
^ *([0-1]?[0-9]|[2][0-3]):[0-5][0-9] *(a|p|A|P)(m|M) *$

# This .NET regular expression matches all valid dates in dd/MM/yyyy , dd-MM-yyyy or dd MM yyyy formats between 1/1/0000 and 31/12/9999 with the leading zero for the day and month portions being optional. The century for the year is optional for all dates except for the 29th of February of century years divisible by 400. This expression also validates the 29th of February for leap years, defined as (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0).
# ID: 3117
^\s*((31([-/ ])((0?[13578])|(1[02]))\3(\d\d)?\d\d)|((([012]?[1-9])|([123]0))([-/ ])((0?[13-9])|(1[0-2]))\12(\d\d)?\d\d)|(((2[0-8])|(1[0-9])|(0?[1-9]))([-/ ])0?2\22(\d\d)?\d\d)|(29([-/ ])0?2\25(((\d\d)?(([2468][048])|([13579][26])|(0[48])))|((([02468][048])|([13579][26]))00))))\s*$

# Canadian Branch-Transit number test.
# ID: 757
^(\d{3}|\d{4})[-](\d{5})$

# [Default]
# ID: 785
(-\d{1,} | \d{1,} | \d{1,}-\d{1,} | \d{1,}-)(,(-\d{1,} | \d{1,} | \d{1,}-\d{1,} | \d{1,}))*

# Quick and simple way of matching a well-formed IPV4 (dotted quad) ip address.
# ID: 1801
\d\d?\d?\.\d\d?\d?\.\d\d?\d?\.\d\d?\d?

# I think this is one of the website url we can validate
# ID: 1616
(http://|)(www\.)?([^\.]+)\.(\w{2}|(com|net|org|edu|int|mil|gov|arpa|biz|aero|name|coop|info|pro|museum))$

# Matches Brazilian phone numbers, includes DDD (long-distance call) with or without 0. Accepts characters -, . and [space] as separators.
# ID: 1521
^((\(0?[1-9][0-9]\))|(0?[1-9][0-9]))[ -.]?([1-9][0-9]{3})[ -.]?([0-9]{4})$

# This pattern matches most international phone numbers using various versions of phone number patters.
# ID: 1395
^(1\s*[-\/\.]?)?(\((\d{3})\)|(\d{3}))\s*([\s-./\\])?([0-9]*)([\s-./\\])?([0-9]*)$

# Validates a decimal with up to 8 whole places and up to two decimal places
# ID: 2183
^(\d{1,8}|(\d{0,8}\.{1}\d{1,2}){1})$

# Does not allow these characters in a string #$%^&*()'
# ID: 799
^(a-z|A-Z|0-9)*[^#$%^&*()']*$

# Validates US currency but allows for spaces between the dollar sign and dollar amount. If there is cents the period validates to two decimal places
# ID: 1052
^\$( )*\d*(.\d{1,2})?$

# It can be used to validate Font Sizes.
# ID: 462
^\d+\x20*([pP][xXtT])?$

# Alphanumeric expression with spaces
# ID: 601
^[a-zA-Z0-9\s]+$

# the regex's on this site for pulling links off a page always seemed to be faulty, or at least never worked with PHP, so i made this one.  simple, as i'm an amateur with regex's, but stumbled thru it and this one actually works.  tested with PHP function: preg_match_all("/href[ ]*=[ ]*('|\")([^\"'])*('|\")/",$string,$matches)
# ID: 758
href[ ]*=[ ]*('|\")([^\"'])*('|\")

# Matches a string if it is valid in the form of MWF or TTHS.  Maybe used for validating the "days part" of a class schedule field.  The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU' .  Only one instance of these set of letters is accepted.
# ID: 1556
^M{0,1}T{0,1}W{0,1}(TH){0,1}F{0,1}S{0,1}(SU){0,1}$

# Matches a string if it is a valid time in the format of "HH:MM AM" or "HH:MM A".
# ID: 1557
^(([0][0-9]|[1][0-2])|[0-9]):([0-5][0-9])( *)((AM|PM)|(A|P))$

# Parses most phone numbers into four groups: country code, area code, number, and extension.
# ID: 3390
^(?:[\+]?[\(]?([\d]{1,3})[\s\-\.\)]+)?(?:[\(]?([\d]{1,3})[\s\-\/\)]+)([2-9][0-9\s\-\.]{6,}[0-9])(?:[\s\D]+([\d]{1,5}))?$

# The goal of my regular expression is to allow me to break apart IP Table log files so that I can build a basic web front-end to allow me to view the traffic on the network. The MAC address is optional, because the way that this firewall works, is by providing the MAC address when the outbound address is not available.
# ID: 1441
^(?<Date>.+\s\d+\s\d+\:\d+\:\d+).+\:.+\:(?<Traffic>.+)\:(?<Rule>.+)\:IN\=(?<InboundInterface>.+)\sOUT\=(?<OutboundIntercace>.*?)\s(?:MAC\=(?<MacAddress>.+)\s|)SRC\=(?<Source>.+)\sDST\=(?<Destination>.+)\sLEN\=.+TOS\=.+PROTO\=(?<Protocol>.+)\sSPT\=(?<SourcePort>.+)\sDPT\=(?<DestinationPort>.+)\s.+$

# Parses command line strings into name value pairs
# ID: 1166
(?<=[-{1,2}|/])(?<name>[a-zA-Z0-9]*)[ |:|"]*(?<value>[\w|.|?|=|&|+| |:|/|\\]*)(?=[ |"]|$)

# finds if statements with only one = sign.
# ID: 2180
if\s[(][A-Za-z]*\s[=]\s

# Yet Another URL Search.  Useful for capturing URLs in raw text.  Ignores URLs in HREF and comments. Turn off  whitespacing to test!
# ID: 1213
# Multiline
\b((https?|ftp|file)://)?([a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+(com\b|edu\b|biz\b|gov\b|in(?:t|fo)\b|mil\b|net\b|org\b|[a-z][a-z]\b)(:\d+)?(/[-a-z0-9_:\@&?=+,.!/~*'%\$]*)*(?<![.,?!])(?!((?!(?:<a )).)*?(?:</a>))(?!((?!(?:<!--)).)*?(?:-->))

# Validates entry for a valid Windows folder name. Excludes all forbidden characters.
# ID: 1652
^[^\\\/\?\*\"\>\<\:\|]*$

# This pattern searches for tags in HTML that should be self closing but currently aren't and self closes them. This is useful if you are doing some HTML parsing.
# ID: 1375
<(?<!\\?|\\/)([^>]*)>\\r*\\n<\\/(?=br|hr|img|input|link|param)[^>]*>

# This pattern matches a decimal value with up to 3 digits after the decimal. Comma is allowed as a thousands separator but not required. N/A is also allowed.
# ID: 590
(^N/A$)|(^[-]?(\d+)(\.\d{0,3})?$)|(^[-]?(\d{1,3},(\d{3},)*\d{3}(\.\d{1,3})?|\d{1,3}(\.\d{1,3})?)$)

# This RX is used to find get all named tags in an html string. If you find a problem with it, please email drew@lordstrange.com
# ID: 98
<[^>]*name[\s]*=[\s]*"?[^\w_]*"?[^>]*>

# Will match a VBScript string and/or comment
# ID: 133
("[^"]*")|('[^\r]*)(\r\n)?

# Validacion de Registro Federal de Contribuyentes (RFC). Para México. Valida 4 caracteres alfabéticos para el nombre, 4 numéricos para la fecha de nacimiento, y, opcional, 3 alfanuméricos para la homoclave, de los cuales, el primero puede ser numérico o alfabético, el segundo es alfabetico y el tercero siempre es numérico.
# ID: 1529
^(?<nombre>\D{4})(?<fechanac>\d{6})(?<homoclave>.{1}\D{1}\d{1})?$

# GLOB the output of an "ls -l" command to extract specific details.  It takes into account issues with older files/directories having a year in place of an hour:minute entry.
# ID: 1651
^([A-Za-z\-]+)\s+(\w+)\s+([A-Za-z0-9_\-\.]+)\s+([A-Za-z0-9_\-\.]+)\s+(\d+)\s+(.{3} [0-9 ]{2} ([0-9][0-9]:[0-9][0-9]| [0-9]{4}))\s+(.+)$

# this expression validates a date-time field in European d/m/y h:m:s format. It is a european variation of Michael Ash's date-validation expression in this library.
# ID: 166
^((((31\/(0?[13578]|1[02]))|((29|30)\/(0?[1,3-9]|1[0-2])))\/(1[6-9]|[2-9]\d)?\d{2})|(29\/0?2\/(((1[6-9]|[2-9]\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))|(0?[1-9]|1\d|2[0-8])\/((0?[1-9])|(1[0-2]))\/((1[6-9]|[2-9]\d)?\d{2})) (20|21|22|23|[0-1]?\d):[0-5]?\d:[0-5]?\d$

# It searches for a IMG tag and group information about source of image.
# ID: 1397
<img[^>]* src=\"([^\"]*)\"[^>]*>

# Evaluates an 'n' series of non decimal numbers separated by a coma
# ID: 3191
^(\d+(,\d+)*)+$

# This can be used to match indian style pincodes / postal codes used by the indian postal departments which are 6 digits long and may have space after the 3rd digit
# ID: 111
^\d{3}\s?\d{3}$

# Only accepts nothing. I know, sounds stupid, but useful for "Invisible Textbox Captcha". Bots will fill in a hidden textbox, and this expression busts them.
# ID: 2770
^.{0,0}

# This regex will match cellphones from Argentina, which have a 15 prefix. It takes into account optional parenthesis and various digit groupings
# ID: 2731
((\(?\d{2,5}\)?)?(\d|-| )?(15((\d|-| ){6,13})))

# Matches a string that contains exactly one letter in the range A-Z or a-z.
# ID: 2978
^[A-Za-z]$

# Matches the numbers 1-10 and only the numbers 1-10.
# ID: 2976
(^[1-9]$)|(^10$)

# Expression 1 of 2 used to check email address syntax.
# ID: 88
^([\w\-\.]+)@((\[([0-9]{1,3}\.){3}[0-9]{1,3}\])|(([\w\-]+\.)+)([a-zA-Z]{2,4}))$

# Expression 2 or 2 for matching email address syntax. This one matches the <angle bracket syntax>.
# ID: 89
^(([-\w \.]+)|(""[-\w \.]+"") )?<([\w\-\.]+)@((\[([0-9]{1,3}\.){3}[0-9]{1,3}\])|(([\w\-]+\.)+)([a-zA-Z]{2,4}))>$

# This is just a very simple matcher for real numbers.
# ID: 999
([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+)|([0-9]+)

# Splits a string by spaces, except when the space is within a quote delimited set of characters. Usefull for splitting search field inputs.
# ID: 2203
\s(?=([^"]*"[^"]*"[^"]*)*$|[^"]*$)

# Validates a YouTube Link
# ID: 2569
^http://\w{0,3}.?youtube+\.\w{2,3}/watch\?v=[\w-]{11}

# This regular expression matches a series of names and/or email addresses much like you would do in Outlook's To field (e.g. To: wrohrbach@carlson.com;miles, er;roemer;lagrander, nitra). The first entry must be a name (in the form of last name followed by a comma and first name) or an email address. The following entries are a semicolon followed by one name or email address. The comma and first name are optional components of the name part.
# ID: 533
^((([a-zA-Z\'\.\-]+)?)((,\s*([a-zA-Z]+))?)|([A-Za-z0-9](([_\.\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\.\-]?[a-zA-Z0-9]+)*)\.([A-Za-z]{2,})))(;{1}(((([a-zA-Z\'\.\-]+){1})((,\s*([a-zA-Z]+))?))|([A-Za-z0-9](([_\.\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\.\-]?[a-zA-Z0-9]+)*)\.([A-Za-z]{2,})){1}))*$

# Validates a UNC to conform to \\server\service
# ID: 542
^\\{2}[\w-]+\\(([\w-][\w-\s]*[\w-]+[$$]?$)|([\w-][$$]?$))

# Maximum 2 digits followed by an optional comma and a valid quarter to be used in time calculations. I wasn't satisfied with the quarter regex posted earlier by Bob Kranson.
# ID: 1394
^\d{1,2}((,)|(,25)|(,50)|(,5)|(,75)|(,0)|(,00))?$

# Word deformed by repeating a character, or a pair of characters. Common in internet communication, can be useful for detecting emotions.
# ID: 3569
(?:\b\w*(\w\w?)\1{2,}\w*\b)

# Recognizes dates of format "[d]d.<slovak name of month>.YYYY". Months part can be either a 3-letter long abbreviation of a month, or full name (with a possible declination suffix).
# ID: 3570
(?:\b(([0-2]\d|3[01])|\d)\.[ ]?(?:jan|feb|mar|apr|máj|jún|júl|aug|sep|okt|nov|dec|január\w{0,2}|február\w{0,2}|mar\w{0,2}|apríl\w{0,2}|máj\w{0,2}|jún\w{0,2}|júl\w{0,2}|august\w{0,2}|septemb\w{0,2}|októb\w{0,2}|novemb\w{0,2}|decemb\w{0,2})[ ][12][0-9]\d\d\b)

# Required and regular expression validator. For supporting
# ID: 944
^[-+]?[0-9]\d{0,2}(\.\d{1,2})?%?$

# A pretty decent URL matching expression.  I've followed most RFC guidelines, so it'll match most anything ya throw at it (And wont match what it's not supposed to).  If you see any problems with it, please email me so I can make the appropriate changes :)
# ID: 1374
(([\w]+:)?//)?(([\d\w]|%[a-fA-f\d]{2,2})+(:([\d\w]|%[a-fA-f\d]{2,2})+)?@)?([\d\w][-\d\w]{0,253}[\d\w]\.)+[\w]{2,4}(:[\d]+)?(/([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)*(\?(&?([-+_~.\d\w]|%[a-fA-f\d]{2,2})=?)*)?(#([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)?

# Matches everything except lines that begin with SEP.
# ID: 2332
^([^S]|S[^E]|SE[^P]).*

# According to RFC 2821 (<see cref="http://tools.ietf.org/html/2821"/>)
# ID: 2558
^((([!#$%&'*+\-/=?^_`{|}~\w])|([!#$%&'*+\-/=?^_`{|}~\w][!#$%&'*+\-/=?^_`{|}~\.\w]{0,}[!#$%&'*+\-/=?^_`{|}~\w]))[@]\w+([-.]\w+)*\.\w+([-.]\w+)*)$

# Validator for New Zealand Mobile phone numbers. Will look for the first number being a 0 and must be a number or either 6 or 7 digits long after to initial (021) suffix
# ID: 1009
(^\([0]\d{2}\))(\d{6,7}$)

# Brazilian CNPJ (xx.xxx.xxx/xxxx-xx)
# ID: 632
(^\d{2}\.\d{3}\.\d{3}\/\d{4}\-\d{2}$)

# Brazilian CEP - (XXXXX-XXX)
# ID: 633
(^\d{5}\-\d{3}$)

# 167 different US telephone patterns. Options includes a)0 or 1 dial, b)area code, c).+-()space between number dial-area code-number.
# ID: 298
(([01][\.\- +]\(\d{3}\)[\.\- +]?)|([01][\.\- +]\d{3}[\.\- +])|(\(\d{3}\) ?)|(\d{3}[- \.]))?\d{3}[- \.]\d{4}

# DESCRIPTION
# ID: 1743
^([-+]?(\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?[r]?|[-+]?((\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?)?[i]|[-+]?(\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?[r]?[-+]((\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?)?[i])$

# This is the same regex pattern as 'Floating Complex Number' but extented by group names. This makes it much easier to extract the parts of the complex number (e.g. string realPart=myMatch.Result("${r}");string imgPart=myMatch.Result("${i}"); ).
# ID: 1744
^((?<r>([-+]?(\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?[r]?))|(?<i>([-+]?((\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?)?[i]))|(?<r>([-+]?(\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?[r]?))(?<i>([-+]((\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?)?[i])))$

# DESCRIPTION
# ID: 1745
^([-+]?(\d+\.?\d*|\d*\.?\d+))$

# DESCRIPTION
# ID: 1746
^([-+]?(\d+\.?\d*|\d*\.?\d+)([Ee][-+]?[0-2]?\d{1,2})?)$

# US zip code expression that disallows 00000 or 00000-0000 for either ZIP or ZIP+4.  Great for web site validation.
# ID: 256
^(?(^00000(|-0000))|(\d{5}(|-\d{4})))$

# Matches all properly formatted integers of 1 or more integer with commas separating each group of 3 integers
# ID: 3381
^((\d{1,3}(,\d{3})*)|(\d{1,3}))$

# This will match results in a template situation. For example:
# ID: 175
@{2}((\S)+)@{2}

# This matches a valid windows filename. Not a valid path.I wanted something simple that covered all the bases
# ID: 2550
^([a-zA-Z]:\\)?[^\x00-\x1F"<>\|:\*\?/]+\.[a-zA-Z]{3,4}$

# This will match valid UK telephone numbers.  This adheres to ofcom's code and number length guide available at http://www.ofcom.org.uk/licensing_numbering/numbers/num_user_guide#1b           Brackets and international codes are not allowed.
# ID: 783
(^0[1-9]\d{1}\s\d{4}\s?\d{4}$)|(^0[1-9]\d{2}\s\d{3}\s?\d{4}$)|(^0[1-9]\d{2}\s\d{4}\s?\d{3}$)|(^0[1-9]\d{3}\s\d{3}\s?\d{2}$)|(^0[1-9]\d{3}\s\d{3}\s?\d{3}$)|(^0[1-9]\d{4}\s\d{3}\s?\d{2}$)|(^0[1-9]\d{4}\s\d{2}\s?\d{3}$)|(^0[1-9]\d{4}\s\d{2}\s?\d{2}$)

# this is regular expression for version number upto 3 digits
# ID: 2446
"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"

# I needed to ensure that a valid hospital number is entered into one of my systems.  They must be prefixed with D,J,F (upper case) and a number (5 to 8 digits in length).
# ID: 3447
[DJF]{1}[0-9]{5,8}

# Matches standard US number formats.
# ID: 3139
^[+-]?\d+(\,\d{3})*\.?\d*\%?$

# Airway bill no that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9.
# ID: 1060
^\d{3}-\d{7}[0-6]{1}$

# forbidden tele numbers when it starts with 0,
# ID: 966
(^0.*[1-9]*)|(^860+)|(^8613)|(\D)|([0-9])

# Matches Visa CC types 13 or 16 digits starting with 4 including Visa CC, Visa ATM only, Visa Electron and Visa Delta.  Safe for international and will NOT match "^(49)" Switch debit cards.
# ID: 1625
(^4\d{12}$)|(^4[0-8]\d{14}$)|(^(49)[^013]\d{13}$)|(^(49030)[0-1]\d{10}$)|(^(49033)[0-4]\d{10}$)|(^(49110)[^12]\d{10}$)|(^(49117)[0-3]\d{10}$)|(^(49118)[^0-2]\d{10}$)|(^(493)[^6]\d{12}$)

# Meastro ONLY card matching - begins with "50" or "56-58" or "6" & 13 to 20 total digits. Overlap of Discover, Solo and Switch is handled and NOT matched.
# ID: 1626
# Multiline
(^(5[0678])\d{11,18}$)|(^(6[^0357])\d{11,18}$)|(^(601)[^1]\d{9,16}$)|(^(6011)\d{9,11}$)|(^(6011)\d{13,16}$)|(^(65)\d{11,13}$)|(^(65)\d{15,18}$)|(^(633)[^34](\d{9,16}$))|(^(6333)[0-4](\d{8,10}$))|(^(6333)[0-4](\d{12}$))|(^(6333)[0-4](\d{15}$))|(^(6333)[5-9](\d{8,10}$))|(^(6333)[5-9](\d{12}$))|(^(6333)[5-9](\d{15}$))|(^(6334)[0-4](\d{8,10}$))|(^(6334)[0-4](\d{12}$))|(^(6334)[0-4](\d{15}$))|(^(67)[^(59)](\d{9,16}$))|(^(6759)](\d{9,11}$))|(^(6759)](\d{13}$))|(^(6759)](\d{16}$))|(^(67)[^(67)](\d{9,16}$))|(^(6767)](\d{9,11}$))|(^(6767)](\d{13}$))|(^(6767)](\d{16}$))

# Matches MasterCard credit cards.  International safe, no overlap with other cards.
# ID: 1627
^5[1-5]\d{14}$

# Discover Credit Card matching.  International safe, no overlap
# ID: 1628
(^(6011)\d{12}$)|(^(65)\d{14}$)

# AMEX Credit Card match.  International safe
# ID: 1629
(^3[47])((\d{11}$)|(\d{13}$))

# Solo Credit Card match.  International safe.
# ID: 1630
# Multiline
(^(6334)[5-9](\d{11}$|\d{13,14}$))|(^(6767)(\d{12}$|\d{14,15}$))

# Switch CC match.  International safe.
# ID: 1631
# Multiline
(^(49030)[2-9](\d{10}$|\d{12,13}$))|(^(49033)[5-9](\d{10}$|\d{12,13}$))|(^(49110)[1-2](\d{10}$|\d{12,13}$))|(^(49117)[4-9](\d{10}$|\d{12,13}$))|(^(49118)[0-2](\d{10}$|\d{12,13}$))|(^(4936)(\d{12}$|\d{14,15}$))|(^(564182)(\d{11}$|\d{13,14}$))|(^(6333)[0-4](\d{11}$|\d{13,14}$))|(^(6759)(\d{12}$|\d{14,15}$))

# JCB cc match.  International safe
# ID: 1632
(^(352)[8-9](\d{11}$|\d{12}$))|(^(35)[3-8](\d{12}$|\d{13}$))

# Diners CC match.  International safe
# ID: 1633
(^(30)[0-5]\d{11}$)|(^(36)\d{12}$)|(^(38[0-8])\d{11}$)

# Cart Blance Credit Card match. International safe
# ID: 1634
^(389)[0-9]{11}$

# EnRoute Credit Card match. international safe.
# ID: 1635
(^(2014)|^(2149))\d{11}$

# Matches any of Solo, Switch or Maestro.  International safe. Will not match on Discover, Visa or Mastercard.  For example; Most recommendations for matching Visa are that they start with "4".  If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.
# ID: 1637
(^(5[0678])\d{11,18}$)|(^(6[^05])\d{11,18}$)|(^(601)[^1]\d{9,16}$)|(^(6011)\d{9,11}$)|(^(6011)\d{13,16}$)|(^(65)\d{11,13}$)|(^(65)\d{15,18}$)|(^(49030)[2-9](\d{10}$|\d{12,13}$))|(^(49033)[5-9](\d{10}$|\d{12,13}$))|(^(49110)[1-2](\d{10}$|\d{12,13}$))|(^(49117)[4-9](\d{10}$|\d{12,13}$))|(^(49118)[0-2](\d{10}$|\d{12,13}$))|(^(4936)(\d{12}$|\d{14,15}$))

# Matches up to three alphabet words separated by spaces with first alphabet character of each word uppercase. Also matches empty strings.
# ID: 243
^([A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,}\040[A-Z]{1}[a-z]{1,})$|^$

# Simple email validator Requires more than three characters for username and domain name
# ID: 3143
([a-zA-Z0-9\_\-\.]+[a-zA-Z0-9\_\-\.]+[a-zA-Z0-9\_\-\.]+)+@([a-zA-z0-9][a-zA-z0-9][a-zA-z0-9]*)+(\.[a-zA-z0-9][a-zA-z0-9][a-zA-z0-9]*)(\.[a-zA-z0-9]+)*

# match string between chars " " as in source code
# ID: 2700
("((\\.)|[^\\"])*")

# match string between chars ' ' as in source code
# ID: 2701
('((\\.)|[^\\'])*')

# Matches any number which includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal.  It matches an unlimited number of decimal places.  It does NOT reject an empty string passed to it.  Credit goes to Al Kahler for posting the original expression from http://regxlib.com/REDetails.aspx?regexp_id=70 along with a fix for the decimal place.
# ID: 2271
^((\$?\-?)|(\-?\$?))([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)?(\.[0-9]*)?$

# Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa, .Aa.Aa. , -Aa-Aa- , _Aa_Aa_ , Aa_Aa_Aa , Aa-Aa-Aa , . , - , _
# ID: 1927
^((\.)?([a-zA-Z0-9_-]?)(\.)?([a-zA-Z0-9_-]?)(\.)?)+$

# [Default]
# ID: 655
(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])(\s{0,1})([AM|PM|am|pm]{2,2})$)|(^([0-9]|[1][0-9]|[2][0-3])(\s{0,1})([AM|PM|am|pm]{2,2})$)

# Matching currency entry with upto 3 letter currency code as prefix
# ID: 3012
^([A-Z]{0,3})?[ ]?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(.[0-9][0-9])?$

# This regex should recognize a Youtube video ID from any Youtube URL, embed snippet, or preview image.
# ID: 3360
(?:youtu\.be\/|youtube.com\/(?:watch\?.*\bv=|embed\/|v\/)|ytimg\.com\/vi\/)(.+?)(?:[^-a-zA-Z0-9]|$)

# will match free floating valid protocol + urls in text ... will not touch the ones wrapped in a tag, so that you can auto-link the ones that aren't :) couple of things to know :
# ID: 703
(\s|\n|^)(\w+://[^\s\n]+)

# .Net full type name with full assembly name
# ID: 1599
^(?<type>(\w+(\.?\w+)+))\s*,\s*(?<assembly>[\w\.]+)(,\s?Version=(?<version>\d+\.\d+\.\d+\.\d+))?(,\s?Culture=(?<culture>\w+))?(,\s?PublicKeyToken=(?<token>\w+))?$

# Checks whether the entered string looks like a URI, with a specified protocol. Optionally, you can add the port number, and some GET variables.
# ID: 2121
^([a-zA-Z]+)://([a-zA-Z0-9_\-]+)((\.[a-zA-Z0-9_\-]+|[0-9]{1,3})+)\.([a-zA-Z]{2,6}|[0-9]{1,3})((:[0-9]+)?)((/[a-zA-Z0-9_\-,.;=%]*)*)((\?[a-zA-Z0-9_\-,.;=&%]*)?)$

# accepts US dallor upto 9,999,999
# ID: 2132
^\$((\d{1})\,\d{1,3}(\,\d{3}))|(\d{1,3}(\,\d{3}))|(\d{1,3})?$

# generate percentage with 2 values after point
# ID: 2133
^(100(?:\.0{1,2})?|0*?\.\d{1,2}|\d{1,2}(?:\.\d{1,2})?)$

# accepts just the web address
# ID: 2134
# Multiline
^((http|https|ftp)\://)?([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.[a-zA-Z]{2,4})(\:[0-9]+)*(/[^/][a-zA-Z0-9\.\,\?\'\\/\+&%\$#\=~_\-]*)*$

# This matches all 5 digit numbers whose first three digits match valid US ZIP code prefixes.
# ID: 3274
(?!00[02-5]|099|213|269|34[358]|353|419|42[89]|51[789]|529|53[36]|552|5[67]8|5[78]9|621|6[348]2|6[46]3|659|69[4-9]|7[034]2|709|715|771|81[789]|8[3469]9|8[4568]8|8[6-9]6|8[68]7|9[02]9|987)\d{5}

# Matches all US ZIP and ZIP+4 codes with vaild prefixes.
# ID: 3275
(?!00[02-5]|099|213|269|34[358]|353|419|42[89]|51[789]|529|53[36]|552|5[67]8|5[78]9|621|6[348]2|6[46]3|659|69[4-9]|7[034]2|709|715|771|81[789]|8[3469]9|8[4568]8|8[6-9]6|8[68]7|9[02]9|987)\d{5}(-\d{4}){0,1}

# Checks for a valid windows file name (Must be used with the case-insensitive option
# ID: 85
^(?!^(PRN|AUX|CLOCK\$|NUL|CON|COM\d|LPT\d|\..*)(\..+)?$)[^\x00-\x1f\\?*:\";|/]+$

# This regex will retreive any text between parenthesis characters (including the parenthesis themselfs)
# ID: 2570
[\(]{1,}((?:(?<t>[^\(]*))[)]{1,})

# Will find any texts within a string that is enclosed within parenthesis ( )
# ID: 2571
[\(]{1,}[^)]*[)]{1,}

# - validates a yyyy-mm-dd, yyyy mm dd, or yyyy/mm/dd date
# ID: 95
^\d{4}[\-\/\s]?((((0[13578])|(1[02]))[\-\/\s]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\-\/\s]?(([0-2][0-9])|(30)))|(02[\-\/\s]?[0-2][0-9]))$

# 0 or one FR +
# ID: 2610
^(FR)?\s?[A-Z0-9-[IO]]{2}[0-9]{9}$

# Indian Postal has siz digit of length and does not start with zero
# ID: 3000
^(?!0{1})\d{6}

# US telephone pattern.  Optional area code with or without '()'.  If area code has parentheses then it is optionally followed by - or space. If no parentheses then it must be followed by - or space.  Number must be separated by either a space or -.
# ID: 742
^(\(\d{3}\)[- ]?|\d{3}[- ])?\d{3}[- ]\d{4}$

# This matches all positive decimal values. There was one here already which claimed to but would fail on value 0.00 which is positive AFAIK...
# ID: 1036
(^\d*\.?\d*[0-9]+\d*$)|(^[0-9]+\d*\.\d*$)

# Matching any valid MS Excel range
# ID: 1098
(^[A-Z]{1,2}[0-9]{1,}:{1}[A-Z]{1,2}[0-9]{1,}$)|(^\$(([A-Z])|([a-z])){1,2}([0-9]){1,}:{1}\$(([A-Z])|([a-z])){1,2}([0-9]){1,}$)|(^\$(([A-Z])|([a-z])){1,2}(\$){1}([0-9]){1,}:{1}\$(([A-Z])|([a-z])){1,2}(\$){1}([0-9]){1,}$)

# Positive real multi-digit  number: don't allow preciding zero, last decimal digit zero not allowed.
# ID: 3188
^([1-9]\d*|0)(([.,]\d*[1-9])?)$

# Checks if the target string is an array consisted of integer numbers or not. An integer array string means that a series of integer numbers that separated by comma (,)
# ID: 3487
^(?:\d+,\s*)*\d+\s*$

# Matches normalized (space separated) phone numbers according to the NANP (North American Numbering Plan). It doesn't support extension numbers.
# ID: 1952
^((\+?(?<CountryCode>1)\s(?<AreaCode>[2-9][0-8][0-9])\s)|((?<AreaCode>[2-9][0-8][0-9])\s))?(?<ExchangeCode>[2-9][0-9][0-9])\s(?<StationCode>[0-9][0-9][0-9][0-9])$

# This expression will match ampersands('&') that are not part an HTML Special Character string.
# ID: 2084
\x26(?!((amp\x3B)|(nbsp\x3B)|(lt\x3B)|(gt\x3B)|(copy\x3B)|(reg\x3B)|(cent\x3B)|(deg\x3B)|(deg\x3B)|(micro\x3B)|(middot\x3B)|(not\x3B)|(para\x3B)|(plusmn\x3B)|(pound\x3B)|(raquo\x3B)|(sect\x3B)|(yen\x3B)|([\x23][0-9]{1,3}\x3B)|(lsquo\x3B)|(rsquo\x3B)|(sbquo\x3B)|(ldquo\x3B)|(rdquo\x3B)|(bdquo\x3B)|(dagger\x3B)|(Dagger\x3B)|(permil\x3B)|(lsaquo\x3B)|(rsaquo\x3B)|(spades\x3B)|(clubs\x3B)|(hearts\x3B)|(diams\x3B)|(oline\x3B)|(larr\x3B)|(uarr\x3B)|(rarr\x3B)|(darr\x3B)|(trade\x3B)|([\x23]x2122\x3B)|(quot\x3B)|(frasl\x3B)|(ndash\x3B)|(mdash\x3B)|(iexcl\x3B)|(cent\x3B)|(curren\x3B)|(brvbar\x3B)|(brvbar\x3B)|(uml\x3B)|(die\x3B)|(ordf\x3B)|(laquo\x3B)|(not\x3B)|(shy\x3B)|(macr\x3B)|(hibar\x3B)|(sup2\x3B)|(sup3\x3B)|(acute\x3B)|(micro\x3B)|(cedil\x3B)|(sup1\x3B)|(ordm\x3B)|(raquo\x3B)|(frac14\x3B)|(frac12\x3B)|(frac34\x3B)|(iquest\x3B)|(Agrave\x3B)|(Aacute\x3B)|(Acirc\x3B)|(Atilde\x3B)|(Auml\x3B)|(Aring\x3B)|(AElig\x3B)|(Ccedil\x3B)|(Egrave\x3B)|(Eacute\x3B)|(Ecirc\x3B)|(Euml\x3B)|(Igrave\x3B)|(Iacute\x3B)|(Icirc\x3B)|(Iuml\x3B)|(ETH\x3B)|(Ntilde\x3B)|(Ograve\x3B)|(Oacute\x3B)|(Ocirc\x3B)|(Otilde\x3B)|(Ouml\x3B)|(times\x3B)|(Oslash\x3B)|(Ugrave\x3B)|(Uacute\x3B)|(Ucirc\x3B)|(Uuml\x3B)|(Yacute\x3B)|(THORN\x3B)|(szlig\x3B)|(agrave\x3B)|(aacute\x3B)|(acirc\x3B)|(atilde\x3B)|(auml\x3B)|(aring\x3B)|(aelig\x3B)|(ccedil\x3B)|(egrave\x3B)|(eacute\x3B)|(ecirc\x3B)|(euml\x3B)|(igrave\x3B)|(iacute\x3B)|(icirc\x3B)|(iuml\x3B)|(eth\x3B)|(ntilde\x3B)|(ograve\x3B)|(oacute\x3B)|(ocirc\x3B)|(otilde\x3B)|(ouml\x3B)|(divide\x3B)|(oslash\x3B)|(ugrave\x3B)|(uacute\x3B)|(ucirc\x3B)|(uuml\x3B)|(yacute\x3B)|(thorn\x3B)|(yuml\x3B)|(Alpha\x3B)|(Alpha\x3B)|(Beta\x3B)|(beta\x3B)|(Gamma\x3B)|(gamma\x3B)|(Delta\x3B)|(delta\x3B)|(Epsilon\x3B)|(epsilon\x3B)|(Zeta\x3B)|(zeta\x3B)|(Eta\x3B)|(eta\x3B)|(Iota\x3B)|(iota\x3B)|(Kappa\x3B)|(kappa\x3B)|(Lambda\x3B)|(lambda\x3B)|(Mu\x3B)|(mu\x3B)|(Nu\x3B)|(nu\x3B)|(Xi\x3B)|(xi\x3B)|(Omicron\x3B)|(omicron\x3B)|(Pi\x3B)|(pi\x3B)|(Rho\x3B)|(rho\x3B)|(Sigma\x3B)|(sigma\x3B)|(Tau\x3B)|(tau\x3B)|(Upsilon\x3B)|(upsilon\x3B)|(Phi\x3B)|(phi\x3B)|(Chi\x3B)|(chi\x3B)|(Psi\x3B)|(psi\x3B)|(Omega\x3B)|(omega\x3B)))

# This will only pull the number off of something like 23rd.
# ID: 3644
([0-9]+)(?:st|nd|rd|th)

# This regular expression match can be used for validating strong password. It expects atleast 1 small-case letter, 1 Capital letter, 1 digit, 1 special character and the length should be between 6-10 characters. The sequence of the characters is not important. This expression follows the above 4 norms specified by microsoft for a strong password.
# ID: 1111
(?=^.{6,10}$)(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()_+}{":;'?/>.<,])(?!.*\s).*$

# This is a slightly modified version of Kurt's DMS Coordinate regex so all the credit should go to Kurt - I just modified it to match a second character that may commonly be used to represent degrees
# ID: 3219
[0-9]{1,2}[:|°|º][0-9]{1,2}[:|'](?:\b[0-9]+(?:\.[0-9]*)?|\.[0-9]+\b)"?[N|S|E|W]

# This regular expression match any valid file path. It checks local drives and network path. The file extension is required.
# ID: 425
^([a-zA-Z]\:|\\\\[^\/\\:*?"<>|]+\\[^\/\\:*?"<>|]+)(\\[^\/\\:*?"<>|]+)+(\.[^\/\\:*?"<>|]+)$

# The basic expression requires at least 1 lower case, 1 upper case, 1 numeric, 1 non-word and no whitespace.
# ID: 1721
^(?=(.*[a-z]){1,})(?=(.*[\d]){1,})(?=(.*[\W]){1,})(?!.*\s).{7,30}$

# Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions
# ID: 1142
^\+?\(?\d+\)?(\s|\-|\.)?\d{1,3}(\s|\-|\.)?\d{4}$

# Regexp to validate Venezuelan Id number Or Cedula de identidad.
# ID: 2330
^[[V|E|J|G]\d\d\d\d\d\d\d\d]{0,9}$

# This RE will match all numbers between (including) 0001 and 9999. Four places of digits are mandatory in this expression.
# ID: 2756
^([1-9]\d{3}|0[1-9]\d{2}|00[1-9]\d{1}|000[1-9]{1})$

# RE to match numbers with value greater than 0.
# ID: 2757
^([\d]*[1-9]+[\d]*)$

# Brazilian ID document, known in Brazil as RG (Registro Geral).
# ID: 1961
(^(\d{2}\x2E\d{3}\x2E\d{3}[-]\d{1})$|^(\d{2}\x2E\d{3}\x2E\d{3})$)

# This is a email validation group to fetch all the valid email address.
# ID: 1260
(?<email>[a-zA-Z][a-zA-Z0-9-_.]+\@[a-zA-Z][a-zA-Z0-9-_]+\.(?(?=[a-zA-Z]{2}\.)([a-zA-Z0-9-_]{2}\.[a-zA-Z0-9-_]{2})|([a-zA-Z0-9-_]{2,3})))

# a simple url validation
# ID: 1103
^[http://www.|www.][\S]+$


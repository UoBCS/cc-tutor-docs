# Introduction

## Purpose and System Scope

The purpose of this platform (CC Tutor) is to enable students to learn efficiently about the
compilation process and its underlying alogrithms and principles.
It is a support for the teacher to tran

The system tackles the gap in educational tools in computer science by providing a distance learning platform
that is focussed towards visualising and interacting with the compilation process algorithms.
Students of compiler construction and formal languages modules can benefit from this tool
in their learning process.

# Overall Description

## System Perspective

The system is comprised of:

- A platform for students
- A platform for teachers
- A generic framework to inspect/debug the compilation process
- A default visualisation package

Each component of the system is visualised in the high-level diagram below:

[Insert diagram here]

## System Functions

### General Features

The general features are in common for both the student and teacher portal.
They include 

### Student Portal

### Teacher Portal

### Inspection Framework

### Default Visualisation Package

### Visualization Package

<Summarize the major functions the product must perform or must let the user perform. Details will be provided in Section 3, so only a high level summary (such as a bullet list) is needed here. Organize the functions to make them understandable to any reader of the SRS. A picture of the major groups of related requirements and how they relate, such as a top level data flow diagram or object class diagram, is often effective.>

## Documentation

<List the user documentation components (such as user manuals, on-line help, and tutorials) that will be delivered along with the software. Identify any known user documentation delivery formats or standards.>

# System Features

## System Feature 1

4.1.1   Description and Priority
<Provide a short description of the feature and indicate whether it is of High, Medium, or Low priority. You could also include specific priority component ratings, such as benefit, penalty, cost, and risk (each rated on a relative scale from a low of 1 to a high of 9).>
4.1.2   Stimulus/Response Sequences
<List the sequences of user actions and system responses that stimulate the behavior defined for this feature. These will correspond to the dialog elements associated with use cases.>
4.1.3   Functional Requirements
<Itemize the detailed functional requirements associated with this feature. These are the software capabilities that must be present in order for the user to carry out the services provided by the feature, or to execute the use case. Include how the product should respond to anticipated error conditions or invalid inputs. Requirements should be concise, complete, unambiguous, verifiable, and necessary. Use “TBD” as a placeholder to indicate when necessary information is not yet available.>

<Each requirement should be uniquely identified with a sequence number or a meaningful tag of some kind.>

REQ-1:  
REQ-2: 

# Other Nonfunctional Requirements

5.1 Performance Requirements
<If there are performance requirements for the product under various circumstances, state them here and explain their rationale, to help the developers understand the intent and make suitable design choices. Specify the timing relationships for real time systems. Make such requirements as specific as possible. You may need to state performance requirements for individual functional requirements or features.>

5.2 Software Quality Attributes
<Specify any additional quality characteristics for the product that will be important to either the customers or the developers. Some to consider are: adaptability, availability, correctness, flexibility, interoperability, maintainability, portability, reliability, reusability, robustness, testability, and usability. Write these to be specific, quantitative, and verifiable when possible. At the least, clarify the relative preferences for various attributes, such as ease of use over ease of learning.>